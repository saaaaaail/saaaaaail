<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>io详解 | sail home</title><meta name="author" content="sail"><meta name="copyright" content="sail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络io详解io模型一个数据操作通常包括:  等待数据到达，复制到内核的缓冲区 把数据从内核缓冲区复制到应用程序缓冲区在Linux网络模型中介绍了5种io模型: 阻塞式io 非阻塞式io 多路复用io 信号驱动io 异步io  阻塞式io用户线程&#x2F;进程发出io系统调用read，cpu会检查内核空间数据有没有复制到内核缓冲区，如果数据ok了，就将数据由内核缓冲区复制到应用程序的缓冲区，应用程序读出数">
<meta property="og:type" content="article">
<meta property="og:title" content="io详解">
<meta property="og:url" content="https://saaaaaail.github.io/saaaaaail/2020/07/24/io%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="sail home">
<meta property="og:description" content="网络io详解io模型一个数据操作通常包括:  等待数据到达，复制到内核的缓冲区 把数据从内核缓冲区复制到应用程序缓冲区在Linux网络模型中介绍了5种io模型: 阻塞式io 非阻塞式io 多路复用io 信号驱动io 异步io  阻塞式io用户线程&#x2F;进程发出io系统调用read，cpu会检查内核空间数据有没有复制到内核缓冲区，如果数据ok了，就将数据由内核缓冲区复制到应用程序的缓冲区，应用程序读出数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://saaaaaail.github.io/saaaaaail/img/post.jpg">
<meta property="article:published_time" content="2020-07-24T13:47:47.000Z">
<meta property="article:modified_time" content="2025-03-16T04:21:42.246Z">
<meta property="article:author" content="sail">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="io">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://saaaaaail.github.io/saaaaaail/img/post.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "io详解",
  "url": "https://saaaaaail.github.io/saaaaaail/2020/07/24/io%E8%AF%A6%E8%A7%A3/",
  "image": "https://saaaaaail.github.io/saaaaaail/img/post.jpg",
  "datePublished": "2020-07-24T13:47:47.000Z",
  "dateModified": "2025-03-16T04:21:42.246Z",
  "author": [
    {
      "@type": "Person",
      "name": "sail",
      "url": "https://saaaaaail.github.io/saaaaaail/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://saaaaaail.github.io/saaaaaail/2020/07/24/io%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'io详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/post.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">sail home</span></a><a class="nav-page-title" href="/"><span class="site-name">io详解</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">io详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-24T13:47:47.000Z" title="发表于 2020-07-24 21:47:47">2020-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-16T04:21:42.246Z" title="更新于 2025-03-16 12:21:42">2025-03-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="网络io详解"><a href="#网络io详解" class="headerlink" title="网络io详解"></a>网络io详解</h1><h2 id="io模型"><a href="#io模型" class="headerlink" title="io模型"></a>io模型</h2><p>一个数据操作通常包括:</p>
<ul>
<li>等待数据到达，复制到内核的缓冲区</li>
<li>把数据从内核缓冲区复制到应用程序缓冲区<br>在Linux网络模型中介绍了5种io模型:</li>
<li>阻塞式io</li>
<li>非阻塞式io</li>
<li>多路复用io</li>
<li>信号驱动io</li>
<li>异步io</li>
</ul>
<h3 id="阻塞式io"><a href="#阻塞式io" class="headerlink" title="阻塞式io"></a>阻塞式io</h3><p>用户线程/进程发出io系统调用read，cpu会检查内核空间数据有没有复制到内核缓冲区，如果数据ok了，就将数据由内核缓冲区复制到应用程序的缓冲区，应用程序读出数据；如果数据还没有准备好，用户线程/进程就会阻塞并让出cpu，直到内核将数据填充到应用程序的缓冲区并唤醒进程/线程。</p>
<p>此过程中进程/线程会阻塞，但是cpu会调度其他进程执行，所以cpu的利用率挺高的。只是执行io系统调用的进程/线程会一直阻塞住。</p>
<p><img src="%E9%98%BB%E5%A1%9E%E5%BC%8Fio.png" alt="阻塞式io"></p>
<h3 id="非阻塞式io"><a href="#非阻塞式io" class="headerlink" title="非阻塞式io"></a>非阻塞式io</h3><p>用户进程发起io系统调用，如果数据没有准备好，就立即返回error状态码。应用程序可以继续执行。但是如果应用程序一定需要io数据的话，就必须不停地轮询进行io系统调用，一旦获得数据就跳出自旋，使用数据。这种方式虽然非阻塞了，但是轮询又浪费了cpu，cpu效率不高。</p>
<p><img src="%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8Fio.png" alt="非阻塞式io"></p>
<h3 id="多路复用io"><a href="#多路复用io" class="headerlink" title="多路复用io"></a>多路复用io</h3><p>这种方式多路指的是多个io资源，复用指的是一个线程管理多个io资源。当这些资源没有一个是可读可写的时候，线程会被阻塞并等待，当一个io资源可读可写说明数据已经就绪，复制到了内核缓冲区中，唤醒线程以非阻塞的方式read，将内核缓冲区的数据复制到用户程序缓冲区中。</p>
<p>可以使用多进程/多线程+阻塞io的方式实现多路复用io的情形，但是如果连接数过多，线程创建与切换会影响cpu的使用率。</p>
<p><img src="%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io.png" alt="多路复用io"></p>
<h3 id="信号驱动io"><a href="#信号驱动io" class="headerlink" title="信号驱动io"></a>信号驱动io</h3><p>在信号驱动io模型中，会给socket注册一个信号驱动的函数sigaction，数据未就绪，进程会继续执行，内核在数据到达时向应用进程发送SIGIO信号，然后信号处理函数会将数据从内核复制到应用进程中，然后在这个函数中进行io处理。这种方式一般用于UDP，类似于待处理的数据。</p>
<h3 id="异步io"><a href="#异步io" class="headerlink" title="异步io"></a>异步io</h3><p>在异步io模型中，用户线程发起一个aio_read()以后会立即返回，线程不会阻塞可以去做其他的事情，内核会等待数据准备完成，然后将数据由内核拷贝到应用程序，这一切完成以后会通知用户线程，用户线程可以直接去使用数据了。</p>
<p>异步io与信号驱动io的区别是:</p>
<ul>
<li>在异步io模型中，收到信号表示io两阶段操作都已完成，直接使用数据即可。</li>
<li>在信号驱动io模型中，收到信号表示数据已经准备好，需要用户线程进行read系统调用去获取数据。</li>
</ul>
<p><img src="%E5%BC%82%E6%AD%A5io.png" alt="异步io"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前四个io模型均为同步io，只有最后一个是真正的异步io。</p>
<ul>
<li>同步io中，数据由内核缓冲区复制到应用程序缓冲区中，应用程序会阻塞。</li>
<li>异步io中，io操作第二阶段也不会阻塞。</li>
</ul>
<p>在同步io中，只有阻塞式io的第一阶段会被阻塞。</p>
<h2 id="io多路复用详解"><a href="#io多路复用详解" class="headerlink" title="io多路复用详解"></a>io多路复用详解</h2><p>select/poll/epoll</p>
<h3 id="谈谈select"><a href="#谈谈select" class="headerlink" title="谈谈select"></a>谈谈select</h3><p>select方法是linux里的一种系统调用方法。select的fd_set是一个1024大小的长整型数组。select与poll都是水平触发模式。即本次轮询结束时有就绪的fd没有处理，下一次再调用会立即返回。</p>
<ul>
<li>将多个socket注册到select中的fd_set中</li>
<li>使用copy_from_user将fd集合从用户空间拷贝到内核空间</li>
<li>注册文件描述符的回调函数__pollwait</li>
<li>然后就是轮询fd集合调用poll方法，也就是上面的回调函数，回调函数会返回一个读写是否就绪的掩码，根据这个掩码给fd_set赋值</li>
<li>如果遍历完fd_set后没有就绪的io设备，就挂起当前进程，直到有设备就绪或者主动超时的时候唤醒当前进程，重新遍历fd_set，判断有没有就绪的fd</li>
<li>如果有就绪的fd了，select立即返回，然后还要再去遍历一遍fd_set获得就绪的文件描述符，读取文件，这一步就是将fd_set由内核再拷贝到用户空间。</li>
</ul>
<h4 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h4><ul>
<li>select每次执行都要将fd集合由用户空间拷贝到内核空间，开销太大。</li>
<li>每次都是轮询整个fd集合，效率不好。</li>
<li>能一次管理的文件描述符有限1024个。</li>
</ul>
<h3 id="谈谈poll"><a href="#谈谈poll" class="headerlink" title="谈谈poll"></a>谈谈poll</h3><p>poll与select类似，解决了select的最后一个缺点就是数量限制，fd_set由数组修改为链表实现。</p>
<h3 id="谈谈epoll"><a href="#谈谈epoll" class="headerlink" title="谈谈epoll"></a>谈谈epoll</h3><p>epoll解决了select前两个缺点。将原先的一个函数拆分为3部分:</p>
<ul>
<li>调用epoll_create方法创建一个epoll对象</li>
<li>调用epoll_ctl向epoll对象中添加socket集合</li>
<li>调用epoll_wait等待事件发生</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这就是一个epoll对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span> &#123;</span><br><span class="line">　　...</span><br><span class="line">　　<span class="comment">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，</span></span><br><span class="line"><span class="comment">　　也就是这个epoll监控的事件*/</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;</span><br><span class="line">　　<span class="comment">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">list_head</span> rdllist;</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个事件都会包装成epitem节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> &#123;</span><br><span class="line">　　...</span><br><span class="line">　　<span class="comment">//红黑树节点</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;</span><br><span class="line">　　<span class="comment">//双向链表节点</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink;</span><br><span class="line">　　<span class="comment">//事件句柄等信息</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd;</span><br><span class="line">　　<span class="comment">//指向其所属的eventepoll对象</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line">　　<span class="comment">//期待的事件类型</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">　　...</span><br><span class="line">&#125;; <span class="comment">// 这里包含每一个事件对应着的信息。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><p>在调用epoll_create方法的时候，内核会构建一个eventpoll结构体，包含两个与epoll相关的成员:</p>
<ul>
<li>struct rb_root rbr 是构建红黑树的头节点，用于存储epoll_ctl传来的socket</li>
<li>struct list_head rdllist 是构建一个双向链表，保存epoll_wait返回给用户的、满足就绪条件的事件</li>
</ul>
<h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><p>epoll_ctl就是epoll的事件注册函数。用于将文件描述符的添加到epoll对象的红黑树中，这样的话，添加、删除、修改事件的时候从红黑树中寻找也非常有效率，然后向内核注册事件的回调函数，用于数据就绪中断发生的时候将事件节点添加到双端链表里面。这个方法在调用时会将所有的fd拷贝到内核空间，而不是在epoll_wait的时候重复拷贝，保证了整个过程中只拷贝一次。</p>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>epoll_wait就会遍历双链表里面有没有就绪的事件节点，不用再遍历所有的文件描述符集合，然后将这里面的事件复制到用户态内存的event数组中，然后将事件数量返回给用户，然后应用程序就可以遍历event数组，进行对应事件的读写操作。  </p>
<p>例子看看：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; )</span><br><span class="line">&#123;</span><br><span class="line">    nfds = <span class="built_in">epoll_wait</span>(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(events[i].data.fd==listenfd) <span class="comment">//有新的连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            connfd = <span class="built_in">accept</span>(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class="comment">//accept这个连接</span></span><br><span class="line">            ev.data.fd=connfd;</span><br><span class="line">            ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class="comment">//将新的fd添加到epoll的监听队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events&amp;EPOLLIN ) <span class="comment">//接收到数据，读socket</span></span><br><span class="line">        &#123;</span><br><span class="line">            n = <span class="built_in">read</span>(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>    <span class="comment">//读</span></span><br><span class="line">            ev.data.ptr = md;     <span class="comment">//md为自定义类型，添加数据</span></span><br><span class="line">            ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class="comment">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">//有数据待发送，写socket</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class="comment">//取数据</span></span><br><span class="line">            sockfd = md-&gt;fd;</span><br><span class="line">            <span class="built_in">send</span>( sockfd, md-&gt;ptr, <span class="built_in">strlen</span>((<span class="type">char</span>*)md-&gt;ptr), <span class="number">0</span> );        <span class="comment">//发送数据</span></span><br><span class="line">            ev.data.fd=sockfd;</span><br><span class="line">            ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class="comment">//修改标识符，等待下一个循环时接收数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//其他的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说:<br>select/poll/epoll都是对linux里设备驱动的poll函数的封装，用来在注册事件的回调函数，并且将当前进程挂当对应设备驱动的等待队列上，由于会依次循环不同事件的poll函数，所以认为每一个事件如果没有就绪都会将进程添加到其等待队列里。</p>
<h5 id="水平触发与边缘触发"><a href="#水平触发与边缘触发" class="headerlink" title="水平触发与边缘触发"></a>水平触发与边缘触发</h5><p>因为读写操作是用户去做的，如果epoll_wait返回了就绪的读写事件，但是用户不去读写的话，就会面临一些问题，所以用下面两种模式来约束一下。</p>
<ul>
<li>水平触发模式 :只要这个文件描述的缓冲区数据没有读干净，那么每次epoll_wait都会返回读事件，提醒用户操作。</li>
<li>边缘触发模式 :当有io事件发生，如果是可读的，就必须将这个文件描述符一直读到空，否则下次不会返回余下的数据，会丢掉事件，但是数据遗留在缓冲区，所以如果读写操作不是非阻塞的，那么最后一次没有数据在就绪的时候就会阻塞住。</li>
</ul>
<h2 id="java中的网络io模型"><a href="#java中的网络io模型" class="headerlink" title="java中的网络io模型"></a>java中的网络io模型</h2><p>java中的io模型包括BIO、NIO、AIO三种。</p>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO是java中Socket的经典的网络编程模型，对于客户端而言就是在某时间去与服务端建立连接，在单线程下对于服务端而言包括下面步骤:</p>
<ul>
<li>socket.accept() 这里会阻塞住等待客户端的连接</li>
<li>socket.getIputStream().read(buffer) 这个方法就是一个阻塞式io，如果数据没有准备好（比如客户端由键盘输入数据，输入完成并发送到达之前，服务端都是阻塞的），这里会阻塞住等待。</li>
<li>接受到数据后处理，客户端断开连接</li>
</ul>
<p>可以看出，BIO在一次通信过程中会阻塞两次。<br>所以BIO要进行并发必须是一个io连接对应一个线程，所以BIO服务器的问题就是大量的连接建立但是又不发送消息长时间占用连接，会使服务器性能下降。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BIO 服务端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> newServerSocket(<span class="number">8080</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动并监听8080端口&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器正在等待连接...&quot;</span>);</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器已接收到连接请求...&quot;</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器正在等待数据...&quot;</span>);</span><br><span class="line">                socket.getInputStream().read(buffer);</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器已经接收到数据&quot;</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> newString(buffer);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到的数据:&quot;</span>+ content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BIO 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> newSocket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> newScanner(System.in);</span><br><span class="line">            message = sc.next();</span><br><span class="line">            socket.getOutputStream().write(message.getBytes());</span><br><span class="line">            socket.close();</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>jdk1.4开始引入了NIO类库，这里的NIO指的是New IO，NIO有标准输入输出NIO与网络编程NIO，主要使用Selector多路复用器来实现，windows通过select实现，linux通过epoll实现。</p>
<p>io是以字节流的方式处理数据，nio是以块的方式处理数据。<br>其中Buffer和Channel是标准NIO的核心对象，写数据或者读数据都要通过一个Channel对象，而Buffer比较类似于要发的数据的载体。在NIO中准备发送的数据要先放到Buffer中，Buffer通过Channel传递数据，然后再通过Buffer从Channel中读取数据，再从Buffer中取数据，最后清理Buffer。</p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>Buffer是一个数组，通常是字节数组，但是也有其他基本数据类型的Buffer。<br>Buffer中使用几个变量来保存当前状态</p>
<ul>
<li>capacity 容量 缓冲区能容纳的元素数量</li>
<li>position 当前位置，指向的是下一次发生读取、写入操作的起始位置</li>
<li>limit 界限，指的是Buffer里有效数据结束以后的第一个索引的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//介绍完几个参数来看看方法flip，将limit设置为之前数据的最后一个，将position设置为0，意味着后面的操作从第一个数据开始，一直到所有有效数据结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clear 将postion置0，limit置为最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Buffer操作顺序:  </p>
<ul>
<li>写数据到Buffer</li>
<li>调用filp()方法，转换Buffer的模式</li>
<li>从Buffer中读数据</li>
<li>clear()或compact()，清理缓冲区，clear会清空所有数据，compact()会清除已经读过的数据。未读的数据会移动到缓冲区的起始位置，新写的数据跟在未读的数据后面</li>
</ul>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel是一个对象，用来读取和写入数据。</p>
<ul>
<li>Channel是双向的，可读可写</li>
<li>Channel具有异步操作的能力</li>
<li>Channel读写通过Buffer</li>
</ul>
<p>Channel对象主要有以下几种:</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel </li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileUseNIO</span><span class="params">(String src,String dst)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="comment">//声明源文件和目标文件</span></span><br><span class="line">            FileInputStream fi=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(src));</span><br><span class="line">            FileOutputStream fo=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(dst));</span><br><span class="line">            <span class="comment">//获得传输通道channel</span></span><br><span class="line">            FileChannel inChannel=fi.getChannel();</span><br><span class="line">            FileChannel outChannel=fo.getChannel();</span><br><span class="line">            <span class="comment">//获得容器buffer</span></span><br><span class="line">            ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">//判断是否读完文件</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">eof</span> <span class="operator">=</span>inChannel.read(buffer);</span><br><span class="line">                <span class="keyword">if</span>(eof==-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//重设一下buffer的position=0，limit=position</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">//开始写</span></span><br><span class="line">                outChannel.write(buffer);</span><br><span class="line">                <span class="comment">//写完要重置buffer，重设position=0,limit=capacity</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            inChannel.close();</span><br><span class="line">            outChannel.close();</span><br><span class="line">            fi.close();</span><br><span class="line">            fo.close();</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>Selector多路复用器提供了一种单线程管理多个连接的非阻塞io方法。将Channel与Channel事件一起注册到Selector中，使Selector监听这个Channel的这个事件。当事件发生select立即返回，并获得就绪事件的集合，在java中就绪事件使用SelectedKey包装，从key中获得Channel，并判断就绪的事件是什么来进行具体地操作。</p>
<p>Selector底层是调用linux的epoll 和poll方法来实现的，EPollArrayWrapper中封装了epoll的三个方法，有时间再看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看到SelectionKey里面关联了Channel、Selector、以及监听的事件、就绪的事件等。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SelectionKey</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">interestOps</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title function_">interestOps</span><span class="params">(<span class="type">int</span> ops)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">readyOps</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//监听读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//监听写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//监听connect操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//监听accept操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// -- Attachments --</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">Object</span> <span class="variable">attachment</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;SelectionKey,Object&gt;</span><br><span class="line">        attachmentUpdater = AtomicReferenceFieldUpdater.newUpdater(</span><br><span class="line">            SelectionKey.class, Object.class, <span class="string">&quot;attachment&quot;</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">attach</span><span class="params">(Object ob)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> attachmentUpdater.getAndSet(<span class="built_in">this</span>, ob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">attachment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> attachment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionKeyImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractSelectionKey</span> &#123;</span><br><span class="line">    <span class="comment">//SelectionKey关联的Channel</span></span><br><span class="line">    <span class="keyword">final</span> SelChImpl channel;</span><br><span class="line">    <span class="comment">//SelectionKey关联的Selector</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SelectorImpl selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">//关联的事件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> interestOps;</span><br><span class="line">    <span class="comment">//就绪的事件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> readyOps;</span><br><span class="line"></span><br><span class="line">    SelectionKeyImpl(SelChImpl var1, SelectorImpl var2) &#123;</span><br><span class="line">        <span class="built_in">this</span>.channel = var1;</span><br><span class="line">        <span class="built_in">this</span>.selector = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureValid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isValid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancelledKeyException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interestOps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensureValid();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.interestOps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改SelectionKey关联的事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> SelectionKey <span class="title function_">interestOps</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensureValid();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.nioInterestOps(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readyOps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensureValid();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.readyOps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nioReadyOps</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.readyOps = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nioReadyOps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.readyOps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SelectionKey <span class="title function_">nioInterestOps</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((var1 &amp; ~<span class="built_in">this</span>.channel().validOps()) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.channel.translateAndSetInterestOps(var1, <span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">this</span>.interestOps = var1;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nioInterestOps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.interestOps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        socketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ready</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (ready == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">accept</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    <span class="keyword">if</span> (accept == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    accept.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    accept.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 读事件</span></span><br><span class="line">                    deal((SocketChannel) key.channel(), key);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="comment">// 写事件</span></span><br><span class="line">                    resp((SocketChannel) key.channel(), key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注：处理完成后要从中移除掉</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selector.close();</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deal</span><span class="params">(SocketChannel channel, SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">responseBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            responseBuffer.put(buffer);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;socket close&quot;</span>);</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">        key.attach(responseBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resp</span><span class="params">(SocketChannel channel, SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        channel.write(buffer);</span><br><span class="line">        <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">            key.attach(<span class="literal">null</span>);</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="nio的零拷贝"><a href="#nio的零拷贝" class="headerlink" title="nio的零拷贝"></a>nio的零拷贝</h4><ul>
<li>要等待dma将数据从硬件设备里面拷贝到</li>
</ul>
<p>要解释零拷贝，首先了解一下，普通的操作系统io数据拷贝过程:</p>
<ul>
<li>由磁盘/socket缓冲区将数据拷贝到内核空间缓冲区。(等待数据就绪) DMA</li>
<li>由内核缓冲区拷贝到应用程序的缓冲区。(读数据) cpu参与复制</li>
<li>由应用程序的缓冲区拷贝到内核缓冲区。(写数据) cpu参与复制</li>
<li>由内核缓冲区拷贝数据到硬盘/网络socket等io设备。DMA    </li>
</ul>
<p>可以看到数据流转过程中经过两次读/写，经过了两次内核态与用户态的切换，所以如果数据仅仅的简单的传输，可以使用零拷贝减少不必要的复制过程。</p>
<p>linux2.4以前 通过sendFile系统调用传送文件:</p>
<ul>
<li>通过 DMA copy 将数据从磁盘读取到 kernel buffer 中 </li>
<li>通过 CPU copy 将数据从 内核缓冲区 copy 到 sokcet的内核缓冲区 中</li>
<li>通过DMA 将socket内核缓冲区的数据拷贝到网卡设备中</li>
</ul>
<p>可见减少了内核态与用户态切换，减少了一次cpu的复制操作。</p>
<p>linux2.4及以后对 sendFile模式进行了改善:  </p>
<ul>
<li>通过DMA将网卡或者磁盘的数据拷贝到内核缓冲区中</li>
<li>CPU不再拷贝数据，而是将位于内核缓冲区的数据的位置和偏移量发给socket 的内核缓冲区  (这一步cpu不拷贝数据，只是把数据地址发给socket的内核)</li>
<li>DMA通过socket内核缓冲区里的数据在内核缓冲区里的内存地址的数据拷贝到网卡磁盘里</li>
</ul>
<p>这样就实现了零拷贝，CPU不再参与数据的拷贝，内核态与用户态之间的数据拷贝次数为0，两次拷贝数据通过DMA完成。</p>
<p>java.nio中通过Channel的transferTo方法实现,将数据由一个Channel传入到另一个可写的Channel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferTo</span><span class="params">(<span class="type">long</span> position,<span class="type">long</span> count,WritableByteChannel target)</span>;</span><br></pre></td></tr></table></figure>
<p>最终依赖sendFile系统调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fileCopyWithFileChannel</span><span class="params">(File fromFile, File toFile)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannelInput</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannelOutput</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fromFile);</span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(toFile);</span><br><span class="line">            <span class="comment">//得到fileInputStream的文件通道</span></span><br><span class="line">            fileChannelInput = fileInputStream.getChannel();</span><br><span class="line">            <span class="comment">//得到fileOutputStream的文件通道</span></span><br><span class="line">            fileChannelOutput = fileOutputStream.getChannel();</span><br><span class="line">            <span class="comment">//将fileChannelInput通道的数据，写入到fileChannelOutput通道</span></span><br><span class="line">            fileChannelInput.transferTo(<span class="number">0</span>, fileChannelInput.size(), fileChannelOutput);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fileChannelInput != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileChannelInput.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fileOutputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fileChannelOutput != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileChannelOutput.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="nio的直接内存"><a href="#nio的直接内存" class="headerlink" title="nio的直接内存"></a>nio的直接内存</h4><p>DirectByteBuffer从内存中分配一段连续的内存，对内存的操作与普通Buffer没有区别，区别在于是使用Unsafe类native方法直接分配的堆外内存。那么堆外内存的释放也由Unsafe类的native方法完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意DirectByteBuffer继承了MappedByteBuffer内存映射的类，而普通的HeapBuffer没有实现内存映射的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectByteBuffer</span> <span class="keyword">extends</span> <span class="title class_">MappedByteBuffer</span> <span class="keyword">implements</span> <span class="title class_">DirectBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Bits.unsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> arrayBaseOffset;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> unaligned;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object att;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner cleaner;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<h5 id="那么为什么要使用直接内存呢？"><a href="#那么为什么要使用直接内存呢？" class="headerlink" title="那么为什么要使用直接内存呢？"></a>那么为什么要使用直接内存呢？</h5><p>首先了解一下数据的拷贝过程，对于Channel的write方法都依赖于IOUtil的write方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="type">long</span> var2, NativeDispatcher var4)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//如果是DirectBuffer，直接写</span></span><br><span class="line">    <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> writeFromNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//非DirectBuffer</span></span><br><span class="line">        <span class="comment">//获取已经读取到的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> var1.position();</span><br><span class="line">        <span class="comment">//获取可以读到的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> var1.limit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> var5 &lt;= var6;</span><br><span class="line">        <span class="comment">//申请一个源buffer可读大小的DirectByteBuffer</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> var5 &lt;= var6 ? var6 - var5 : <span class="number">0</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">var8</span> <span class="operator">=</span> Util.getTemporaryDirectBuffer(var7);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> var10;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            var8.put(var1);</span><br><span class="line">            var8.flip();</span><br><span class="line">            var1.position(var5);</span><br><span class="line">            <span class="comment">//通过DirectBuffer写</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">var9</span> <span class="operator">=</span> writeFromNativeBuffer(var0, var8, var2, var4);</span><br><span class="line">            <span class="keyword">if</span> (var9 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                var1.position(var5 + var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var10 = var9;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//回收分配的DirectByteBuffer</span></span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(var8);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当Buffer是DirectBuffer时会直接调用writeFromNativeBuffer方法，当Buffer是HeapBuffer时会先申请一个直接内存，然后将堆内存拷贝到直接内存，然后在进行write操作系统调用。</p>
<h5 id="可以知道，nio在使用堆内存进行io操作之前会先拷贝到堆外内存，是为什么呢？"><a href="#可以知道，nio在使用堆内存进行io操作之前会先拷贝到堆外内存，是为什么呢？" class="headerlink" title="可以知道，nio在使用堆内存进行io操作之前会先拷贝到堆外内存，是为什么呢？"></a>可以知道，nio在使用堆内存进行io操作之前会先拷贝到堆外内存，是为什么呢？</h5><p>因为指向native方法的线程被认为是处于safepoint，可能会发生GC，导致堆内存重排。</p>
<p>传统的BIO的write方法数据使用字节数组传递，而NIO的write方法为了提高效率，数据仅仅通过内存地址传递，所以如果在native方法时发生了GC就会导致HeapBuffer的内存地址变化，因此要使用DirectBuffer来暂存保证内存地址不会被修改。</p>
<p>所以HeapBuffer数据拷贝的顺序应该是</p>
<blockquote>
<p>网络 –&gt; 临时的DirectByteBuffer –&gt; 应用 HeapByteBuffer –&gt; 临时的DirectByteBuffer –&gt; 网络</p>
</blockquote>
<p>如果直接使用DirectByteBuffer的数据拷贝顺序是</p>
<blockquote>
<p>网络 –&gt; 应用 DirectByteBuffer –&gt; 网络</p>
</blockquote>
<h5 id="申请堆外内存意味着java需要对这一块内存进行管理"><a href="#申请堆外内存意味着java需要对这一块内存进行管理" class="headerlink" title="申请堆外内存意味着java需要对这一块内存进行管理"></a>申请堆外内存意味着java需要对这一块内存进行管理</h5><p>DirectByteBuffer中使用Bits对象申请堆外内存，其中有一个变量totalCapacity记录已经分配的堆外内存的总大小，然后jvm通过-XX:MaxDirectMemorySize参数设置堆外内存的大小限制。</p>
<p>在DirectByteBuffer的构造方法里会预分配堆外内存，如果分配空间不足就会调用System.gc()方法来触发full gc期待能回收一点堆外内存，如果gc以后还是不足会抛OOM(因此如果堆外内存不够的话也是会抛OOM的),如果内存足够了就会使用Unsafe类去分配内存，返回内存基址。</p>
<h5 id="DirectByteBuffer的回收"><a href="#DirectByteBuffer的回收" class="headerlink" title="DirectByteBuffer的回收"></a>DirectByteBuffer的回收</h5><p>DirectByteBuffer是一个冰山对象，存在于堆里的对象DirectByteBuffer很小，包括内存基地址、大小等属性以及Cleaner对象用来做内存回收，但其指向了一大堆内存。</p>
<p>DirectByteBuffer对象的Cleaner对象实现了PhantomReference接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cleaner</span> <span class="keyword">extends</span> <span class="title class_">PhantomReference</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; dummyQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Cleaner</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Cleaner</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Cleaner</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable thunk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cleaner</span><span class="params">(Object var1, Runnable var2)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1, dummyQueue);</span><br><span class="line">        <span class="built_in">this</span>.thunk = var2;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.thunk.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                            (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.exit(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Cleaner实现了虚引用接口，其构造方法将DirectByteBuffer对象与虚引用队列传递给了父类，也就是给DirectByteBuffer对象加上了虚引用。当DirectByteBuffer对象被回收以后，就会将cleaner对象放到虚引用队列里面，然后使用一个ReferenceHandle线程处理这个队列，如果从队列里面取出了Cleaner对象就执行它的clean方法，执行trunk.run方法，这个trunk其实是Deallocator类实现了Runnable接口的嵌套类，其run方法会调用unsafe.freeMemory(long address)方法来释放堆外内存。</p>
<p>当然还有个问题就是，如果DirectByteBuffer对象经过几次Y gc进入了老年代以后很难回收掉，就会长期占用堆外内存。因此使用堆外内存要求手动回收。</p>
<h4 id="nio的内存映射"><a href="#nio的内存映射" class="headerlink" title="nio的内存映射"></a>nio的内存映射</h4><p>linux中使用mmap内存映射，将文件映射到应用程序的缓冲区，那么文件位于哪儿？文件描述符经由我们open系统调用后获得，自然是位于内核缓冲区，将位于内核空间的文件映射到应用程序缓冲区，减少了由内核空间到用户空间的数据拷贝，以及用户态与内核态的切换。</p>
<ul>
<li>发出mmap系统调用，导致用户空间到内核空间的上下文切换(第一次上下文切换)。通过DMA引擎将磁盘文件中的内容拷贝到内核空间缓冲区中(第一次拷贝: hard drive ——&gt; kernel buffer)。</li>
<li>mmap系统调用返回，导致内核空间到用户空间的上下文切换(第二次上下文切换)。接着用户空间和内核空间共享这个缓冲区，而不需要将数据从内核空间拷贝到用户空间。因为用户空间和内核空间共享了这个缓冲区数据，所以用户空间就可以像在操作自己缓冲区中数据一般操作这个由内核空间共享的缓冲区数据。</li>
<li>发出write系统调用，导致用户空间到内核空间的上下文切换(第三次上下文切换)。将数据从内核空间缓冲区拷贝到内核空间socket相关联的缓冲区(第二次拷贝: kernel buffer ——&gt; socket buffer)。</li>
<li>write系统调用返回，导致内核空间到用户空间的上下文切换(第四次上下文切换)。通过DMA引擎将内核空间socket缓冲区中的数据传递到协议引擎(第三次拷贝: socket buffer ——&gt; protocol engine)</li>
</ul>
<p>在java中使用FileChannel.map方法来将文件映射到MappedByteBuffer中，有三种模式:</p>
<ul>
<li>FileChannel.MapMode.READ_ONLY:产生只读缓冲区，对缓冲区的写入操作将导致ReadOnlyBufferException</li>
<li>FileChannel.MapMode.READ_WRITE:产生可写缓冲区，任何修改将在某个时刻由内核缓冲区写回到磁盘文件中，而这某个时刻是依赖OS的，其他映射同一个文件的程序可能不能立即看到这些修改，多个程序同时进行文件映射的确切行为是依赖于系统的，但是它是线程安全的</li>
<li>FileChannel.MapMode.PRIVATE:产生可写缓冲区，但任何修改是缓冲区私有的，不会回到文件中</li>
</ul>
<p>这种方式处理大文件很方便，避免了文件的拷贝，而且由于零拷贝无法修改数据，因此有数据修改需求的时候可以使用内存映射缓冲区来做，修改完的数据就是映射到的内核空间的数据。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://saaaaaail.github.io/saaaaaail">sail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://saaaaaail.github.io/saaaaaail/2020/07/24/io%E8%AF%A6%E8%A7%A3/">https://saaaaaail.github.io/saaaaaail/2020/07/24/io%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://saaaaaail.github.io/saaaaaail" target="_blank">sail home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/io/">io</a></div><div class="post-share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2020/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/" title="计算机网络知识点记录"><img class="cover" src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">计算机网络知识点记录</div></div><div class="info-2"><div class="info-item-1">计算机网络物理层链路层数据成帧链路层对数据封装成帧，给网络层传下来的分组添加首部尾部，标记为一个帧。 透明传输透明传输传的是转义字符，为了避免数据帧与结束标识符相同，需要给数据帧中的结束标识符前面加上转移标识符，在取出数据的时候会消掉，因此是透明的 差错检测循环冗余检验（CRC）来检查比特差错。 信道分类广播信道这种是一对多，同时有多个节点要使用广播信道，因此就要避免冲突。避免冲突的方式有 信道复用技术 与 CSMA/CD协议  点对点信道这种一对一通信，比较简单使用ppp协议进行控制 信道复用技术频分复用不同节点主机 同时使用信道，但是占用不同的频率带宽资源。   时分复用不同节点主机 占用相同的频率带宽，但是占用不同的时间片 统计时分复用以上两种都是提前规定了信道使用的方式，利用率很低。这种 不固定不同主机使用时分复用帧的顺序或者位置，有数据来就集中起来组成统计时分复用帧发生。 波分复用光的频分复用。对于光 常使用波长来表示光载波。   码分复用即给每个用户分配 m bit的码片，不同用户的码片相交 是等于0，那么m bit位组成一个串S就可以表示一个用户的 1...</div></div></div></a><a class="pagination-related" href="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" title="设计模式详解"><img class="cover" src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">设计模式详解</div></div><div class="info-2"><div class="info-item-1"> https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md  设计原则主要是为了解耦，模块间减少依赖，职责分明，支持扩展。  单一职责原则 里氏替换原则 子类必须完全实现父类方法 子类可以有个性 子类覆盖或实现父类方法时 入参可以被放大 子类重写或实现父类方法时 输出结果可以被缩小   依赖倒置原则 模块间依赖通过接口或抽象类产生   接口隔离原则 迪米特法则 一个类尽量耦合   开闭原则...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/" title="计算机网络知识点记录"><img class="cover" src="/img/post.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-17</div><div class="info-item-2">计算机网络知识点记录</div></div><div class="info-2"><div class="info-item-1">计算机网络物理层链路层数据成帧链路层对数据封装成帧，给网络层传下来的分组添加首部尾部，标记为一个帧。 透明传输透明传输传的是转义字符，为了避免数据帧与结束标识符相同，需要给数据帧中的结束标识符前面加上转移标识符，在取出数据的时候会消掉，因此是透明的 差错检测循环冗余检验（CRC）来检查比特差错。 信道分类广播信道这种是一对多，同时有多个节点要使用广播信道，因此就要避免冲突。避免冲突的方式有 信道复用技术 与 CSMA/CD协议  点对点信道这种一对一通信，比较简单使用ppp协议进行控制 信道复用技术频分复用不同节点主机 同时使用信道，但是占用不同的频率带宽资源。   时分复用不同节点主机 占用相同的频率带宽，但是占用不同的时间片 统计时分复用以上两种都是提前规定了信道使用的方式，利用率很低。这种 不固定不同主机使用时分复用帧的顺序或者位置，有数据来就集中起来组成统计时分复用帧发生。 波分复用光的频分复用。对于光 常使用波长来表示光载波。   码分复用即给每个用户分配 m bit的码片，不同用户的码片相交 是等于0，那么m bit位组成一个串S就可以表示一个用户的 1...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">sail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9Cio%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">网络io详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">io模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8Fio"><span class="toc-number">1.1.1.</span> <span class="toc-text">阻塞式io</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8Fio"><span class="toc-number">1.1.2.</span> <span class="toc-text">非阻塞式io</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io"><span class="toc-number">1.1.3.</span> <span class="toc-text">多路复用io</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io"><span class="toc-number">1.1.4.</span> <span class="toc-text">信号驱动io</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5io"><span class="toc-number">1.1.5.</span> <span class="toc-text">异步io</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">io多路复用详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88select"><span class="toc-number">1.2.1.</span> <span class="toc-text">谈谈select</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">select缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88poll"><span class="toc-number">1.2.2.</span> <span class="toc-text">谈谈poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88epoll"><span class="toc-number">1.2.3.</span> <span class="toc-text">谈谈epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-create"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">epoll_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-ctl"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">epoll_ctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-wait"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">epoll_wait</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">水平触发与边缘触发</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">java中的网络io模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO"><span class="toc-number">1.3.1.</span> <span class="toc-text">BIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO"><span class="toc-number">1.3.2.</span> <span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nio%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">nio的零拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nio%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">nio的直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%91%A2%EF%BC%9F"><span class="toc-number">1.3.2.6.1.</span> <span class="toc-text">那么为什么要使用直接内存呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E7%9F%A5%E9%81%93%EF%BC%8Cnio%E5%9C%A8%E4%BD%BF%E7%94%A8%E5%A0%86%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8Cio%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%89%8D%E4%BC%9A%E5%85%88%E6%8B%B7%E8%B4%9D%E5%88%B0%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%EF%BC%8C%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">1.3.2.6.2.</span> <span class="toc-text">可以知道，nio在使用堆内存进行io操作之前会先拷贝到堆外内存，是为什么呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%84%8F%E5%91%B3%E7%9D%80java%E9%9C%80%E8%A6%81%E5%AF%B9%E8%BF%99%E4%B8%80%E5%9D%97%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.2.6.3.</span> <span class="toc-text">申请堆外内存意味着java需要对这一块内存进行管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DirectByteBuffer%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.2.6.4.</span> <span class="toc-text">DirectByteBuffer的回收</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nio%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">nio的内存映射</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/16/hello-world/" title="Hello World"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2025/03/16/hello-world/" title="Hello World">Hello World</a><time datetime="2025-03-16T04:21:42.245Z" title="发表于 2025-03-16 12:21:42">2025-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/01/%E9%98%BF%E9%87%8C%E7%9A%84maven%E4%BE%9D%E8%B5%96http%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/" title="阿里的maven依赖http失效问题"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里的maven依赖http失效问题"/></a><div class="content"><a class="title" href="/2020/12/01/%E9%98%BF%E9%87%8C%E7%9A%84maven%E4%BE%9D%E8%B5%96http%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/" title="阿里的maven依赖http失效问题">阿里的maven依赖http失效问题</a><time datetime="2020-12-01T09:31:49.000Z" title="发表于 2020-12-01 17:31:49">2020-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/04/Tomcat%E5%AE%9A%E6%97%B6%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/" title="Tomcat定时检查服务状态的启动脚本"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tomcat定时检查服务状态的启动脚本"/></a><div class="content"><a class="title" href="/2020/11/04/Tomcat%E5%AE%9A%E6%97%B6%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/" title="Tomcat定时检查服务状态的启动脚本">Tomcat定时检查服务状态的启动脚本</a><time datetime="2020-11-04T03:29:25.000Z" title="发表于 2020-11-04 11:29:25">2020-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/11/RocketMQ%E8%AF%A6%E8%A7%A3/" title="RocketMQ详解"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ详解"/></a><div class="content"><a class="title" href="/2020/09/11/RocketMQ%E8%AF%A6%E8%A7%A3/" title="RocketMQ详解">RocketMQ详解</a><time datetime="2020-09-11T07:28:43.000Z" title="发表于 2020-09-11 15:28:43">2020-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/04/zookeeper/" title="zookeeper"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="zookeeper"/></a><div class="content"><a class="title" href="/2020/09/04/zookeeper/" title="zookeeper">zookeeper</a><time datetime="2020-09-04T06:58:11.000Z" title="发表于 2020-09-04 14:58:11">2020-09-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By sail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 5.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>