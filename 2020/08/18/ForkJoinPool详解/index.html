<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ForkJoinPool详解 | sail home</title><meta name="author" content="sail"><meta name="copyright" content="sail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="文章参考博客分析jdk-1.8-ForkJoinPool实现原理(上)、分析jdk-1.8-ForkJoinPool实现原理(下)  ForkJoinPool详解 介绍一下forkJoinPool?这个线程池是ExecutorsService的另一个分支，用在多核CPU，而且任务可以拆分为子任务去解决的那种情况。里面会默认创建cpu核数的工作线程，每个工作线程具有自己的阻塞队列，从对尾取自己得任">
<meta property="og:type" content="article">
<meta property="og:title" content="ForkJoinPool详解">
<meta property="og:url" content="https://saaaaaail.github.io/saaaaaail/2020/08/18/ForkJoinPool%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="sail home">
<meta property="og:description" content="文章参考博客分析jdk-1.8-ForkJoinPool实现原理(上)、分析jdk-1.8-ForkJoinPool实现原理(下)  ForkJoinPool详解 介绍一下forkJoinPool?这个线程池是ExecutorsService的另一个分支，用在多核CPU，而且任务可以拆分为子任务去解决的那种情况。里面会默认创建cpu核数的工作线程，每个工作线程具有自己的阻塞队列，从对尾取自己得任">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://saaaaaail.github.io/saaaaaail/img/butterfly-icon.png">
<meta property="article:published_time" content="2020-08-18T12:57:25.000Z">
<meta property="article:modified_time" content="2025-03-16T04:21:42.244Z">
<meta property="article:author" content="sail">
<meta property="article:tag" content="juc">
<meta property="article:tag" content="java并发">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://saaaaaail.github.io/saaaaaail/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ForkJoinPool详解",
  "url": "https://saaaaaail.github.io/saaaaaail/2020/08/18/ForkJoinPool%E8%AF%A6%E8%A7%A3/",
  "image": "https://saaaaaail.github.io/saaaaaail/img/butterfly-icon.png",
  "datePublished": "2020-08-18T12:57:25.000Z",
  "dateModified": "2025-03-16T04:21:42.244Z",
  "author": [
    {
      "@type": "Person",
      "name": "sail",
      "url": "https://saaaaaail.github.io/saaaaaail/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://saaaaaail.github.io/saaaaaail/2020/08/18/ForkJoinPool%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ForkJoinPool详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 5.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">sail home</span></a><a class="nav-page-title" href="/"><span class="site-name">ForkJoinPool详解</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">ForkJoinPool详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-18T12:57:25.000Z" title="发表于 2020-08-18 20:57:25">2020-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-16T04:21:42.244Z" title="更新于 2025-03-16 12:21:42">2025-03-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>文章参考博客<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/de025df55363">分析jdk-1.8-ForkJoinPool实现原理(上)</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/44b09f52a225">分析jdk-1.8-ForkJoinPool实现原理(下)</a></p>
</blockquote>
<h1 id="ForkJoinPool详解"><a href="#ForkJoinPool详解" class="headerlink" title="ForkJoinPool详解"></a>ForkJoinPool详解</h1><blockquote>
<p>介绍一下forkJoinPool?<br>这个线程池是ExecutorsService的另一个分支，用在多核CPU，而且任务可以拆分为子任务去解决的那种情况。里面会默认创建cpu核数的工作线程，每个工作线程具有自己的阻塞队列，从对尾取自己得任务，如果自己阻塞队列里面没有任务了去其他工作线程的队头去偷任务。</p>
</blockquote>
<p>分开又合并，分而治之。</p>
<p>核心算法是work-stealing算法，翻译过来是工作窃取算法。</p>
<p>有三个重要角色:</p>
<ul>
<li>ForkJoinWorkerThread ，包装Thread，后面简称worker线程</li>
<li>workQueue ， 双向工作队列</li>
<li>ForkJoinTask ，worker线程执行对象，实现了Future。两种类型，一种叫submission，另一种就叫task。</li>
</ul>
<p>ForkJoinPool使用数组保存了所有WorkQueue（workQueue[]），每个worker都有自己的workQueue，不是所有workQueue都有自己的worker。</p>
<ul>
<li>没有worker的WorkQueue：保存的是submission，来自外部提交，在WorkQueue[]的下标是偶数；</li>
<li>属于worker的WorkQueue：保存的是task，在WorkQueue[]的下标是奇数。</li>
</ul>
<p>WorkerQueue是一个双端队列，同时支持作为栈的push、pop操作，也支持作为队列的offer、poll操作，worker线程处理自己的workerQueue与之前的线程池取任务不一样，这里是当作栈来使用的，先进后出的方式处理workerQueue里的任务，除此之外worker线程偷其他worker的workerQueue是当作队列来处理的，也就是当队列里有多个任务的时候，worker去取任务不会与其他worker争用任务。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism,</span></span><br><span class="line"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span><br><span class="line"><span class="params">                     UncaughtExceptionHandler handler,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">                     String workerNamePrefix)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    <span class="built_in">this</span>.ueh = handler;</span><br><span class="line">    <span class="built_in">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="type">long</span> <span class="variable">np</span> <span class="operator">=</span> (<span class="type">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="built_in">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>parallelism</strong>：默认是cpu的核心数，ForkJoinPool的线程数量依据与它，但不表示ThreadPoolExecutor的核心线程数和最大线程数。  </p>
<p><strong>factory</strong>：ThreadFactory，实现newThread方法即可。</p>
<p><strong>config</strong>：config保存不变的参数，包括parallelism和mode。</p>
<p><strong>ctl</strong>：是ForkJoinPool中最重要的控制手段，将下面信息按16bit为一组保存在ctl这个long整型里。</p>
<ul>
<li>AC: 活动的worker数量</li>
<li>TC: 总共的worker数量</li>
<li>SS: WorkerQueue状态，第1位表示active还是inactive，其余十五位表示版本号，ABA</li>
<li>ID：保存一个WorkQueue在WorkQueue[]的下标，和其他worker通过字段stackPred组成一个TreiberStack。后文讲的栈顶，指这里下标所在的WorkQueue。</li>
</ul>
<p>TreiberStack：这个栈的pull和pop使用了CAS，所以支持并发下的无锁操作。</p>
<h2 id="ForkJoinPool状态修改"><a href="#ForkJoinPool状态修改" class="headerlink" title="ForkJoinPool状态修改"></a>ForkJoinPool状态修改</h2><p>在介绍里面的方法之前先看看线程池的状态</p>
<ul>
<li>STARTED</li>
<li>STOP</li>
<li>TERMINATED</li>
<li>SHUTDOWN<br>以上四种，线程池的标准状态</li>
<li>RSLOCK</li>
<li>RSIGNAL<br>runState是线程池的状态，在修改状态之前要获得锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState bits: SHUTDOWN must be negative, others arbitrary powers of two</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">RSLOCK</span>     <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">RSIGNAL</span>    <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">STARTED</span>    <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">STOP</span>       <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">TERMINATED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">SHUTDOWN</span>   <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="任务ForkJoinTask"><a href="#任务ForkJoinTask" class="headerlink" title="任务ForkJoinTask"></a>任务ForkJoinTask</h2><p>ForkJoinPool执行任务的对象是ForkJoinTask，它是一个抽象类，有两个具体实现类RecursiveAction和RecursiveTask。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RecursiveAction</span> <span class="keyword">extends</span> <span class="title class_">ForkJoinTask</span>&lt;Void&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title function_">getRawResult</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setRawResult</span><span class="params">(Void mustBeNull)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">exec</span><span class="params">()</span> &#123;</span><br><span class="line">        compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RecursiveTask</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">ForkJoinTask</span>&lt;V&gt; &#123;</span><br><span class="line">    V result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title function_">compute</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getRawResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setRawResult</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        result = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">exec</span><span class="params">()</span> &#123;</span><br><span class="line">        result = compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForkJoinTask的抽象方法exec由RecursiveAction和RecursiveTask实现，它被定义为final，具体的执行步骤compute延迟到子类实现。很容易看出RecursiveAction和RecursiveTask的区别，前者没有result，getRawResult返回空，它们对应不需要返回结果和需要返回结果两种场景。</p>
<p>ForkJoinTask里很重要的字段是它的状态status，默认是0，当得出结果时变更为负数，有三种结果：</p>
<p>NORMAL<br>CANCELLED<br>EXCEPTIONAL<br>除此之外，在得出结果之前，任务状态能够被设置为SIGNAL，表示有线程等待这个任务的结果，执行完成后需要notify通知，具体看后文的join。</p>
<p>ForkJoinTask在触发执行后，并不支持其他什么特别操作，只能等待任务执行完成。CountedCompleter是ForkJoinTask的子类，它在子任务协作方面扩展了更多操作。</p>
<h2 id="ForkJoinTask在pool里的提交"><a href="#ForkJoinTask在pool里的提交" class="headerlink" title="ForkJoinTask在pool里的提交"></a>ForkJoinTask在pool里的提交</h2><p>有三种，分别是submit、execute、invoke</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        externalPush(task);</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">        ForkJoinTask&lt;T&gt; job = <span class="keyword">new</span> <span class="title class_">ForkJoinTask</span>.AdaptedCallable&lt;T&gt;(task);</span><br><span class="line">        externalPush(job);</span><br><span class="line">        <span class="keyword">return</span> job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">        ForkJoinTask&lt;T&gt; job = <span class="keyword">new</span> <span class="title class_">ForkJoinTask</span>.AdaptedRunnable&lt;T&gt;(task, result);</span><br><span class="line">        externalPush(job);</span><br><span class="line">        <span class="keyword">return</span> job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ForkJoinTask&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        ForkJoinTask&lt;?&gt; job;</span><br><span class="line">        <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">            job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            job = <span class="keyword">new</span> <span class="title class_">ForkJoinTask</span>.AdaptedRunnableAction(task);</span><br><span class="line">        externalPush(job);</span><br><span class="line">        <span class="keyword">return</span> job;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>submit方法支持Runnable和Callable，通过适配器适配成ForkJoinTask。返回的值当前的FoekJoinTask</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//execute</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Arranges for (asynchronous) execution of the given task.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        externalPush(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AbstractExecutorService methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        ForkJoinTask&lt;?&gt; job;</span><br><span class="line">        <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">            job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            job = <span class="keyword">new</span> <span class="title class_">ForkJoinTask</span>.RunnableExecuteAction(task);</span><br><span class="line">        externalPush(job);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>execute是没有返回值的提交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invoke</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        externalPush(task);</span><br><span class="line">        <span class="keyword">return</span> task.join();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>invoke是返回join结果的提交。</p>
<p>可以看到所有提交的任务都进externalPush方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> ThreadLocalRandom.getProbe();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runState;</span><br><span class="line">        <span class="comment">//工作队列数组不是空，从数组中选定一个queue也不是空，</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (q = ws[m &amp; r &amp; SQMASK]) != <span class="literal">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            ForkJoinTask&lt;?&gt;[] a; <span class="type">int</span> am, n, s;</span><br><span class="line">            <span class="keyword">if</span> ((a = q.array) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                <span class="comment">//在队尾top处添加task</span></span><br><span class="line">                U.putOrderedObject(a, j, task);</span><br><span class="line">                U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                U.putIntVolatile(q, QLOCK, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//那么现在将task加入到队列中，之后要启用worker线程来执行它，signalWork</span></span><br><span class="line">                <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        externalSubmit(task);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">        <span class="type">int</span> r;                                    <span class="comment">// initialize caller&#x27;s probe</span></span><br><span class="line">        <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            ThreadLocalRandom.localInit();</span><br><span class="line">            r = ThreadLocalRandom.getProbe();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            WorkQueue[] ws; WorkQueue q; <span class="type">int</span> rs, m, k;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">move</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//1</span></span><br><span class="line">            <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                tryTerminate(<span class="literal">false</span>, <span class="literal">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                     ((ws = workQueues) == <span class="literal">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                rs = lockRunState();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                        U.compareAndSwapObject(<span class="built_in">this</span>, STEALCOUNTER, <span class="literal">null</span>,</span><br><span class="line">                                               <span class="keyword">new</span> <span class="title class_">AtomicLong</span>());</span><br><span class="line">                        <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                        n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                        n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        workQueues = <span class="keyword">new</span> <span class="title class_">WorkQueue</span>[n];</span><br><span class="line">                        ns = STARTED;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> q.top;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">submitted</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                        <span class="keyword">if</span> ((a != <span class="literal">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                            (a = q.growArray()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                            U.putOrderedObject(a, j, task);</span><br><span class="line">                            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                            submitted = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">                        signalWork(ws, q);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                move = <span class="literal">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">                q = <span class="keyword">new</span> <span class="title class_">WorkQueue</span>(<span class="built_in">this</span>, <span class="literal">null</span>);</span><br><span class="line">                q.hint = r;</span><br><span class="line">                q.config = k | SHARED_QUEUE;</span><br><span class="line">                q.scanState = INACTIVE;</span><br><span class="line">                rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">                <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    k &lt; ws.length &amp;&amp; ws[k] == <span class="literal">null</span>)</span><br><span class="line">                    ws[k] = q;                 <span class="comment">// else terminated</span></span><br><span class="line">                unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                move = <span class="literal">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">            <span class="keyword">if</span> (move)</span><br><span class="line">                r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上就是线程池提交任务的流程，对于externalSubmit方法是externalPush方法的完整版。<br>只介绍一下externalSubmit:<br>mark1检查运行状态是否已经进入SHUTDOWN，抛出拒收的异常。对于ForkJoinPool的关闭，见后文“关闭ForkJoinPool”一节。</p>
<p>第一次执行externalSubmit时，运行状态还没有STARTED，执行mark2进行初始化操作：</p>
<p>按2的幂设置WorkQueue[]的长度<br>设置原子对象stealCounter<br>运行状态进入STARTED<br>第二次循环中，执行mark4，创建第一个WorkQueue。这个工作队列是没有worker线程对应的，因此它位于workQueue[]的偶数位。</p>
<blockquote>
<p>ForkJoinPool中的这些WorkQueue和工作线程ForkJoinWorkerThread并不是一对一的关系，而是随时都有多于ForkJoinWorkerThread数量的WorkQueue元素。而这个ForkJoinPool中的WorkQueue数组中，索引位为非奇数的工作队列用于存储从外部提交到ForkJoinPool中的任务，也就是所谓的submissions queue；索引位为奇数的工作队列用于存储归并计算过程中等待处理的子任务，也就是task queue。</p>
<p>第三次循环中，执行mark3，会找到刚才创建的WorkQueue，从队列的top端加入任务，调用后面要讲的signalWork激活或者创建worker。</p>
</blockquote>
<p>WorkQueue在WorkQueue[]的下标，取的是k = r &amp; m &amp; SQMASK。r是线程的probe，来自随机数ThreadLocalRandom；m是WorkQueue[]的长度减一；SQMASK是固定值0x007e，转为二进制是1111110，末尾是0，在&amp;操作后，得出的k必定是偶数。所以创建的第一个WorkQueue没有对应worker，保存的任务是submission，scanState默认是INACTIVE。</p>
<p>externalSubmit是长了点，不过逻辑清晰，不难理解。除了初始化，大部分时间其实不需要externalSubmit，使用简单版的externalPush即可。</p>
<p>以上如果队列里只有一个任务，就调用signalWork</p>
<h2 id="worker管理"><a href="#worker管理" class="headerlink" title="worker管理"></a>worker管理</h2><p>一个worker线程的生命周期里面有注册、创建、执行、注销</p>
<h2 id="worker的创建"><a href="#worker的创建" class="headerlink" title="worker的创建"></a>worker的创建</h2><p>首先是worker的创建在signalWork()方法里面，signalWork方法就是当任务到队列中等候以后，判断没有空闲线程就创建新的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> &#123;</span><br><span class="line">    <span class="type">long</span> c; <span class="type">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="type">int</span>)c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="literal">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="literal">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">vs</span> <span class="operator">=</span> (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="literal">null</span>)</span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是进入循环的条件，判断了ctl的正负，我们知道ctl的第一个16bit表示AC，为负时表示活动的worker还未达到预定的Parallelism，需要新增或者激活。mark1通过sp判断现在没有空闲worker，需要执行增加，调用tryAddWorker。</p>
<p>有空闲worker的情况进入mark2，sp取栈顶WorkQueue的下标，具体解挂worker的过程和tryRelease几乎一样，这里合起来介绍。<br>解卦worker的意思是将worker线程解除挂起。  </p>
<p>在sp上，将状态从inactive改为active，累加版本号 ，解挂线程，通过stackPred取得前一个WorkQueue的index，设回sp里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryAddWorker</span><span class="params">(<span class="type">long</span> c)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">add</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                       (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">            <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">                <span class="type">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">                <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                    add = U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc);</span><br><span class="line">                unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">                <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                    createWorker();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="type">int</span>)c == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">createWorker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ForkJoinWorkerThreadFactory</span> <span class="variable">fac</span> <span class="operator">=</span> factory;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ForkJoinWorkerThread</span> <span class="variable">wt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="literal">null</span> &amp;&amp; (wt = fac.newThread(<span class="built_in">this</span>)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加worker，需要将AC和TC都加1，成功后调用createWorker。</p>
<p>createWorker的代码很简单，通过线程工厂创建worker的实例并启动。如果没有异常，直接返回就行；否则，需要逆操作撤销worker的注册。worker什么时候注册了？看ForkJoinWorkerThread的构造函数，里面调用ForkJoinPool.registerWorker，所以就是在创建worker的时候会注册工作线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WorkQueue <span class="title function_">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> &#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    wt.setDaemon(<span class="literal">true</span>);                           <span class="comment">// configure thread</span></span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="literal">null</span>)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    <span class="type">WorkQueue</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkQueue</span>(<span class="built_in">this</span>, wt);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> config &amp; MODE_MASK;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws; <span class="type">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// odd-numbered indices</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="literal">null</span>) &#123;                  <span class="comment">// collision</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">probes</span> <span class="operator">=</span> <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2</span></span><br><span class="line">            w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始，线程就被设置为守护线程。重温知识点，当只剩下守护线程时，JVM就会退出，垃圾回收线程也是一个典型的守护线程。</p>
<p>mark1，前文讲过有对应worker的WorkQueue只能出现在WorkQueue[]奇数index，代码里取初始index用的是：</p>
<p>i = ((s &lt;&lt; 1) | 1) &amp; m;<br>seed左移再“或”1，是奇数。m是WorkQueue[]长度减1，也是奇数。两者再“与”，保证取得的i是奇数。若该位置已经存在其他WorkQueue，需要重新计算下一个位置，有需要还要扩容WorkQueue[]。</p>
<p>mark2设置新创建WorkQueue的scanState为index，表示了两种意思：</p>
<ul>
<li>非负表示有对应的worker；</li>
<li>默认scanState使用SCANNING。</li>
</ul>
<p>就此描述清楚worker的创建、WorkQueue的创建和加入WorkQueue[]。</p>
<h2 id="workter执行"><a href="#workter执行" class="headerlink" title="workter执行"></a>workter执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="literal">null</span>) &#123; <span class="comment">// only run once</span></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                onTermination(exception);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="literal">null</span>)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                pool.deregisterWorker(<span class="built_in">this</span>, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(WorkQueue w)</span> &#123;</span><br><span class="line">    w.growArray();                   <span class="comment">// allocate queue</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> w.hint;               <span class="comment">// initially holds randomization hint</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// avoid 0 for xorShift</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="literal">null</span>)</span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))<span class="comment">//这里如果为false，进入到break出了循环，这个线程就结束了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个run方法是ForkJoinWorkerThread里的run，重写了Thread的run方法，当启动这个线程执行的就是这个run。</p>
<p>调用了ForkJoinPool的runWorker方法。</p>
<p>worker执行流程就是三部曲：</p>
<ul>
<li>scan：尝试获取一个任务；</li>
<li>runTask：执行取得的任务；</li>
<li>awaitWork：没有任务进入等待。</li>
</ul>
<p>如果awaitWork返回false，等不到任务，跳出runWorker的循环，回到run中执行finally，最后调用deregisterWorker撤销注册。</p>
<p>首先是scan</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="type">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ss</span> <span class="operator">=</span> w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">origin</span> <span class="operator">=</span> r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="type">int</span> b, n; <span class="type">long</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (a = q.array) != <span class="literal">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                              U.getObjectVolatile(a, i))) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        q.base == b) &#123;</span><br><span class="line">                        <span class="comment">//2</span></span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="literal">null</span>)) &#123;</span><br><span class="line">                                q.base = b + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate</span></span><br><span class="line">                                 w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="type">int</span>)c], AC_UNIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                    oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> ((SP_MASK &amp; ns) |</span><br><span class="line">                               (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                    w.stackPred = (<span class="type">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc))</span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是获得了当前线程对应的workQueue的scanState状态。<br>在mark2的时候要判断这个状态:</p>
<ul>
<li>如果是active，那直接拿着偷到的task返回。</li>
<li>如果是inactive，调用tryRelease激活这个workQueue</li>
</ul>
<p>在mark3处，每次循环会校验新取的index是不是等于第一次取的index。如果相等，说明遍历了一圈还没有steal到任务，当前worker是过剩的，执行如下操作：</p>
<ul>
<li>当前WorkQueue的scanState修改为inactive；</li>
<li>当前WorkQueue挂到栈顶，AC减一。</li>
</ul>
<p>偷到一个任务以后就执行它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; <span class="comment">// mark as busy</span></span><br><span class="line">        (currentSteal = task).doExec();</span><br><span class="line">        U.putOrderedObject(<span class="built_in">this</span>, QCURRENTSTEAL, <span class="literal">null</span>); <span class="comment">// release for GC</span></span><br><span class="line">        execLocalTasks();</span><br><span class="line">        <span class="type">ForkJoinWorkerThread</span> <span class="variable">thread</span> <span class="operator">=</span> owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>steal到一个任务后，就可以开始执行：</p>
<ul>
<li>将WorkQueue的scanState从SCANNING转为RUNNING；</li>
<li>记录当前任务是steal来的，保存在currentSteal，并执行doExec；</li>
<li>执行自己WorkQueue里的任务execLocalTasks（根据mode控制取任务是- LIFO还是FIFO，调用doExec执行，直到WorkQueue为空）；</li>
<li>累加steal数量；</li>
<li>能执行的都执行了，scanState转回SCANNING。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; <span class="type">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">setCompletion</span><span class="params">(<span class="type">int</span> completion)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> s;;) &#123;</span><br><span class="line">       <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, STATUS, s, s | completion)) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((s &gt;&gt;&gt; <span class="number">16</span>) != <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; notifyAll(); &#125;</span><br><span class="line">           <span class="keyword">return</span> completion;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doExec方法，里面最终调用ForkJoinTask的核心方法exec，前文介绍过，RecursiveAction和RecursiveTask它们override的exce调用了compute。这样子，源码和使用的方法关联起来了。</p>
<p>当任务执行完成，调用setCompletion，将任务状态改为NORMAL。注意，使用CAS修改状态时，目标状态使用s|NORMAL。</p>
<ul>
<li>原状态是NORMAL，无符号右移为0；</li>
<li>原状态是SIGNAL，无符号右移不为0。<br>如果任务原状态是SIGNAL，表示有线程由于join而进入了wait，等着任务完成，这时需要额外操作notify触发唤醒。</li>
</ul>
<p>没有偷到任务就阻塞这个工作线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">awaitWork</span><span class="params">(WorkQueue w, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="literal">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pred</span> <span class="operator">=</span> w.stackPred, spins = SPINS, ss;;) &#123;</span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">                WorkQueue v; WorkQueue[] ws; <span class="type">int</span> s, j; AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                    (v = ws[j]) != <span class="literal">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">                    (v.parker == <span class="literal">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// recheck after spins</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="type">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ac</span> <span class="operator">=</span> (<span class="type">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);</span><br><span class="line">           <span class="comment">//4</span></span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="literal">false</span>, <span class="literal">false</span>)) ||</span><br><span class="line">                (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//5</span></span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="type">int</span>)c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (<span class="type">short</span>)(c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, prevctl))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">            w.parker = wt;</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">                U.park(<span class="literal">false</span>, parkTime);</span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="literal">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, prevctl))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>awaitWork里核心是一个无限循环，我们重点看里面的等待操作和跳出条件。</p>
<p>mark1判断WorkQueue的scanState，非负表示WorkQueue要不在RUNNING，要不在SCANNING，直接跳出。mark2里，SPINS初始为0，没有启用自旋等待的控制。</p>
<p>重点来看mark3，只要没有中断，就会一直循环执行（tryTerminate终止ForkJoinPool时会中断所有worker）。啰嗦一句，要分清楚return和break的不同含义：</p>
<ul>
<li>break：回到runWorker继续执行scan、runTask、awaitWork；</li>
<li>return false：worker需要终止了。<br>mark4检查ForkJoinPool的状态，如果走向中止那边，当前worker也就无必要存在，return false。</li>
</ul>
<p>mark5判断worker的存在是否有必要，如果满足下面条件：</p>
<ul>
<li>AC为零；</li>
<li>TC超过2个；</li>
<li>当前WorkQueue在栈顶。</li>
</ul>
<p>说明当前worker过剩，存在也没有任务执行，所以WorkQueue从栈顶释放，return false终止worker。</p>
<p>其他情况计算一个等待时间，挂起线程，被唤醒有两种可能：</p>
<ul>
<li>外部唤醒：如果scanState非负，break出循环，继续执行scan；</li>
<li>时间到达唤醒：还是老样子，自己过剩，return false终止。</li>
</ul>
<p>最后回到ForkJoinTask里的方法中。</p>
<h2 id="ForkJoinTask-Fork"><a href="#ForkJoinTask-Fork" class="headerlink" title="ForkJoinTask Fork"></a>ForkJoinTask Fork</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fork的代码很简单，如果当前线程是一个worker，直接将任务从top端加入自己的WorkQueue。对于非worker提交的task，执行externalPush，这个前面详细分析过了。</p>
<h2 id="ForkJoinTask-Join"><a href="#ForkJoinTask-Join" class="headerlink" title="ForkJoinTask Join"></a>ForkJoinTask Join</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>join的目的是得到任务的运行结果，核心调用doJoin，根据任务状态返回结果，或者抛出异常。要注意的是，任务在ForkJoinPool中可能处于各种各样的状况，有可能刚好要被执行啊，有可能正在队列里排队啊，有可能已经被别人偷走啊。</p>
<p>doJoin的return是花一样的一串判断，先分解出头两个判断：</p>
<ul>
<li>status为负表示任务执行已经有结果，直接返回；</li>
<li>区分当前线程是否worker。</li>
</ul>
<p>如果当前线程不是ForkJoinWorkerThread这种情况，调用externalAwaitDone</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">externalAwaitDone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> ((<span class="built_in">this</span> <span class="keyword">instanceof</span> CountedCompleter) ? <span class="comment">// try helping</span></span><br><span class="line">             ForkJoinPool.common.externalHelpComplete(</span><br><span class="line">                 (CountedCompleter&lt;?&gt;)<span class="built_in">this</span>, <span class="number">0</span>) :</span><br><span class="line">             ForkJoinPool.common.tryExternalUnpush(<span class="built_in">this</span>) ? doExec() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span> &amp;&amp; (s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, STATUS, s, s | SIGNAL)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(<span class="number">0L</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                            interrupted = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不讲CountedCompleter的协作，将任务状态设置为SIGNAL，然后是使用wait/notify机制，线程进入等待。既然不是worker，不属于ForkJoinPool的管理范围，你挂起等通知就是了。</p>
<p>然后是dojoin里的剩下的判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) </span><br></pre></td></tr></table></figure>
<p>首先调用tryUnpush，如果WorkQueue的top端任务正好是等待join的任务，毫无疑问，下个就是执行它，直接doExec；否则调用ForkJoinPool的awaitJoin。</p>
<h1 id="awaitJoin看晕了，有时间再看"><a href="#awaitJoin看晕了，有时间再看" class="headerlink" title="awaitJoin看晕了，有时间再看"></a>awaitJoin看晕了，有时间再看</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://saaaaaail.github.io/saaaaaail">sail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://saaaaaail.github.io/saaaaaail/2020/08/18/ForkJoinPool%E8%AF%A6%E8%A7%A3/">https://saaaaaail.github.io/saaaaaail/2020/08/18/ForkJoinPool%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://saaaaaail.github.io/saaaaaail" target="_blank">sail home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/juc/">juc</a><a class="post-meta__tags" href="/tags/java%E5%B9%B6%E5%8F%91/">java并发</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2020/08/12/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%AF%A6%E8%A7%A3/" title="SpringBoot自动装配详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">SpringBoot自动装配详解</div></div><div class="info-2"><div class="info-item-1">@EnableAutoConfiguration1234567891011121314@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)//1.5.x版本@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123;    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;    Class&lt;?&gt;[] exclude() default &#123;&#125;;    String[]...</div></div></div></a><a class="pagination-related" href="/2020/08/18/LongAdder%E8%AF%A6%E8%A7%A3/" title="LongAdder详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">LongAdder详解</div></div><div class="info-2"><div class="info-item-1">LongAdder建议参考ConcurrentHashMap addCount与fulladdCount方法源码，类似~~ </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/07/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" title="线程池原理详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-04</div><div class="info-item-2">线程池原理详解</div></div><div class="info-2"><div class="info-item-1">线程池的原理详解理解线程池是由任务队列和工作线程组成，可以重用线程来避免线程创建的开销，在任务过多时，通过排队来避免创建过多的线程，来减少系统资源的消耗和竞争，确保任务有序完成。 线程池的构成ExecutorService是真正的线程池接口。 Executors是java提供的生产线程池的静态工厂，生产各种线程池实例。 Executor是线程池的顶级接口，用来执行线程，通过execute方法。 AbstractExecutorService实现了ExecutorService接口的部分方法，为抽象类。 ThreadPoolExecutor继承了AbstractExecutorService，实现了ExecutorService的接口。 ThreadPoolExecutor12345678910111213141516171819202122232425//ThreadPoolExecutor参数最全的一个构造类，来一一记录public ThreadPoolExecutor(int corePoolSize,                          int...</div></div></div></a><a class="pagination-related" href="/2020/07/04/AQS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" title="AQS原理详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-04</div><div class="info-item-2">AQS原理详解</div></div><div class="info-2"><div class="info-item-1">AQS原理/源码详解AQS全称为AbstractQueuedSynchronizeder（抽象队列同步器），juc包中Lock、CountDownLatch、CyclicBarrier、Phaser、Exchanger等线程同步工具都是基于AQS实现的。 AQS的基本思想是...</div></div></div></a><a class="pagination-related" href="/2020/06/03/CompareAndSwap%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" title="CompareAndSwap原理详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-03</div><div class="info-item-2">CompareAndSwap原理详解</div></div><div class="info-2"><div class="info-item-1">CompareAndSwap原理详解谈到CAS操作就离不开原子类，在多个线程中对同一变量进行操作需要加锁，否则会存在线程安全问题，但是在多个线程对原子类进行操作的时候不需要加锁原因就是使用了CAS。 CAS即CompareAndSwap比较与交换，又称为无锁、自选锁、乐观锁。 以AtomicInteger i = new AtomicInteger(1)为例: 123456789101112131415161718192021222324252627282930public class AtomicInteger extends Number implements java.io.Serializable &#123;    private static final long serialVersionUID = 6214790243416807050L;    // setup to use Unsafe.compareAndSwapInt for updates    private static final Unsafe unsafe =...</div></div></div></a><a class="pagination-related" href="/2020/08/18/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/" title="ConcurrentHashMap详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-18</div><div class="info-item-2">ConcurrentHashMap详解</div></div><div class="info-2"><div class="info-item-1">ConcurrentHashMap详解jdk1.7数据结构由一个Segment数组构成，每个Segment数组元素是一个HashEntry数组，一个HashEntry节点就是一个链表的kv键值对节点。Segment数组的大小由size来表示。   12345int size =1;while(size &lt; concurrencyLevel) &#123;++a;size &lt;&lt;=1;&#125;       size的大小为2的n次方，没有指定concurrencyLevel默认值为16，如果指定的话size最大值能到65536。 每个HashEntry的数组大小用cap来表示，也是2的n次方 123static class  Segment&lt;K,V&gt; extends  ReentrantLock implements  Serializable...</div></div></div></a><a class="pagination-related" href="/2020/08/18/LongAdder%E8%AF%A6%E8%A7%A3/" title="LongAdder详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-18</div><div class="info-item-2">LongAdder详解</div></div><div class="info-2"><div class="info-item-1">LongAdder建议参考ConcurrentHashMap addCount与fulladdCount方法源码，类似~~ </div></div></div></a><a class="pagination-related" href="/2020/07/02/ReentrantLock%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" title="ReentrantLock原理详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-02</div><div class="info-item-2">ReentrantLock原理详解</div></div><div class="info-2"><div class="info-item-1">ReentrantLock原理详解 提问：介绍一下ReentrantLock？  基础方法1Lock lock = new ReentrantLock();  lock()/unlock()  tryLock()1可以进行加锁尝试 ，如果一段时间没有获得锁，就停止尝试获得锁返回false lockInterruptibly() 1通过这个方式加锁的，可以被线程的interrupt()方法打断 公平锁  1Lock lock = new ReentrantLock(true);  提问：Lock公平锁为什么不能保证绝对的公平？  源码解读ps:以下是ReentrantLock源码分析，AQS原理不再赘述噢，AQS源码解读-&gt; AQS源码解读 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">sail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ForkJoinPool%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">ForkJoinPool详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoinPool%E7%8A%B6%E6%80%81%E4%BF%AE%E6%94%B9"><span class="toc-number">1.2.</span> <span class="toc-text">ForkJoinPool状态修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1ForkJoinTask"><span class="toc-number">1.3.</span> <span class="toc-text">任务ForkJoinTask</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoinTask%E5%9C%A8pool%E9%87%8C%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="toc-number">1.4.</span> <span class="toc-text">ForkJoinTask在pool里的提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worker%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">worker管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worker%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.6.</span> <span class="toc-text">worker的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#workter%E6%89%A7%E8%A1%8C"><span class="toc-number">1.7.</span> <span class="toc-text">workter执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoinTask-Fork"><span class="toc-number">1.8.</span> <span class="toc-text">ForkJoinTask Fork</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoinTask-Join"><span class="toc-number">1.9.</span> <span class="toc-text">ForkJoinTask Join</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#awaitJoin%E7%9C%8B%E6%99%95%E4%BA%86%EF%BC%8C%E6%9C%89%E6%97%B6%E9%97%B4%E5%86%8D%E7%9C%8B"><span class="toc-number">2.</span> <span class="toc-text">awaitJoin看晕了，有时间再看</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/16/hello-world/" title="Hello World">Hello World</a><time datetime="2025-03-16T04:21:42.245Z" title="发表于 2025-03-16 12:21:42">2025-03-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/12/01/%E9%98%BF%E9%87%8C%E7%9A%84maven%E4%BE%9D%E8%B5%96http%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/" title="阿里的maven依赖http失效问题">阿里的maven依赖http失效问题</a><time datetime="2020-12-01T09:31:49.000Z" title="发表于 2020-12-01 17:31:49">2020-12-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/11/04/Tomcat%E5%AE%9A%E6%97%B6%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/" title="Tomcat定时检查服务状态的启动脚本">Tomcat定时检查服务状态的启动脚本</a><time datetime="2020-11-04T03:29:25.000Z" title="发表于 2020-11-04 11:29:25">2020-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/09/11/RocketMQ%E8%AF%A6%E8%A7%A3/" title="RocketMQ详解">RocketMQ详解</a><time datetime="2020-09-11T07:28:43.000Z" title="发表于 2020-09-11 15:28:43">2020-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/09/04/zookeeper/" title="zookeeper">zookeeper</a><time datetime="2020-09-04T06:58:11.000Z" title="发表于 2020-09-04 14:58:11">2020-09-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By sail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 5.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>