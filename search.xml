<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/16/hello-world/"/>
      <url>/2025/03/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> sail </tag>
            
            <tag> start </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里的maven依赖http失效问题</title>
      <link href="/2020/12/01/%E9%98%BF%E9%87%8C%E7%9A%84maven%E4%BE%9D%E8%B5%96http%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/01/%E9%98%BF%E9%87%8C%E7%9A%84maven%E4%BE%9D%E8%B5%96http%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat定时检查服务状态的启动脚本</title>
      <link href="/2020/11/04/Tomcat%E5%AE%9A%E6%97%B6%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"/>
      <url>/2020/11/04/Tomcat%E5%AE%9A%E6%97%B6%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat启动脚本"><a href="#Tomcat启动脚本" class="headerlink" title="Tomcat启动脚本"></a>Tomcat启动脚本</h1><p>检查tomcat服务有没有挂掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">FILE=&quot;/usr/local/tomcat/app-8080&quot;</span><br><span class="line">TOMCAT=&quot;/bin/startup.sh&quot;</span><br><span class="line">URL=&quot;127.0.0.1:8080/sys/getConfigContent?flag=DEFAULT_USER_HEAD_ICON&quot;</span><br><span class="line"></span><br><span class="line">RESP=&quot;$( curl -I -m 5 -o /dev/null -s -w %&#123;http_code&#125; $URL)&quot;</span><br><span class="line">echo $RESP</span><br><span class="line"></span><br><span class="line">if [[ $RESP == *&quot;200&quot;* ]]; then</span><br><span class="line">    echo &#x27;服务正常&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;服务异常&#x27;</span><br><span class="line">PID=$(ps -ef|grep &quot;$FILE&quot;|grep -v &quot;grep&quot;|awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">echo $PID</span><br><span class="line">if [[ $PID == &quot;&quot; ]]; then</span><br><span class="line">   echo &#x27;为空了&#x27;</span><br><span class="line">else</span><br><span class="line">   echo &#x27;杀死进程&#x27;</span><br><span class="line">   kill -9 $PID</span><br><span class="line">fi</span><br><span class="line">sh $FILE$TOMCAT</span><br><span class="line">echo &#x27;重新启动&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h1 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* */1 * * * * sh xxx.sh 1&gt;&gt;1.txt 2&gt;/dev/null</span><br><span class="line">* */1 * * * * sleep 30;sh xxx.sh 1&gt;&gt;1.txt 2&gt;/dev/null</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ详解</title>
      <link href="/2020/09/11/RocketMQ%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/09/11/RocketMQ%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><ol><li>能够保证严格的消息顺序</li><li>提供丰富的消息拉取模式</li><li>高效的订阅者水平扩展能力</li><li>实时的消息订阅机制</li><li>支持事务消息</li><li>亿级消息堆积能力</li></ol><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>在conf文件夹下包含三个默认的</p><ul><li>2m-2s-async ：2主2从 异步传输数据</li><li>2m-2s-sync  ：2主2从 同步传输数据</li><li>2m-noslave  ：2主 没有从节点</li></ul><p>修改bin目录下的runbroker.sh文件里的jvm启动参数</p><ul><li>设置xmx最大堆内存大小、xms最小堆内存大小、xmn新生代大小、xss单个虚拟机栈大小</li></ul><p>修改bin目录下的runserver.sh文件里的jvm启动参数</p><ul><li>设置xmx最大堆内存大小、xms最小堆内存大小、xmn新生代大小、xss单个虚拟机栈大小、-XX:MetaspaceSize=128M、-XX:MaxMetaspaceSize=320M为合适的大小</li></ul><p>先启动nameServer、然后启动broker    </p><h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><ul><li>普通消息</li><li>顺序消息 - 能实现有序的顺序消费</li><li>事务消息 - 能解决分布式事务实现最终一致性问题</li></ul><p>两种消费模式：</p><ul><li>DefaultMQPushConsumer</li><li>DefaullMQPullConsumer</li></ul><h1 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h1><p>DefaultMQProducer 生产者对象  </p><ul><li>producerGroup: 生产者组</li><li>nameServer</li></ul><p>Message 消息对象  </p><ul><li>topic: 主题，用来与消费者消费对应的数据</li><li>tags: 标记，用来与消费者对应，过滤主题里的数据</li><li>keys: 消息的唯一值</li><li>消息数据体</li></ul><h1 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h1><p>DefaultMQPushConsumer 消费者对象，push模式  </p><ul><li>consumerGroup: 消费者组</li><li>nameServer</li></ul><p>配置消费什么对象  </p><ul><li>topic: 指定消费的主题</li><li>tags: 过滤规则</li></ul><p>消息监听  MessageListenerConcurrently监听器<br>能获得批量拉取的消息list，能设置一次拉取的消息数量上限，对批量消息list迭代消费掉。</p><ul><li>消息返回消费成功标志位。</li><li>消息消费异常则返回消息重试标志位。</li></ul><h1 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h1><p>由于生产者组向broker发送消息，消息会负载到不同的队列中，很难保证顺序消费。</p><p>因此要保证顺序消费：</p><ul><li>消息被发送时保持顺序</li><li>消息被存储时保持和发送的顺序一致</li><li>消息被消费时保持和发送的顺序一致</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>生产者发送消息选择一个topic队列，然后将顺序消息信息发往这一个队列。 </li><li>消费者对于顺序消息要保证有序消费，那么就修改普通消息的MessageListenerConcurrently监听器为MessageListenerOrderly监听器进行有序消费。</li></ul><h1 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h1><ol><li>生产者组首先向broker发送预提交消息到HalfTopic</li><li>预提交消息发送成功以后回调生产者组的执行本地事务的方法</li><li>判断生产者组本地事务是否执行成功，成功则看第4步，失败看第7步</li><li>将本地执行成功的消息发送到broker的OpTopic </li><li>broker会将OpTopic的数据提交到RealTopic中</li><li>此时消费者端就可以在RealTopic中消费到这个事务消息，并且通过重试机制解决消费端失败的问题。</li><li>如果失败则返回超时或者Unknow状态，由于之前发送了预提交，现在broker想知道进一步的情况，会进行消息回查（会比较HalfTopic与OpTopic里消息的区别确定要进行回查的消息）</li></ol><p>在普通消息的基础上：</p><ul><li>指定消息的事务监听对象TransactionListener，用于执行本地事务与消息回查</li><li>重写上面接口的executeLocalTransaction执行本地事务</li><li>重写上面接口的checkLocalTransaction进行消息回查</li></ul><h2 id="RocketMQ分布式事务流程"><a href="#RocketMQ分布式事务流程" class="headerlink" title="RocketMQ分布式事务流程"></a>RocketMQ分布式事务流程</h2><ul><li>第一阶段. 预提交消息，提交到HalfTopic，broker会拿到事务消息的id值。</li><li>第二阶段. broker根据事务id回调执行本地事务，如果执行成功会Commit将事务消息写到OpTopic，执行失败会Rollback清理HalfTopic。</li><li>第三阶段. 如果没有收到之前的预提交的事务消息的确认会回调检查事务状态，返回给broker去做Commit或Rollback</li></ul><h1 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h1><p>在默认的集群消息模式时，同一个消费组中只有一个消费组消费消息。</p><p>在广播模式中同一个消费组中的所有消费者都能消费同一个消息。</p><h1 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h1><h2 id="消息存储和发送"><a href="#消息存储和发送" class="headerlink" title="消息存储和发送"></a>消息存储和发送</h2><p>消息存储采用文件系统的顺序写方式。</p><p>消息发送采用的是零拷贝技术。</p><h2 id="消息存储数据结构"><a href="#消息存储数据结构" class="headerlink" title="消息存储数据结构"></a>消息存储数据结构</h2><p>CommitLog文件夹: 存储消息的元数据，包括topic、queueId、Message，这么一个文件的是顺序写入的，采用了一个ConsumerQueue记录这么1g的文件里面各个消息的索引值，包括最小的消息偏移量，已经消费的消息偏移量，最大的消息偏移量。</p><p>可以通过CommitLog文件生成ConsumerQueue文件。  </p><p>index文件夹: 也是一个索引文件，ConsumerQueue是一个文件，按照消息id的索引值得到偏移量，而index提供了按照消息key、时间戳来查询消息的索引文件。</p><h2 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h2><p>RocketMQ将消息以文件系统的方式存储到了磁盘上面。有两种写磁盘方式，同步刷盘、异步刷盘。</p><ul><li>同步刷盘: 指的是消息发送到MQ之后，保存到内存里，立即进行磁盘的写入，写入完成以后才会返回该请求写成功的响应。</li><li>异步刷盘: 指消息被保存到内存以后就立即返回了写入成功的响应，当内存的消息数量积累到一定程度才会统一触发写磁盘的操作。</li></ul><p>这两种机制都能通过broker的配置文件进行配置。</p><h2 id="RocketMQ高可用"><a href="#RocketMQ高可用" class="headerlink" title="RocketMQ高可用"></a>RocketMQ高可用</h2><h3 id="nameServer的高可用"><a href="#nameServer的高可用" class="headerlink" title="nameServer的高可用"></a>nameServer的高可用</h3><p>首先生产组集群、消费组集群、broker集群的主机会注册到nameServer集群中。<br>NameServer集群本身的高可用是通过部署多台NameServer服务器来实现的，但是匹此之间互不通信，因此集群各个nameServer主机之间在某一时刻的数据并不会完全相同的。每个nameServer都是独立的对broker进行心跳检测、路由注册、路由删除的。</p><p>检测的话主要通过心跳，Broker启动以后每隔30s会向所有NameServer结点发送心跳包，NameServer收到心跳包会在自己的brokerLiveTable中缓存brokerId与最近发送心跳包的时间，然后NameServer会每隔10s扫描brokerLiveTable，如果这个表里面有连续120s没有收到心跳包的broker，NameServer就移除这个broker的注册信息，并且关闭socket连接。</p><h3 id="broker的高可用"><a href="#broker的高可用" class="headerlink" title="broker的高可用"></a>broker的高可用</h3><h4 id="多主多从-异步复制模式"><a href="#多主多从-异步复制模式" class="headerlink" title="多主多从 异步复制模式"></a>多主多从 异步复制模式</h4><p>集群中存在多个master节点，每个master节点至少存在一个slave节点。master节点可读可写，slave节点只能读。</p><p>因此对于生产者写的话，只能写入master节点，一个master节点宕机了，还可以写入其他master节点。</p><p>对于消费组读的话，master宕机以后，仍然能从所有slave节点中读取数据。</p><p>优点：高可用<br>缺点：使用异步复制的数据同步方式有可能会有消息丢失的问题。</p><h4 id="多主多从-同步双写模式"><a href="#多主多从-同步双写模式" class="headerlink" title="多主多从 同步双写模式"></a>多主多从 同步双写模式</h4><p>架构上与上面的类似，只是数据同步上面，采用的是同步双写的模式。</p><ul><li><p>同步复制：master与slave数据同步完成以后，才对生产者写入反馈成功响应。好处就是master与slave数据保证一致，但是坏出增大了写入延迟，减少了吞吐量。</p></li><li><p>异步复制: 只要master写入成功就可以反馈客户端写成功状态，好处延迟较低，高吞吐，坏处就是Master宕机的时候可能有部分数据还没有同步到slave上。</p></li></ul><p>在broker的配置文件中brokerRole参数，设置成ASYNC_MASTER、SYNC_MASTER、SLAVE（从节点配成这个）值中的一个。</p><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>将刷盘配置成 异步刷盘<br>将主从同步配置成 同步复制</p><h2 id="RocketMQ的负载均衡"><a href="#RocketMQ的负载均衡" class="headerlink" title="RocketMQ的负载均衡"></a>RocketMQ的负载均衡</h2><h3 id="生产者的负载均衡"><a href="#生产者的负载均衡" class="headerlink" title="生产者的负载均衡"></a>生产者的负载均衡</h3><p>默认会通过轮询的方式将消息发送到不同的messageQueue中，然后messageQueue可以均匀地落在不同地broker服务器节点上。</p><h3 id="消费者地负载均衡"><a href="#消费者地负载均衡" class="headerlink" title="消费者地负载均衡"></a>消费者地负载均衡</h3><h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><p>在集群模式下，同一个消费组中的消费者会均摊接收当前topic的所有messageQueue，即假设有6个messageQueue，在当前消费组中有3个消费者，那么编号为0、1的messageQueue的消息由1号消费者消费，编号为 2、3的messageQueue的消息由2号消费者消费，编号为4、5的messageQueue的消息由3号消费者消费。</p><p>还有一种分摊算法是按照broker节点来均匀分摊，即每个消费者分摊各个broker节点中的一个messageQueue。</p><p>由于采用的是一种分摊的方法，因此为了避免出现有消费者没有分到messageQueue而导致无消息消费的情况，要求messageQueue的总数量大于消费组中消费者的数量。</p><h4 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h4><p>不是负载均衡的形式。</p><p>处于广播模式的消费组中的每一个消费者会消耗每一个messageQueue里的消息。</p><h2 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h2><p>由于RocketMQ中消费消息存在普通消息与顺序消息。</p><ul><li>对于顺序消息，如果一个消息不断失败，那么其会自动不断重试，间隔1s，就会出现后续消息积压无法消费的情况。</li><li>对于无序消息（普通、定时、延时、事务消息），如果消费失败了，要人为返回错误的状态达到消息重试的结果。无序消息重试只针对集群模式生效。广播方式不提供失败重试机制。</li></ul><h3 id="重试次数"><a href="#重试次数" class="headerlink" title="重试次数"></a>重试次数</h3><p>默认每条消息最多重试16次，每次重试时间间隔会不断增大，当16次都失败以后的消息将不再重试。</p><h3 id="重试情况"><a href="#重试情况" class="headerlink" title="重试情况"></a>重试情况</h3><p>以下情况都会触发消息的重试:   </p><ul><li>消费消息以后返回了消费失败的状态码</li><li>返回null</li><li>抛出异常</li></ul><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>当消息重试次数超过最大次数以后会被放到死信队列。</p><ul><li>死信队列的消息不会再被正常消费。</li><li>有效期与正常消息相同均为3天，3天后自动被删除</li></ul><p>死信队列的特性:  </p><ul><li>一个死信队列对应一个Group ID就是一个消费组，而不是对应单个消费者实例</li><li>如果Group ID未产生死信消息，那么不会新建死信队列</li><li>一个死信队列包含了对应Group ID产生的死信消息，不论该消息属于哪个topic的</li></ul><h2 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h2><p>指的是消费方接收到多个重复的消息的时候，出现一次与出现多次的结果是一致的。</p><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>Message ID是有可能出现重复的，因此使用Message ID作为处理依据是不靠谱的。</p><p>因此使用业务唯一标识作为幂等的关键依据，而业务的唯一标识可以通过Message Key进行设置。</p><p>在消费方将每一个消费的消息的key存起来，然后在处理消息之前判断这个消息key有没有被消费过。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/2020/09/04/zookeeper/"/>
      <url>/2020/09/04/zookeeper/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是zookeeper"><a href="#什么是zookeeper" class="headerlink" title="什么是zookeeper"></a>什么是zookeeper</h1><p>ZooKeeper是分布式协调服务，简单点说就是保证zookeeper里面的数据在其管辖下的所有服务之间保持一致。</p><p>是一个 文件系统 + 通知机制。</p><p>是一个类似文件系统的树形结构。</p><p>解决了分布式集群环境下的数据一致性。</p><blockquote><p>关于数据一致性C   </p><ul><li>强一致性 - 用户写入了A机器一个值，然后B机器读取，这时候由A到B的数据同步还没完成，用户就只能阻塞住等待同步完成以后读取最新的值。</li><li>弱一致性 - 指的是同步没有完成也可以读取系统当前的值。</li><li>最终一致性 - 指的是刚开始读取允许读到旧值，但是同步完成以后再读又会读到最新的值。</li></ul></blockquote><h2 id="zookeeper是如何保证一致性的"><a href="#zookeeper是如何保证一致性的" class="headerlink" title="zookeeper是如何保证一致性的"></a>zookeeper是如何保证一致性的</h2><p>因为Zookeeper实现了类似Paxos的Zab协议，解决了分布式数据一致性问题。</p><h3 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h3><p>原子广播协议（zookeeper atomic broadcast）。<br>有 两种模式：  </p><ul><li>崩溃恢复模式</li><li>原子广播模式</li></ul><p>当服务启动或者leader挂掉以后，zab进入恢复模式，当leader被选举出来，并且大多数Server完成了和leader的状态同步以后恢复模式就结束了。</p><h3 id="原子广播模式"><a href="#原子广播模式" class="headerlink" title="原子广播模式"></a>原子广播模式</h3><blockquote><p>首先什么是两阶段提交协议<br>就将leader与follower执行一个操作拆分为表决阶段与执行阶段。<br>表决阶段就是leader开启一个事务，然后发送给follower，由followe告诉leader自己是提交还是取消事务。<br>执行阶段就是leader根据表决阶段的响应，只有当所有follower都同意提交事务，leader才会通知所有follower进行提交操作，否则取消执行。</p></blockquote><p>类似于二阶段提交过程。</p><ol><li>客户端发送的写指令，会经由follower发送给leader，然后leader会将生成一个事务日志持久化到本地，然后将写指令封装成一个事务Proposal（分配一个递增zxid），发送给所有follower做预提交操作，先把数据传过去。</li><li>follower接收到以后如果他能够在自己的本地也成功持久化地生成这个事务日志的话，给leader返回ack响应。</li><li>如果超过半数的follower响应了，leader就执行commit操作执行，然后发送给follower做commit执行。</li></ol><h1 id="zookeeper能干嘛"><a href="#zookeeper能干嘛" class="headerlink" title="zookeeper能干嘛"></a>zookeeper能干嘛</h1><ul><li>统一的命名服务<ul><li>即能根据服务的名称、标识符找到对应的服务（Name Service如Dubbo服务注册中心）</li></ul></li><li>统一的配置管理<ul><li>提供配置文件统一修改的目的（Configurration Management各种开源的配置管理框架）</li></ul></li><li>集群管理<ul><li>zookeeper自身集群的管理，</li></ul></li><li><h2 id="分布式消息同步和协调"><a href="#分布式消息同步和协调" class="headerlink" title="分布式消息同步和协调"></a>分布式消息同步和协调</h2></li><li>负载均衡<ul><li>可以做，但没必要</li></ul></li><li><strong>对Dubbo的支持</strong><ul><li>提供了一套很好的分布式集群管理的机制，就是他这种基于层次型的目录树的数据结构，并对数中的节点进行有效的管理，从而可以设计出多种多样的分布式的数据管理模型，作为分布式系统的沟通调度桥梁。</li></ul></li><li>备注</li></ul><h2 id="zookeeper的应用场景"><a href="#zookeeper的应用场景" class="headerlink" title="zookeeper的应用场景"></a>zookeeper的应用场景</h2><ul><li>命名服务</li><li>配置管理</li><li>集群管理</li><li>分布式锁</li></ul><h1 id="zookeeper数据模型"><a href="#zookeeper数据模型" class="headerlink" title="zookeeper数据模型"></a>zookeeper数据模型</h1><p>与unix类似，整体上看作一颗树，每个节点称做一个zookeeper node，简称ZNode，每个ZNode节点默认能够存储1MB的数据，每个ZNode都可以通过路径唯一标识。</p><p>并且 znode 自身仍然是一个树形结构，znode = 路径path + 节点值nodeValue + Stat结构体（记录当前ZNode的一些信息）</p><h2 id="zookeeper-Stat-结构体"><a href="#zookeeper-Stat-结构体" class="headerlink" title="zookeeper Stat 结构体"></a>zookeeper Stat 结构体</h2><p>记录的是每个ZNode节点相关数据的这么一个结构体。</p><ul><li>czxid - 引起这个znode创建的zxid，创建节点的事务的zxid（Zookeeper Transaction Id）</li><li>ctime - znode被创建的时间点</li><li>mzxid - 最后修改znode的zxid值</li><li>mtime - znode最后被修改的时间点</li><li>pZxid - 当前znode的子节点最后更新的zxid</li><li>cversion - znode子节点变化号，znode子节点修改次数</li><li>dataversion - znode数据变化号，就是指令前面指令指向一次就加一次的编号</li><li>aclVersion - znode访问控制列表的变化号</li><li>ephemeralOwner - 如果是临时节点，这个是znode拥有者的sessionId，如果不是临时节点则是0。</li><li>dataLength - znode的value的数据长度</li><li>numChildren - znode的子节点数量</li></ul><h1 id="zookeeper的存在类型-持久-临时"><a href="#zookeeper的存在类型-持久-临时" class="headerlink" title="zookeeper的存在类型 - 持久/临时"></a>zookeeper的存在类型 - 持久/临时</h1><p>create指令：  </p><ul><li>-s 指给节点名称添加序列号排序，例<code>create -s /myNode v1</code>，执行完以后会生成一个/myNode0000000001形式的节点。</li><li>-e 创建一个临时节点，客户端关闭以后就没有了，注意是客户端断开连接以后临时节点就没有了。</li><li>-p 默认为持久化节点，不加-p也可以。</li></ul><h2 id="细分"><a href="#细分" class="headerlink" title="细分"></a>细分</h2><p>由于-s与-e可以同时支持。</p><ul><li>默认是 持久化节点</li><li>持久化序列号节点</li><li>临时节点</li><li>临时序列号节点</li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>和redis的kv键值命令类似，不过key变成了path，v就是znode节点值。</p><ul><li>help</li><li>ls</li><li>ls2<ul><li>比ls多了znode的stat结构体</li></ul></li><li>stat</li><li>set</li><li>get</li><li>create</li><li>delete</li><li>rmr<ul><li>递归删除znode节点</li></ul></li></ul><h1 id="四字命令"><a href="#四字命令" class="headerlink" title="四字命令"></a>四字命令</h1><p>举例ruok询问zookeeper服务器状态:<code>echo ruok | nc localhost 2181</code><br>在linux中的指令。</p><ul><li>stat - 输出性能和连接的客户端列表</li><li>conf - 输出相关服务配置的详细信息</li><li>cons - 所有连接到服务器的客户端的完全连接/会话的详细信息</li><li>dump - 列出未经处理的会话和临时节点</li><li>envi - 输出服务环境的详细信息</li><li>reqs - 列出未经处理的请求</li><li>wchs - 列出服务器watch的详细信息</li><li>wchc - 通过session列出服务器watch的详细信息</li><li>wchp - 通过路径列出服务器watch的详细信息</li></ul><h1 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h1><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>客户端使用某种语言绑定创建一个服务的句柄的时候，就建立了一个Zoookeeper会话，会话创建后句柄就处于CONNECTING状态，客户端会试图连接到Zookeeper服务器，连接成功句柄处于CONNECTED状态，如果发生不可恢复的错误就进入到CLOSED状态。</p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>是异步+回调的触发机制。</p><p>watch是设置一个watcher观察者观察ZNode节点，节点有发生变化就通知客户端执行watcher方法的回调方法，而且根据测试是异步执行。</p><h1 id="zookeeper集群"><a href="#zookeeper集群" class="headerlink" title="zookeeper集群"></a>zookeeper集群</h1><p>集群配置文件书写方式：<br>（服务器编号N、服务器ip地址、LF通信端口A、选举端口B）<br>例：<br><code>server.N=ip:A:B:observer</code></p><p>其中A表示Leader-Follower的通信端口，表示与该服务器与Leader交换信息的端口。<br>其中B表示选举端口，当Leader挂掉时，其他服务器会相互通信的端口，选举出新的Leader。<br>最后的observer，如果不添加的话，那么节点就是非observer节点，只有添加了这个词，这个节点就是observer节点了。</p><h2 id="zookeeper中的角色"><a href="#zookeeper中的角色" class="headerlink" title="zookeeper中的角色"></a>zookeeper中的角色</h2><ul><li>Leader： 用来发出提案Proposal，或者提出选举。</li><li>Follower： 可以接受提案或者拒绝提案，还可以在选举过程中发起投票。</li><li>Observer： 可以接受客户端连接，将写请求发给leader，不进行提案的表决也不参加投票过程，只同步leader的状态。</li></ul><p>每个Server节点有三种状态：  </p><ul><li>LOOKING 当前节点还不知道谁是leader</li><li>LEADING 当前节点是Leader</li><li>FOLLOWING 当前节点找到了Leader，现在是Follower</li></ul><p>一般，一个集群中的不同服务器ip不同，但是使用相同的A端口与B端口。  </p><h1 id="zookeeper选举机制"><a href="#zookeeper选举机制" class="headerlink" title="zookeeper选举机制"></a>zookeeper选举机制</h1><h2 id="过半机制"><a href="#过半机制" class="headerlink" title="过半机制"></a>过半机制</h2><p>就是投票选举的时候，zookeeper在QuorumMaj类里面进行过半选票的判断，里面有个half变量等于集群节点的n/2，然后选票必须大于half。这保证了集群不管怎么拆分，网络断联，都不可能产生选出第二个leader：  </p><ul><li>因为即便是集群对半断开连接，两个集群会因为两方都没有大于half节点而无法选出leader，停止提供服务。</li><li>如果不是对半分，也保证了数量多的一块集群能选出新leader，数量少于half的节点的集群无法选出新leader而停止了服务。</li></ul><h2 id="关于zookeeper集群奇数个的原因"><a href="#关于zookeeper集群奇数个的原因" class="headerlink" title="关于zookeeper集群奇数个的原因"></a>关于zookeeper集群奇数个的原因</h2><p>部署5台机器与6台机器都是最多只能挂掉两台，挂掉超过两台就整个集群停止服务了。因此选择部署尽量少的5台机器即可，这是部署奇数个主机说法的原因。</p><p>但是增加机器能提高读请求的吞吐量。但是会降低leader两阶段提交同步follower的效率。</p><p>这时候就可以将这个节点设置为observer节点，不参与投票，只同步数据，同步的地方位于二阶段提交第二阶段，当leader通知其他follower节点commit以后，会跟着通知所有observer执行这个写请求同步数据（要注意一阶段的预处理的时候，leader是没有给observer节点发送请求的）。然后leader会执行自己的commit操作。</p><p>选举有三种情况：  </p><ul><li>集群启动的时候</li><li>leader挂调的时候</li><li>follower挂掉的后当前leader没有过半follower跟随自己了</li></ul><h3 id="服务器启动过程"><a href="#服务器启动过程" class="headerlink" title="服务器启动过程"></a>服务器启动过程</h3><ul><li>解析配置</li><li>（根据配置文件里的config.server判断是否大于0，走集群路线。）</li><li>（QuorumPeer这个类记录集群模式下某一服务器节点的信息，并继承了Thread类，是一个线程。）</li><li>QuorumPeer.start()方法<ul><li>loadDataBase() 从磁盘加载服务器节点的数据到内存中。</li><li>cnxnFactory.start()方法 开启一个线程使用nio去监听端口连接</li><li>startLeaderElection()方法 仅仅进行领导者选举的准备工作</li><li>super.start() 真正的选举过程发生在线程启动以后的run方法里</li></ul></li><li>QuorumPeer.run()方法</li><li>进入一个while循环 main loop</li><li>如果当前服务器节点是LOOKING，那么会选择一个服务器节点投票，如果投完以后就break出switch结构，继续循环。<ul><li>通过lookforLeader()方法，进行投票选举。就是下面的集群启动选举过程。当前服务器在选举过程中主线程会一直阻塞在lookforLeader()该方法，导致不能接收任何请求。</li><li>setCurrentVote()设置当前服务器，经过上面选举过程后的leader节点。</li><li>这样LOOKING节点就结束了，服务器有了新的状态，重新进入了主循环。</li></ul></li><li>如果当前服务器节点是OBSERVING节点，</li><li>如果当前服务器节点是FOLLOWING节点，</li><li>如果当前服务器节点是LEADING节点，</li></ul><h2 id="集群启动的时候选举"><a href="#集群启动的时候选举" class="headerlink" title="集群启动的时候选举"></a>集群启动的时候选举</h2><ol><li><p>sendNotifications() 首先各个节点都是先投给自己。</p></li><li><p>然后将自己当前投的leader封装成多个选票，放入sendBlockingQueue，另一个worker线程会根据选票里的myid将队列里的选票分别发送给不同的参与者，通过各个节点第二个port去进行投票。</p></li><li><p>（如果当前节点还是LOOKING状态，就会一直在while里面自旋）然后从recvBlockingQueue接受其他服务器的选票，进行选票pk（epoch与zxid与myid）</p><ul><li><p>如从recvBlockingQueue取到的选票为空，那么当前服务器就会主动的与其他参与者进行socket连接connectAll，遍历参与者依次connectOne，而且只有myid大的能向myid小的建立连接，连接建立好以后，就自己的服务器开两个线程一个是sendWorker，取sendBlockingQueue里的选票进行发送，一个是recvWorker从接收socket发来的选票，并放入当前服务器节点的recvBlockingQueue中。以上就是当从recvQueue里面取得一个数据为空的时候，会去进行了一个连接的新建。</p></li><li><p>如果从recvBlockingQueue取到的选票不为空，那么判断发来选票的服务器的状态，如果是LOOKING状态就要进行选票PK了，那么就根据epoch与zxid与myid来pk，前面大的就赢，前面相等就比较后面大的赢，如果选票更新成功了就再次通知给其他参与者。</p></li></ul></li><li><p>各个节点通过pk不断修改投票对象，并发送给其他服务器节点sendNotifications()。</p></li><li><p>各个节点将自己与接受到的其他选票都在各自的服务器上维护一个Map作为投票箱。那么前面接收到其他选票并且pk完了以后，覆盖对应服务器myid的最新投票结果。</p></li><li><p>处理投票，通过过半机制。将投票箱里的选票与当前服务器所投的目标服务器一致的选票放入一个set中通过过半机制验证是否大于half，如果大于half就选出一个准leader。</p></li><li><p>过半机制返回true以后没完，还会再次从recvQueue里面取选票数据，如果有更优秀的选票，那么break重新进入外层循环，走投票箱-过半机制等等。如果没有新的选票了返回最终得leader。</p></li></ol><h2 id="leader挂掉以后"><a href="#leader挂掉以后" class="headerlink" title="leader挂掉以后"></a>leader挂掉以后</h2><h2 id="follower挂掉"><a href="#follower挂掉" class="headerlink" title="follower挂掉"></a>follower挂掉</h2><h2 id="当集群已经启动leader已经选定，新来的节点如何知道自己的角色？"><a href="#当集群已经启动leader已经选定，新来的节点如何知道自己的角色？" class="headerlink" title="当集群已经启动leader已经选定，新来的节点如何知道自己的角色？"></a>当集群已经启动leader已经选定，新来的节点如何知道自己的角色？</h2><ul><li>如果leader或者follower收到新加入节点的选票以后会将其当前服务器所选的currentVote返回给新来的节点，就是放到自己的sendQueue里面。</li><li>新来的节点由于自己是LOOKING状态，一直处在一个while循环里面，从自己的recvQueue里面取得新来的数据，这时候发了数据的服务器节点肯定不是LOOKING状态，如果是其他状态的话就直接将选票里的信息new一个vote对象出来，并保存当前的leader是谁。</li></ul><h2 id="当集群leader假死，新集群选了一个新leader，旧leader复活了怎么处理？"><a href="#当集群leader假死，新集群选了一个新leader，旧leader复活了怎么处理？" class="headerlink" title="当集群leader假死，新集群选了一个新leader，旧leader复活了怎么处理？"></a>当集群leader假死，新集群选了一个新leader，旧leader复活了怎么处理？</h2><p>首先新leader选定说明有集群中有过半的follower跟随了他，然后旧leader复活，这时候旧leader的提案epoch都落后于其他follower，那么会被直接拒绝掉，当他发现没有过半的follower跟随自己时会触发选举，状态改为LOOKING，然后按照选举逻辑首先将自己的选票发给其他follower，其他follower如果不是LOOKING状态的，就直接将当前的leader返回给旧leader，旧leader作为新leader的follower接入集群。</p><h1 id="zookeeper数据传输"><a href="#zookeeper数据传输" class="headerlink" title="zookeeper数据传输"></a>zookeeper数据传输</h1><p>zookeeper在QuorumPeer初始化阶段。</p><p>createElectionAlgorithm方法里定义了FastLeaderElection选举算法。  </p><p>在此之前呢，会createCnxnManager创建数据传输的数据结构。</p><ul><li>senderWorkerMap保存对应的服务节点的senderWorker线程</li><li>queueSendMap保存对应服务节点的sendQueue阻塞队列</li><li>lastMessageSent发送给每台服务器最近的消息，也是一个map，value是byteBuffer<br>以上三个都是ConcurrentHashMap。   </li></ul><p>recvQueue 接收其他服务器发送的数据。</p><p>listenr 监听器，是一个线程，通过start启动以后，while循环中通过socket.accept来不断地监听连接，监听的是选举的端口。</p><p>对应服务器节点的senderWorker线程从sendQueue里面取数据通过socket发送给对应的服务器节点，而通过receiverWorker线程</p><p>以上是数据传输的数据结构。</p><p>下面讲解应用层的数据存储结构。</p><p>即在FastLeaderElection的构造方法中开始应用层的数据结构初始化。</p><p>sendqueue 应用层只管将选票数据放到该发送队列中，<br>recvqueue 应用层只管从该队列中取出选票数据。<br>Messager 里面new了两个线程一个叫workerSender一个叫workerReceiver，与之前的数据发送相关的线程是不同的。</p><p><img src="zookeeper%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9E%B6%E6%9E%84.png" alt="zookeeper数据传输架构.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试题记录2020</title>
      <link href="/2020/08/27/java%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%952020/"/>
      <url>/2020/08/27/java%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%952020/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么选择activiti6"><a href="#为什么选择activiti6" class="headerlink" title="为什么选择activiti6"></a>为什么选择activiti6</h1><p>因为一开始是leader选型的，我只是参与一下，后面问了为什么要使用activiti6，而不是自己使用状态模式，定义多个状态，leader说不要重复造轮子，如果自己实现的话，自己管理流程也要做activiti6类似的工作，而且在不停地场景下面，自己定义不同状态地实现的话，就要不停地修改状态的跳转逻辑，就是抽象一个类出来做complete操作，根据我传的状态位去跳，如果自己写，流程一变这些都需要改，activiti6提供了一种bpmn快速绘图的机制，能快速修改流程，并且只需要修改相关的业务逻辑即可，不需要修改状态的逻辑。</p><h1 id="数组是什么类型"><a href="#数组是什么类型" class="headerlink" title="数组是什么类型"></a>数组是什么类型</h1><p>有原生类型与引用类型<br>原生的就是在jvm虚拟机栈上分配，引用的就是在虚拟机栈上分配一个引用指向堆上的实例。</p><h1 id="jdbc连接池-池化技术的核心"><a href="#jdbc连接池-池化技术的核心" class="headerlink" title="jdbc连接池 池化技术的核心"></a>jdbc连接池 池化技术的核心</h1><p>就是要让连接能够复用。</p><h1 id="如何设计一个直播平台"><a href="#如何设计一个直播平台" class="headerlink" title="如何设计一个直播平台"></a>如何设计一个直播平台</h1><ol><li>主播端需要视频采集编码</li><li>视频流要传输到服务端</li><li>服务端要能适配各种编码的视频流，要推送给不同端的用户，要能转码</li><li>推给端上播放要解码+渲染</li><li>对于一个后台而言，</li><li>视频流肯定要做持久化，数据库</li><li>热点视频流做缓存</li><li>消息队列做限流</li></ol><h1 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h1><blockquote><p><a href="https://blog.csdn.net/a_bcdef_/article/details/96443019">instanceof</a> </p><p>大意是 将目标类强制转型为源类，如果不抛类型转换异常就认为是其子类，做类型转换时容易触发源类遍历其继承链影响效率。</p></blockquote><h1 id="java中类加载器可以加载两个相同包名的类吗？"><a href="#java中类加载器可以加载两个相同包名的类吗？" class="headerlink" title="java中类加载器可以加载两个相同包名的类吗？"></a>java中类加载器可以加载两个相同包名的类吗？</h1><p>如果使用不同的类加载器，可以加载两个相同全限定名的类。</p><h1 id="jni是什么"><a href="#jni是什么" class="headerlink" title="jni是什么"></a>jni是什么</h1><p>java native interface java本地接口<br>即java可以调用本地方法的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chnic.jni;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SayHellotoCPP</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SayHellotoCPP</span><span class="params">()</span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>首先先一个有native标识方法的java类，然后使用javah -jni 类全限定名 生成一个.h头文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -jni com.chnic.jni.SayHellotoCPP  </span><br></pre></td></tr></table></figure><p>然后创建一个c++工程项目，在项目中打开上面生成的.h头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Class:     com_chnic_jni_SayHellotoCPP </span></span><br><span class="line"><span class="comment"> * Method:    sayHello </span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;)V </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_com_chnic_jni_SayHellotoCPP_sayHello</span>  </span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject, jstring)</span></span>;  </span><br></pre></td></tr></table></figure><p>可以看到注释中有一个Signature签名。 </p><p>现在就是当在java方法里调用了sayHello方法以后就会唤醒在dll里的Java_com_chnic_jni_SayHellotoCPP_sayHello方法，因此要新建一个C++ source file来实现这个方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_chnic_jni_SayHellotoCPP.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_com_chnic_jni_SayHellotoCPP_sayHello</span>   </span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv* env, jobject obj, jstring name)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pname = env-&gt;<span class="built_in">GetStringUTFChars</span>(name, <span class="literal">NULL</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; pname &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>然后对该类进行编译，发现缺少jni.h文件，引入#include “jni.h”，再编译发现缺少jni_md.h，引入再编译，发现生成了HelloEnd.dll文件。  </p><p>之后要将java程序与c++的程序连接起来，要让java认识这个动态链接库，就要把dll文件放到windows path环境变量下面。  </p><p>两种方式：  </p><ul><li>把这个DLL放到windows下面的sysytem32文件夹下面，这个是windows默认的path</li><li>复制你工程的Debug目录，我这里是C:/Program Files/Microsoft Visual Studio/MyProjects/HelloEnd/Debug这个目录，把这个目录配置到User variable的Path下面。重启eclipse，让eclipse在启动的时候重新读取这个path变量。</li></ul><p>在配置完环境变量以后，java程序就能找到这个dll文件，接下来要让java代码认识的话，要通过系统调用System.loadLibrary(“HelloEnd”);<br>在java代码的静态代码块中添加这一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chnic.jni;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SayHellotoCPP</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.loadLibrary(<span class="string">&quot;HelloEnd&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SayHellotoCPP</span><span class="params">()</span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>然后调用这个java方法就可以执行native方法了。   </p><blockquote><p>参考<a href="https://www.cnblogs.com/lechance/p/4373163.html">Java JNI的详细介绍</a></p></blockquote><h1 id="浮点数在计算机内存中的存储方式"><a href="#浮点数在计算机内存中的存储方式" class="headerlink" title="浮点数在计算机内存中的存储方式"></a>浮点数在计算机内存中的存储方式</h1><p>首先，采用的是科学计数法的方式。  </p><ul><li>S表示符号，正或者负</li><li></li></ul><p>5.5 首先其二进制位为 0101.1</p><h1 id="静态链接与动态链接的区别"><a href="#静态链接与动态链接的区别" class="headerlink" title="静态链接与动态链接的区别"></a>静态链接与动态链接的区别</h1><p>c代码的处理流程是 预处理、编译、汇编、链接 最后生成可执行性文件。</p><ul><li>静态链接： 那么就是在每个c文件独立生成的o文件进行链接生成，可执行文件的过程就是静态链接的过程。<ul><li>缺点： 1. 浪费空间，不同的链接生成的文件可能有相同的.o文件，为了各自都能执行，那就是每人一份。2. 文件更新困难。</li><li>优点： 执行的时候速度快。</li></ul></li><li>动态链接： 在运行时才对不同的.o文件进行链接，即使多个.o依赖同一个.o文件，也只需要使用内存中存在的一份即可。</li></ul><h1 id="一个线程崩溃会影响进程与进程内其他线程不？"><a href="#一个线程崩溃会影响进程与进程内其他线程不？" class="headerlink" title="一个线程崩溃会影响进程与进程内其他线程不？"></a>一个线程崩溃会影响进程与进程内其他线程不？</h1><p>如果是在java里面，进程崩溃的话一般就栈溢出或者OOM，这时候会触发GC，如果其他线程没有同时申请大内存空间的话，不会抛异常。</p><p>但是在linux里面的话，有可能因为线程的栈溢出或者堆区内存溢出，覆盖了其他线程的内存数据导致其他线程崩溃最终导致进程崩溃。</p><h1 id="p、p与-amp-p的区别"><a href="#p、p与-amp-p的区别" class="headerlink" title="*p、p与&amp;p的区别"></a>*<em>p、</em>p与&amp;p的区别</h1><p>首先定义一个变量int a=3;  假设a变量地址为0002<br>然后定义一个指针并同时初始化 int *p = &a;   假设p指针变量地址为0004<br>当前定义指针还一种方式就是int *p; p=&a;    </p><blockquote><p>注意*p指向a地址的过程是将a的地址号复制到p指针的内存空间中。</p></blockquote><p>那么通过这个指针，能获得的信息包括：</p><ul><li>&amp;p获得的是指针p的地址0004  </li><li>p获得的是a变量的地址0002</li><li>*p获得的是a的值也就是3  </li></ul><p>那么在子函数给指针分配内存空间的时候要注意什么呢？要注意传递给子函数的应该是指针的地址&amp;p，子函数的局部变量根据指针定义的规则，要使用p指针的指针来指向这个地址&amp;p，即<strong>tp=&amp;p。<br>那么对于</strong>tp能获得的信息：</p><ul><li>&amp;*tp就是这个p指针的指针的地址</li><li>*tp就是p指针的地址</li><li>**tp就是p指针存放的数据，即a变量的地址</li></ul><p>在回到指针p，给指针p赋值一个malloc的地址，指的是p指向一个malloc出来的内存空间。子函数里怎么操作能满足呢？</p><p>那么现在p指针的地址也知道了，就是<em>tp，然后赋值一个物理地址给他，</em>tp = (char *)malloc(100）;</p><h1 id="HashMap解决冲突的方法"><a href="#HashMap解决冲突的方法" class="headerlink" title="HashMap解决冲突的方法"></a>HashMap解决冲突的方法</h1><ol><li>开放地址法<ol><li>线性探测再散列 - 就是线性向后找2数组为空的</li><li>平方探测再散列 - 就是+1平方，+2平方不断往后找</li></ol></li><li>拉链法</li><li>再hash法 - 使用另一个方法再次计算hashcode</li></ol><h1 id="线程池cpu密集型与io密集型设置多少线程数量"><a href="#线程池cpu密集型与io密集型设置多少线程数量" class="headerlink" title="线程池cpu密集型与io密集型设置多少线程数量"></a>线程池cpu密集型与io密集型设置多少线程数量</h1><p>cpu密集型线程数量与cpu核数相同，io密集型的话线程数量为cpu核数得二倍。</p><h1 id="线程池的一个线程抛异常了，线程池是怎么做的？"><a href="#线程池的一个线程抛异常了，线程池是怎么做的？" class="headerlink" title="线程池的一个线程抛异常了，线程池是怎么做的？"></a>线程池的一个线程抛异常了，线程池是怎么做的？</h1><h1 id="线程池是怎么做一个线程的复用的？"><a href="#线程池是怎么做一个线程的复用的？" class="headerlink" title="线程池是怎么做一个线程的复用的？"></a>线程池是怎么做一个线程的复用的？</h1><p>因为Worker本身是一个Runnable接口的实现类，对于用户提交的任务runnable实际上是传到这个Worker里面进行了包装，作为了Worker里面的一个成员变量。然后这个线程池维护的Worker Runnable对象的run方法调用了runWorker方法，这个方法里面有一个while循环，除了执行当前worker对象本身的用户提交的task以后，还会不断从阻塞队列里面去取任务出来执行，直到没有任务就去到processWorkerExit方法里准备退出，将当前的worker从数组里面清理掉，然后判断如果小于核心线程数的话，再调用一次addWorker方法添加一个空任务的worker对象到数组里面存着。</p><h1 id="线程池的核心线程数量是怎么由大于当前的数量减少为核心线程数的"><a href="#线程池的核心线程数量是怎么由大于当前的数量减少为核心线程数的" class="headerlink" title="线程池的核心线程数量是怎么由大于当前的数量减少为核心线程数的"></a>线程池的核心线程数量是怎么由大于当前的数量减少为核心线程数的</h1><p>上面的回答解释了，当阻塞队列没有任务可以做了以后，会进行worker对象的收尾工作，然后清理掉，但是还会判断当前线程数目是不是大于核心线程数，如果小于会重新addWorker嘛，大于就不会再新增了，这样最后会减到corePoolSize。</p><h1 id="如何看待美团优选事业部"><a href="#如何看待美团优选事业部" class="headerlink" title="如何看待美团优选事业部"></a>如何看待美团优选事业部</h1><p>美团优选事业部主打社区团购，瞄准的是下沉市场，提供的是社区服务范围，以及预定加自提的这么一种模式。所以这种肯定是为了提高生活质量的一种应用。 是对社区生活资源的一种打乱重组提高利用率。但是是具有地域性特点的，因为局限在社区，因此对于小城乡镇是比较方便的。当然对于大城市，目前相似的社区应用很多，比如京东买菜这样类型的吧，而且外卖配送比较发达，社区团购就感觉会冲突，所以美团瞄准的市场我觉得应该是农村乡镇的资源重组利用，进行切入。</p><h1 id="select-和select-a的区别"><a href="#select-和select-a的区别" class="headerlink" title="select *和select a的区别"></a>select *和select a的区别</h1><p>select *会查找到所有字段，而select a只会查询a字段出来，而且如果a字段有索引，那么通过a索引的b+树就能查询数据并返回，而select *会先走非主键索引，再回表查询主键索引。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis原理详解</title>
      <link href="/2020/08/26/Mybatis%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/26/Mybatis%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="MybatisAutoConfiguration"><a href="#MybatisAutoConfiguration" class="headerlink" title="MybatisAutoConfiguration"></a>MybatisAutoConfiguration</h1><p>首先这个自动配置类包含注解 @AutoConfigureAfter({DataSourceAutoConfiguration.class}) 表示当前类要在这个类之后加载，假设数据源已经加载好了。</p><p>然后通过SqlSessionFactoryBean生成SqlSessionFactory并注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    factory.setDataSource(dataSource);</span><br><span class="line">    factory.setVfs(SpringBootVFS.class);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.properties.getConfigLocation())) &#123;</span><br><span class="line">        factory.setConfigLocation(<span class="built_in">this</span>.resourceLoader.getResource(<span class="built_in">this</span>.properties.getConfigLocation()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    org.apache.ibatis.session.<span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="built_in">this</span>.properties.getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (configuration == <span class="literal">null</span> &amp;&amp; !StringUtils.hasText(<span class="built_in">this</span>.properties.getConfigLocation())) &#123;</span><br><span class="line">        configuration = <span class="keyword">new</span> <span class="title class_">org</span>.apache.ibatis.session.Configuration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configuration != <span class="literal">null</span> &amp;&amp; !CollectionUtils.isEmpty(<span class="built_in">this</span>.configurationCustomizers)) &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationCustomizers.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            <span class="type">ConfigurationCustomizer</span> <span class="variable">customizer</span> <span class="operator">=</span> (ConfigurationCustomizer)var4.next();</span><br><span class="line">            customizer.customize(configuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    factory.setConfiguration(configuration);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.properties.getConfigurationProperties() != <span class="literal">null</span>) &#123;</span><br><span class="line">        factory.setConfigurationProperties(<span class="built_in">this</span>.properties.getConfigurationProperties());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.interceptors)) &#123;</span><br><span class="line">        factory.setPlugins(<span class="built_in">this</span>.interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.databaseIdProvider != <span class="literal">null</span>) &#123;</span><br><span class="line">        factory.setDatabaseIdProvider(<span class="built_in">this</span>.databaseIdProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(<span class="built_in">this</span>.properties.getTypeAliasesPackage())) &#123;</span><br><span class="line">        factory.setTypeAliasesPackage(<span class="built_in">this</span>.properties.getTypeAliasesPackage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(<span class="built_in">this</span>.properties.getTypeHandlersPackage())) &#123;</span><br><span class="line">        factory.setTypeHandlersPackage(<span class="built_in">this</span>.properties.getTypeHandlersPackage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.properties.resolveMapperLocations())) &#123;</span><br><span class="line">        factory.setMapperLocations(<span class="built_in">this</span>.properties.resolveMapperLocations());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过SqlSessionFactory生成sqlSessionTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionTemplate <span class="title function_">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorType</span> <span class="variable">executorType</span> <span class="operator">=</span> <span class="built_in">this</span>.properties.getExecutorType();</span><br><span class="line">    <span class="keyword">return</span> executorType != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory, executorType) : <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经取得了SqlSessionFactory对象，那么只需要openSession就能获得一个SqlSession对象DefaultSqlSession。</p><h1 id="Mapper对象咋来的"><a href="#Mapper对象咋来的" class="headerlink" title="Mapper对象咋来的"></a>Mapper对象咋来的</h1><p>首先Mybatis将我们的所有配置解析为Configuration对象。<br>首先看DefaultSqlSession的getMapper方法，我们都知道，通过sqlSession.getMapper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>configuration对象是我们在加载DefaultSqlSessionFactory时传入的。</p><p>然后看下这个的getMapper方法，通过mapperRegistry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于mapperRegistry里面有什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MapperRegistry</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.config = config;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有Configuration对象与一个Map，包含一个类型键与Mapper代理工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到一个return了，返回了mapperProxyFactory生成的一个实例对象。往下看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">   <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过这个方式可以看出来mapperProxyFactory.newInstance里的创建了一个MapperProxy对象。后面的newInstance先不管，首先肯定返回出去的Mapper对象是一个Mapper的代理对象。</p><p>既然是Mapper代理对象，看一下MapperProxy这个类，实现了InvocationHandler接口，并重写了invoke方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">      <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法。  </p><ol><li>从代码中我们可以看到前面做了一个判断，这个判断主要是保证我们调用像toString方法或者equals方法时也能正常调用。  </li><li>然后我们可以看到它调用cachedMapperMethod返回MapperMethod对象，这个cachedMapperMethod方法主要是能缓存我们使用过的一些mapperMethod对象，方便下次使用。</li><li>这个MapperMethod对象主要是获取方法对应的sql命令和执行相应SQL操作等的处理。</li></ol><p>接着往execute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName() </span><br><span class="line">          + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的Command是哪来的？</p><h1 id="Mybatis预编译"><a href="#Mybatis预编译" class="headerlink" title="Mybatis预编译"></a>Mybatis预编译</h1><p>使用jdbc的preparedStatement来预编译语句。<br>使用#{}与${}的时候，Mybatis动态sql解析的时候，解析成BoundSql对象的时候#{}会被解析成?占位符，得到一串没有参数的sql语句。</p><p>即使没有开启预编译，preparedStatement<br>preparedStatement提供了一个setString的方法，能对字符串里面的部分符号做转义处理。</p><p>如果开启了预编译，那么一条语句会与Mysql进行两次传输，第一次传输?占位符的sql语句进行预编译，第二次传递完整转义的sql语句执行。</p><p>一条sql语句执行包括</p><ul><li>解析阶段<ul><li>主要做各种校验</li></ul></li><li>编译阶段</li><li>优化阶段<ul><li>编译优化结束以后，语句执行逻辑就确定了</li></ul></li><li>缓存阶段</li><li>执行阶段</li></ul><p>所以在set参数的时候，preparedStatement就已经完成了编译的过程，后续只是将数据进行替换，参数中的执行逻辑是不会被解析的。</p><p>所以预编译的优点就是性能优势，sql语句的分析、编译、优化，在第一次传输时已经完成，后续如果是相同的sql语句直接执行就可以。</p><h1 id="什么情况下不能使用预编译"><a href="#什么情况下不能使用预编译" class="headerlink" title="什么情况下不能使用预编译"></a>什么情况下不能使用预编译</h1><h1 id="数据库连接池参数"><a href="#数据库连接池参数" class="headerlink" title="数据库连接池参数"></a>数据库连接池参数</h1><ol><li><p>maxActive 连接池支持的最大连接数，这里取值为20，表示同时最多有20个数据库连接。一般把maxActive设置成可能的并发量就行了设 0 为没有限制。</p></li><li><p>maxIdle 连接池中最多可空闲maxIdle个连接 ，这里取值为20，表示即使没有数据库连接时依然可以保持20空闲的连接，而不被清除，随时处于待命状态。设 0 为没有限制。</p></li><li><p>minIdle 连接池中最小空闲连接数，当连接数少于此值时，连接池会创建连接来补充到该值的数量</p></li><li><p>initialSize 初始化连接数目</p></li><li><p>maxWait 连接池中连接用完时,新的请求等待时间,毫秒，这里取值-1，表示无限等待，直到超时为止，也可取值9000，表示9秒后超时。超过时间会出错误信息</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Mybaits </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring_Boot_事务管理</title>
      <link href="/2020/08/26/Spring-Boot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2020/08/26/Spring-Boot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>首先还是从自动配置类入手，看看哪些关键类被实例化。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring_Boot_AOP原理详解</title>
      <link href="/2020/08/26/Spring-Boot-AOP%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/26/Spring-Boot-AOP%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><p>主要分为三个步骤：</p><ol><li>创建AnnotationAwareAspectJAutoProxyCreator对象</li><li>扫描容器中的切面，创建PointcutAdvisor对象</li><li>生成代理类</li></ol><p>先总结:</p><ol><li>主要使用AnnotationAwareAspectJAutoProxyCreator类来初始化Aop</li><li>在Bean实例化之前执行beanPostProcess.postProcessBeforeInstantiation方法来生成所有的Advisor</li><li>在Bean实例初始化之后执行beanPostProcess.postProcessAfterInitialization方法来判断一个bean实例能否获得切在它上面的Advisor，如果能获得，说明需要生成代理类，否则不需要生成代理类</li></ol><h1 id="创建AnnotationAwareAspectJAutoProxyCreator对象"><a href="#创建AnnotationAwareAspectJAutoProxyCreator对象" class="headerlink" title="创建AnnotationAwareAspectJAutoProxyCreator对象"></a>创建AnnotationAwareAspectJAutoProxyCreator对象</h1><p>先从自动装配开始<br>观察AutoConfiguration类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; EnableAspectJAutoProxy.class, Aspect.class, Advice.class,</span></span><br><span class="line"><span class="meta">AnnotatedElement.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;, matchIfMissing = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续观察@EnableAspectJAutoProxy注解，其中proxyTargetClass属性默认为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入了一个Register，继续观察这个AspectJAutoProxyRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(</span></span><br><span class="line"><span class="params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line"><span class="type">AnnotationAttributes</span> <span class="variable">enableAspectJAutoProxy</span> <span class="operator">=</span></span><br><span class="line">AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line"><span class="comment">//将 aop 代理方式相关的变量设置到 AopConfigUtils，创建代理类时会读取变量</span></span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注册了一个AnnotationAwareAspectJAutoProxyCreator类的BeanDefinition对象</p><p>AnnotationAwareAspectJAutoProxyCreator这个类实现了BeanFactoryAware接口，能拿到Beanfactory，并最终执行initBeanFactory方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.initBeanFactory(beanFactory);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.aspectJAdvisorFactory == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//advisor 工厂类</span></span><br><span class="line"><span class="built_in">this</span>.aspectJAdvisorFactory = <span class="keyword">new</span> <span class="title class_">ReflectiveAspectJAdvisorFactory</span>(beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于创建 advisor</span></span><br><span class="line"><span class="built_in">this</span>.aspectJAdvisorsBuilder =</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">BeanFactoryAspectJAdvisorsBuilderAdapter</span>(beanFactory, <span class="built_in">this</span>.aspectJAdvisorFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扫描容器中的切面，创建PointcutAdvisor对象"><a href="#扫描容器中的切面，创建PointcutAdvisor对象" class="headerlink" title="扫描容器中的切面，创建PointcutAdvisor对象"></a>扫描容器中的切面，创建PointcutAdvisor对象</h1><p>注意上面创建的AnnotationAwareAspectJAutoProxyCreator对象，是SmartInstantiationAwareBeanPostProcessor的子类<br>在bean初始化之前会完成Advisor对象的初始化。通过执行beanPostProcessor.postProcessBeforeInstantiation()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="comment">//advisedBeans用于存储不可代理的bean，如果包含直接返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断当前bean是否可以被代理，然后存入advisedBeans</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line"><span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line"><span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line"><span class="comment">//到这里说明该bean可以被代理，所以去获取自定义目标类，如果没有定义，则跳过。</span></span><br><span class="line"><span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line"><span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="comment">//如果最终可以获得代理类，则返回代理类，直接执行实例化后置通知方法</span></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生成代理类"><a href="#生成代理类" class="headerlink" title="生成代理类"></a>生成代理类</h1><p>常规的生成代理类的时机在bean的实例初始化完成以后postProcessAfterInitialization中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">//处理循环依赖的判断</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line"><span class="comment">//获取到合适的advisor，如果为空。如果不为空，则生成代理类。</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line"><span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法通过调用getAdvicesAndAdvisorsForBean()方法来获取advisor，该方法最终会调用findEligibleAdvisors()，Eligible意为有资格的，合适的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line"><span class="comment">//获取到合适的advisor，如果为空。如果不为空，则生成代理类。</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line"><span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法通过调用getAdvicesAndAdvisorsForBean()方法来获取advisor，该方法最终会调用findEligibleAdvisors()，Eligible意为有资格的，合适的。具体来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="comment">//这里会对获取的advisor进行筛选</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line"><span class="comment">//添加一个默认的advisor，执行时用到。</span></span><br><span class="line">extendAdvisors(eligibleAdvisors);</span><br><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的筛选规则在AopUtils中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title function_">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="comment">// already processed</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//调用 canApply 方法，遍历所有的方法进行匹配</span></span><br><span class="line"><span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用canApply方法，遍历被代理类的所有的方法，跟进切面表达式进行匹配，如果有一个方法匹配到，也就意味着该类会被代理。</p><p>重点看一下生成代理类的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line"><span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果代理目标是接口或者Proxy类型，则走jdk类型</span></span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>optimize：官方文档翻译为设置代理是否应执行积极的优化，默认为false。</li><li>proxyTargetClass：这个在上面已经提到了，AopAutoConfiguration中指定，默认为true，也就是选择使用 cglib 代理。可以看到该变量和optimize意义一样，之所以这么做，个人理解是为了可以在不同的场景中使用。</li><li>hasNoUserSuppliedProxyInterfaces：是否设置了实现接口。</li></ul><h1 id="jdk实现的代理类"><a href="#jdk实现的代理类" class="headerlink" title="jdk实现的代理类"></a>jdk实现的代理类</h1><p>新建一个类IUser实现InvocationHandler类，重写invoke接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserManager</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String id, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserManager</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String id, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======调用了UserManagerImpl.addUser()方法======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/** 需要代理的目标对象 */</span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将目标对象传入进行代理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">newProxy</span><span class="params">(Object targetObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.targetObject = targetObject;</span><br><span class="line">        <span class="comment">//返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),</span><br><span class="line">                targetObject.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invoke方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 一般我们进行逻辑处理的函数比如这个地方是模拟检查权限</span></span><br><span class="line">        checkPopedom();</span><br><span class="line">        <span class="comment">// 设置方法的返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 调用invoke方法，ret存储该方法的返回值</span></span><br><span class="line">        ret  = method.invoke(targetObject, args);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟检查权限的例子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPopedom</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======检查权限checkPopedom()======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法执行前后添加操作。<br>jdk动态代理只能针对实现了接口的类来生成代理，</p><h1 id="cglib实现的代理"><a href="#cglib实现的代理" class="headerlink" title="cglib实现的代理"></a>cglib实现的代理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jpeony.spring.proxy.compare;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CGLibProxy动态代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/** CGLib需要代理的目标对象 */</span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxyObject</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.targetObject = obj;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(obj.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxyObj</span> <span class="operator">=</span> enhancer.create();</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> proxyObj;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args,</span></span><br><span class="line"><span class="params">                            MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 过滤方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;addUser&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="comment">// 检查权限</span></span><br><span class="line">            checkPopedom();</span><br><span class="line">        &#125;</span><br><span class="line">        obj = method.invoke(targetObject, args);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPopedom</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======检查权限checkPopedom()======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK代理类与Cglib代理类的区别"><a href="#JDK代理类与Cglib代理类的区别" class="headerlink" title="JDK代理类与Cglib代理类的区别"></a>JDK代理类与Cglib代理类的区别</h1><p>jdk的是java类库提供的，cglib是第三方库。<br>jdk需要代理类实现接口，cglib不需要。<br>jdk是通过反射来实现一个代理接口的匿名类，cglib通过修改字节码来生成子类来处理。</p><h1 id="AspectJ-aop与-Spring-aop的区别是"><a href="#AspectJ-aop与-Spring-aop的区别是" class="headerlink" title="AspectJ aop与 Spring aop的区别是"></a>AspectJ aop与 Spring aop的区别是</h1><p>AspectJ aop的织入是编译时织入，编译完成生成的class文件就将切面织入到了目标对象或者方法上面。<br>Spring aop的织入是运行时织入，在运行时生成目标类的代理对象并织入。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operation-core</title>
      <link href="/2020/08/25/operation-core/"/>
      <url>/2020/08/25/operation-core/</url>
      
        <content type="html"><![CDATA[<h1 id="CAS单点登录"><a href="#CAS单点登录" class="headerlink" title="CAS单点登录"></a>CAS单点登录</h1><h1 id="passport登录"><a href="#passport登录" class="headerlink" title="passport登录"></a>passport登录</h1><p>*.domain.cn 这是跨了三级域名<br>*.com这是跨了二级域名<br>因此对于一级域</p><p>首先访问服务器a，未登录，前端拿着用户名与密码去passport登录并带上服务器a的login url，passport与翻译系统的服务器有相同的二级域名，passport登录成功以后会使用SetCookie将AuthCookie种到相同的domain域名下，这个Cookie里面有个AuthCookie的字段，然后重定向后端这里的Login方法，Login会拿着AuthCookie字段对应的值去请求passport服务端获得用户信息，验证成功就返回用户信息。</p><h1 id="登录成功后将用户名存入principal，将其他用户名、id、昵称、缩略图存入request-setAttribute"><a href="#登录成功后将用户名存入principal，将其他用户名、id、昵称、缩略图存入request-setAttribute" class="headerlink" title="登录成功后将用户名存入principal，将其他用户名、id、昵称、缩略图存入request.setAttribute"></a>登录成功后将用户名存入principal，将其他用户名、id、昵称、缩略图存入request.setAttribute</h1><h1 id="dealFirstLogin-处理第一次登录"><a href="#dealFirstLogin-处理第一次登录" class="headerlink" title="dealFirstLogin 处理第一次登录"></a>dealFirstLogin 处理第一次登录</h1><p>将用户信息入库，同时添加一个默认权限信息入库。 加锁</p><h1 id="通过principal构建Security里的AuthenticationToken对象"><a href="#通过principal构建Security里的AuthenticationToken对象" class="headerlink" title="通过principal构建Security里的AuthenticationToken对象"></a>通过principal构建Security里的AuthenticationToken对象</h1><h1 id="存入Detail对象，包含客户端地址与SessionId，为空则为null"><a href="#存入Detail对象，包含客户端地址与SessionId，为空则为null" class="headerlink" title="存入Detail对象，包含客户端地址与SessionId，为空则为null"></a>存入Detail对象，包含客户端地址与SessionId，为空则为null</h1><h1 id="调用authenticationManager-authenticate-authRequest"><a href="#调用authenticationManager-authenticate-authRequest" class="headerlink" title="调用authenticationManager.authenticate(authRequest)"></a>调用authenticationManager.authenticate(authRequest)</h1><p>由Security里面的一个类解析注入 ProviderManager<br>xml里添加PreAuthentionProvider，依赖UserDetailService</p><h1 id="重写了一下UserDetailService的loadUserByUsername-username-方法-这个方法的目的是生成包含权限信息的UserDetail对象"><a href="#重写了一下UserDetailService的loadUserByUsername-username-方法-这个方法的目的是生成包含权限信息的UserDetail对象" class="headerlink" title="重写了一下UserDetailService的loadUserByUsername(username)方法 这个方法的目的是生成包含权限信息的UserDetail对象"></a>重写了一下UserDetailService的loadUserByUsername(username)方法 这个方法的目的是生成包含权限信息的UserDetail对象</h1><p>这里传的是name是因为在 PreAuthentionProvider 里的依赖项是一个 UserDetailServiceWrapper 将AuthenticationToken 的principal传进去了<br>方法里做的就是查 刚刚 登录的那个用户名的 权限列表，得到的是权限的id列表，将这个id列表封装成SimpleGrantedAuthority，就是Spring Security的权限</p><p>最后用户名有了，用户权限列表有了，生成User对象 return new User(username, “”, auths);</p><h1 id="USer传回到Provider的authenticate方法里面，再次包装成AuthenticationToken对象，包括用户名、权限列表，以及之前存入的Detail对象，返回"><a href="#USer传回到Provider的authenticate方法里面，再次包装成AuthenticationToken对象，包括用户名、权限列表，以及之前存入的Detail对象，返回" class="headerlink" title="USer传回到Provider的authenticate方法里面，再次包装成AuthenticationToken对象，包括用户名、权限列表，以及之前存入的Detail对象，返回"></a>USer传回到Provider的authenticate方法里面，再次包装成AuthenticationToken对象，包括用户名、权限列表，以及之前存入的Detail对象，返回</h1><h1 id="返回到ProvaideManager对象的authenticate方法里面得到新的AuthenticationToken对象"><a href="#返回到ProvaideManager对象的authenticate方法里面得到新的AuthenticationToken对象" class="headerlink" title="返回到ProvaideManager对象的authenticate方法里面得到新的AuthenticationToken对象"></a>返回到ProvaideManager对象的authenticate方法里面得到新的AuthenticationToken对象</h1><h1 id="最终回到我自己定义的Filter，获得用户角色列表转成json，存到redis里面，用户角色id的列表也存到redis里面"><a href="#最终回到我自己定义的Filter，获得用户角色列表转成json，存到redis里面，用户角色id的列表也存到redis里面" class="headerlink" title="最终回到我自己定义的Filter，获得用户角色列表转成json，存到redis里面，用户角色id的列表也存到redis里面"></a>最终回到我自己定义的Filter，获得用户角色列表转成json，存到redis里面，用户角色id的列表也存到redis里面</h1><p>最后把之前登录的用户信息，全部存到Session里面request.getSession().setAttribute</p><h1 id="中间进一下logoutFilter-做SecurityContext清理工作，UrlLogoutSuccessHandler里面outSide登录的直接返回成功即可"><a href="#中间进一下logoutFilter-做SecurityContext清理工作，UrlLogoutSuccessHandler里面outSide登录的直接返回成功即可" class="headerlink" title="中间进一下logoutFilter 做SecurityContext清理工作，UrlLogoutSuccessHandler里面outSide登录的直接返回成功即可"></a>中间进一下logoutFilter 做SecurityContext清理工作，UrlLogoutSuccessHandler里面outSide登录的直接返回成功即可</h1><h1 id="ExceptionTranslationFilter"><a href="#ExceptionTranslationFilter" class="headerlink" title="ExceptionTranslationFilter"></a>ExceptionTranslationFilter</h1><h1 id="GlobalFilterSecurityInterceptor"><a href="#GlobalFilterSecurityInterceptor" class="headerlink" title="GlobalFilterSecurityInterceptor"></a>GlobalFilterSecurityInterceptor</h1><pre><code>会依赖 authenticationManager accessDecisionManager 与securityMetadataSource</code></pre><h1 id="CustomSecurityMetadataSource这个metaDataSource为一开始就注入生成的Bean，在FilterSecurityInterceptor-中会调用getAttribute"><a href="#CustomSecurityMetadataSource这个metaDataSource为一开始就注入生成的Bean，在FilterSecurityInterceptor-中会调用getAttribute" class="headerlink" title="CustomSecurityMetadataSource这个metaDataSource为一开始就注入生成的Bean，在FilterSecurityInterceptor 中会调用getAttribute"></a>CustomSecurityMetadataSource这个metaDataSource为一开始就注入生成的Bean，在FilterSecurityInterceptor 中会调用getAttribute</h1><p>主要继承实现getAttribute方法 根据请求获得 访问请求需要的权限列表</p><h1 id="最后进入GlobalFilterSecurityInterceptor-类里的beforeInvocation方法，调用决策器决策AuthenticationToken、request的Attribute"><a href="#最后进入GlobalFilterSecurityInterceptor-类里的beforeInvocation方法，调用决策器决策AuthenticationToken、request的Attribute" class="headerlink" title="最后进入GlobalFilterSecurityInterceptor 类里的beforeInvocation方法，调用决策器决策AuthenticationToken、request的Attribute"></a>最后进入GlobalFilterSecurityInterceptor 类里的beforeInvocation方法，调用决策器决策AuthenticationToken、request的Attribute</h1><h1 id="关于session的登录状态问题"><a href="#关于session的登录状态问题" class="headerlink" title="关于session的登录状态问题"></a>关于session的登录状态问题</h1><p>首先在登录过滤器里面获得不创建方式的Session，session不为空且，attribute属性里用户名不为空，就认为登录成功了。否则就要去登录。在passport登录完以后会给cookie里种一个Token，调用后端的登录接口，对于登录的/login请求跳过登录过滤器，进入SecurityContextFilter创建session，保存AuthenticationToken，然后进入自定义的AbstractAuthenticationProcessingFilter，定义这个主要是因为里面有现成的authentacationManager做用户校验。在这个filter里面做用户登录，就是拿着passport给的登录成功的token去请求一下passort验证一下，并返回用户名一些信息，然后把这些信息存到，request里面，session里面，最后过滤器链走完了会commitSession保存到redis。登出操作的时候，一搬要清理Cookie、Session、SecurityContext里的AuthenticationToken。</p><p>SecurityMetadataSource的getAttribute方法也很重要，方法返回获取的是资源具有的权限。<br>UserDetailsService.loadUserDetails获得用户具有的权限，有交集就成功。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Activiti6部分源码解析</title>
      <link href="/2020/08/24/Activiti6%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/08/24/Activiti6%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="开启流程实例"><a href="#开启流程实例" class="headerlink" title="开启流程实例"></a>开启流程实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService.startProcessInstanceByKey(ActivitiConstant.VIDEO_TRANSLATE_PROCESS_ID,</span><br><span class="line">                        translateTask.getTranslatePartnerId().toString(),</span><br><span class="line">                        vars);</span><br></pre></td></tr></table></figure><p>以startProcessInstanceByKey方法为例，点进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ProcessInstance <span class="title function_">startProcessInstanceByKey</span><span class="params">(String processDefinitionKey, String businessKey, Map&lt;String, Object&gt; variables)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (ProcessInstance)<span class="built_in">this</span>.commandExecutor.execute(<span class="keyword">new</span> <span class="title class_">StartProcessInstanceCmd</span>(processDefinitionKey, (String)<span class="literal">null</span>, businessKey, variables));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实例化了一个StartProcessInstanceCmd对象，看看如何实例化的。<br>在StartProcessInstanceCmd的execute方法中看到从deploymentcache中取得流程定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ProcessInstance <span class="title function_">execute</span><span class="params">(CommandContext commandContext)</span> &#123;</span><br><span class="line">        <span class="type">DeploymentManager</span> <span class="variable">deploymentCache</span> <span class="operator">=</span> commandContext.getProcessEngineConfiguration().getDeploymentManager();</span><br><span class="line">        <span class="type">ProcessDefinition</span> <span class="variable">processDefinition</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.processDefinitionId != <span class="literal">null</span>) &#123;</span><br><span class="line">            processDefinition = deploymentCache.findDeployedProcessDefinitionById(<span class="built_in">this</span>.processDefinitionId);</span><br><span class="line">            <span class="keyword">if</span> (processDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ActivitiObjectNotFoundException</span>(<span class="string">&quot;No process definition found for id = &#x27;&quot;</span> + <span class="built_in">this</span>.processDefinitionId + <span class="string">&quot;&#x27;&quot;</span>, ProcessDefinition.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.processDefinitionKey == <span class="literal">null</span> || <span class="built_in">this</span>.tenantId != <span class="literal">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(<span class="built_in">this</span>.tenantId)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.processDefinitionKey == <span class="literal">null</span> || <span class="built_in">this</span>.tenantId == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(<span class="built_in">this</span>.tenantId)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ActivitiIllegalArgumentException</span>(<span class="string">&quot;processDefinitionKey and processDefinitionId are null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processDefinition = deploymentCache.findDeployedLatestProcessDefinitionByKeyAndTenantId(<span class="built_in">this</span>.processDefinitionKey, <span class="built_in">this</span>.tenantId);</span><br><span class="line">            <span class="keyword">if</span> (processDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ActivitiObjectNotFoundException</span>(<span class="string">&quot;No process definition found for key &#x27;&quot;</span> + <span class="built_in">this</span>.processDefinitionKey + <span class="string">&quot;&#x27; for tenant identifier &quot;</span> + <span class="built_in">this</span>.tenantId, ProcessDefinition.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            processDefinition = deploymentCache.findDeployedLatestProcessDefinitionByKey(<span class="built_in">this</span>.processDefinitionKey);</span><br><span class="line">            <span class="keyword">if</span> (processDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ActivitiObjectNotFoundException</span>(<span class="string">&quot;No process definition found for key &#x27;&quot;</span> + <span class="built_in">this</span>.processDefinitionKey + <span class="string">&quot;&#x27;&quot;</span>, ProcessDefinition.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.processInstanceHelper = commandContext.getProcessEngineConfiguration().getProcessInstanceHelper();</span><br><span class="line">        <span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> <span class="built_in">this</span>.createAndStartProcessInstance(processDefinition, <span class="built_in">this</span>.businessKey, <span class="built_in">this</span>.processInstanceName, <span class="built_in">this</span>.variables, <span class="built_in">this</span>.transientVariables);</span><br><span class="line">        <span class="keyword">return</span> processInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后会去调用findDeployedLatestProcessDefinitionByKey方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ProcessDefinition <span class="title function_">findDeployedLatestProcessDefinitionByKey</span><span class="params">(String processDefinitionKey)</span> &#123;</span><br><span class="line">    <span class="type">ProcessDefinition</span> <span class="variable">processDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.processDefinitionEntityManager.findLatestProcessDefinitionByKey(processDefinitionKey);</span><br><span class="line">    <span class="keyword">if</span> (processDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ActivitiObjectNotFoundException</span>(<span class="string">&quot;no processes deployed with key &#x27;&quot;</span> + processDefinitionKey + <span class="string">&quot;&#x27;&quot;</span>, ProcessDefinition.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ProcessDefinition</span> <span class="variable">processDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.resolveProcessDefinition(processDefinition).getProcessDefinition();</span><br><span class="line">        <span class="keyword">return</span> processDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的findLatestProcessDefinitionByKey方法最终会去执行sql，查询表ACT_RE_PROCDEF</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectLatestProcessDefinitionByKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;processDefinitionResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from $&#123;prefix&#125;ACT_RE_PROCDEF </span><br><span class="line">    where KEY_ = #&#123;key&#125; and</span><br><span class="line">          (TENANT_ID_ = &#x27;&#x27;  or TENANT_ID_ is null) and</span><br><span class="line">          VERSION_ = (select max(VERSION_) from $&#123;prefix&#125;ACT_RE_PROCDEF where KEY_ = #&#123;processDefinitionKey&#125; and (TENANT_ID_ = &#x27;&#x27; or TENANT_ID_ is null))</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面的resolveProcessDefinition则会去继续解析流程定义ACT_GE_BYTEARRAY、ACT_RE_DEPLOYMENT。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ProcessDefinitionCacheEntry <span class="title function_">resolveProcessDefinition</span><span class="params">(ProcessDefinition processDefinition)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">processDefinitionId</span> <span class="operator">=</span> processDefinition.getId();</span><br><span class="line">     <span class="type">String</span> <span class="variable">deploymentId</span> <span class="operator">=</span> processDefinition.getDeploymentId();</span><br><span class="line">     <span class="type">ProcessDefinitionCacheEntry</span> <span class="variable">cachedProcessDefinition</span> <span class="operator">=</span> (ProcessDefinitionCacheEntry)<span class="built_in">this</span>.processDefinitionCache.get(processDefinitionId);</span><br><span class="line">     <span class="keyword">if</span> (cachedProcessDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="type">CommandContext</span> <span class="variable">commandContext</span> <span class="operator">=</span> Context.getCommandContext();</span><br><span class="line">         <span class="keyword">if</span> (commandContext.getProcessEngineConfiguration().isActiviti5CompatibilityEnabled() &amp;&amp; Activiti5Util.isActiviti5ProcessDefinition(Context.getCommandContext(), processDefinition)) &#123;</span><br><span class="line">             <span class="keyword">return</span> Activiti5Util.getActiviti5CompatibilityHandler().resolveProcessDefinition(processDefinition);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="type">DeploymentEntity</span> <span class="variable">deployment</span> <span class="operator">=</span> (DeploymentEntity)<span class="built_in">this</span>.deploymentEntityManager.findById(deploymentId);</span><br><span class="line">         deployment.setNew(<span class="literal">false</span>);</span><br><span class="line">         <span class="built_in">this</span>.deploy(deployment, (Map)<span class="literal">null</span>);</span><br><span class="line">         cachedProcessDefinition = (ProcessDefinitionCacheEntry)<span class="built_in">this</span>.processDefinitionCache.get(processDefinitionId);</span><br><span class="line">         <span class="keyword">if</span> (cachedProcessDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ActivitiException</span>(<span class="string">&quot;deployment &#x27;&quot;</span> + deploymentId + <span class="string">&quot;&#x27; didn&#x27;t put process definition &#x27;&quot;</span> + processDefinitionId + <span class="string">&quot;&#x27; in the cache&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> cachedProcessDefinition;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果cachedProcessDefinition为null，则会执行this.deploy(deployment, (Map)null)方法，此方法里会完成对xml的解析保存工作。</p><h1 id="查询任务"><a href="#查询任务" class="headerlink" title="查询任务"></a>查询任务</h1><h1 id="自动创建表"><a href="#自动创建表" class="headerlink" title="自动创建表"></a>自动创建表</h1><p>配置文件中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 是否自动部署</span><br><span class="line">spring.activiti.database-schema-update=true</span><br></pre></td></tr></table></figure><p>配置ProcessEngineConfiguration.setDatabaseSchemaUpdate(“true”)<br>那么当创建ProcessEngine的时候就会自动创建表</p><p>设置寻找bpmn图的位置以及图的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.activiti.process-definition-location-prefix=classpath:/bpmn/</span><br><span class="line">spring.activiti.process-definition-location-suffixes=**.bpmn</span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>在引擎的AutoConfiguration包里面的processEngineConfigurationBean方法中注入了事务管理器与dataSource。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SpringProcessEngineConfiguration <span class="title function_">processEngineConfigurationBean</span><span class="params">(Resource[] processDefinitions, DataSource dataSource, PlatformTransactionManager transactionManager, SpringAsyncExecutor springAsyncExecutor)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SpringProcessEngineConfiguration</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringProcessEngineConfiguration</span>();</span><br><span class="line">    <span class="keyword">if</span> (processDefinitions != <span class="literal">null</span> &amp;&amp; processDefinitions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        engine.setDeploymentResources(processDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    engine.setDataSource(dataSource);</span><br><span class="line">    engine.setTransactionManager(transactionManager);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != springAsyncExecutor) &#123;</span><br><span class="line">        engine.setAsyncExecutor(springAsyncExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> engine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在数据源的AutoConfiguration包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到生成的事务管理器为DataSourceTransactionManager，与SpringBoot是相同的，而且使用了@ConditionalOnMissingBean注解，保证与SpringBoot是只有一个这个事务管理器。</p><p> 数据源在源码里没找到，猜想是spring boot jdbc的数据源。</p><h1 id="分布式环境下Activiti6主键问题"><a href="#分布式环境下Activiti6主键问题" class="headerlink" title="分布式环境下Activiti6主键问题"></a>分布式环境下Activiti6主键问题</h1><p> 因为Activiti6的主键是自己维护的，通过IdGenerator来生成的，通过对getNextId加锁来获得下一个主键id。</p><p> 单机可以，分布式就可能会出错，因此：</p><ol><li>使用redis来自增获得主键，不同主机获得的也不一样</li><li>加分布式锁</li></ol><h1 id="关于视频字幕翻译系统的难点"><a href="#关于视频字幕翻译系统的难点" class="headerlink" title="关于视频字幕翻译系统的难点"></a>关于视频字幕翻译系统的难点</h1><ol><li>翻译公司要求能批量添加翻译任务，每一个任务都要使用activiti6开启流程实例，然后获得流程实例id与对应翻译任务关联。但是activiti没有提供一个批量的api，我这边如果一次批量创建了太多流程实例接口就特别的慢，然后将整个开启流程、更新翻译任务表、完成第一个任务节点的操作异步去做了。然后开一个定时任务扫描最近10分钟的失败的，重新开一个流程实例挂到对应翻译任务上。</li><li>字幕条数可能在原始字幕校对、翻译、审核、字幕制作阶段变化，之所以要顺序Id，是最后解析成文件的时候，通过orderId顺序来生成的，就是只做关联操作，新增的字幕做插入，更新的字幕做修改，在字幕制作结束以后，根据时间轴</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Activiti6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx详解</title>
      <link href="/2020/08/24/nginx%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/24/nginx%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx负载均衡策略"><a href="#nginx负载均衡策略" class="headerlink" title="nginx负载均衡策略"></a>nginx负载均衡策略</h1><ul><li>轮询</li><li>权重</li><li>依据ip分配</li><li>连接数最少</li><li>响应时间短</li><li>url_hash</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring_Boot_知识点详解</title>
      <link href="/2020/08/23/Spring-Boot-%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/23/Spring-Boot-%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h1><h1 id="ioc相关"><a href="#ioc相关" class="headerlink" title="ioc相关"></a>ioc相关</h1><h2 id="FactoryBean和BeanFactory"><a href="#FactoryBean和BeanFactory" class="headerlink" title="FactoryBean和BeanFactory"></a>FactoryBean和BeanFactory</h2><p>FactoryBean是工厂Bean，是Spring提供的实例化比较复杂的对象的一种方式，通过实现FactoryBean<br>接口，重写getObject方法来实现一个工厂Bean，隐藏了实现细节，简化xml的配置。<br>BeanFactory是ioc容器的顶级接口。主要完成Bean的注册，创建，访问等工作。</p><h1 id="aop原理"><a href="#aop原理" class="headerlink" title="aop原理"></a>aop原理</h1><ol><li>在around中可以用,此时可以使用process()来执行被包裹的代码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinpoint)</span> &#123;  </span><br><span class="line">    joinpoint.proceed();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>1 2 3 6 7<br>3<br>3 2 3 6 5</p><ol><li>joinPoint可以获得的参数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">joinpoint.getArgs();<span class="comment">//輸入的參數列表  </span></span><br><span class="line">  </span><br><span class="line">joinpoint.getTarget().getClass().getName();<span class="comment">//類全路徑  </span></span><br><span class="line">  </span><br><span class="line">joinpoint.getSignature().getDeclaringTypeName();<span class="comment">//接口全路徑  </span></span><br><span class="line">          </span><br><span class="line">joinpoint.getSignature().getName();<span class="comment">//調用的方法  </span></span><br></pre></td></tr></table></figure><h1 id="springboot包含哪些设计模式"><a href="#springboot包含哪些设计模式" class="headerlink" title="springboot包含哪些设计模式"></a>springboot包含哪些设计模式</h1><h2 id="简单工厂模式-BeanFactory或者ApplicationContext中getBean"><a href="#简单工厂模式-BeanFactory或者ApplicationContext中getBean" class="headerlink" title="简单工厂模式 BeanFactory或者ApplicationContext中getBean"></a>简单工厂模式 BeanFactory或者ApplicationContext中getBean</h2><blockquote><p>BeanFactory或者ApplicationContext这俩类的区别？<br>ApplicationContext是BeanFactory的子类，所以ApplicationContext包含BeanFactory的全部功能并且还有额外的优化。<br>BeanFactory对Bean是懒加载的，ApplicationContext是预加载的<br>ApplicationContext有对国际化信息支持的类<br>ApplicationContext自动注册BeanPostProcess、BeanFactoryPostProcess，BeanFactory需要手动注册<br>ApplicationContext提供统一的资源加载策略<br>ApplicationContext提供事件传播机制</p></blockquote></li></ol><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>spring 的 ioc容器是单例的，单例的Bean在初始化完成以后会放入到ioc容器中。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>Spring MVC里的HandlerAdapter就是将不同的Controller实现以及调用其内部的方法封装到Adapter中。<br>源代码里不需要通过if else来判断执行哪个Controller，只需要给每个Controller写一个Adapter，然后批量执行Adapter集合就可以了。</p><p>Handler有许多种形式，最后给每个Handler写一个Adapter，合并成一个Adapter集合遍历执行即可。</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>RequestWrapper</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>AOP通过动态代理实现</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>事件驱动模型<br>监听者为观察者，事件为被观察者，监听器注册到事件上，事件有发生就通知监听器</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>dataSource</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h1 id="Spring-Boot事务"><a href="#Spring-Boot事务" class="headerlink" title="Spring Boot事务"></a>Spring Boot事务</h1><h2 id="传播级别"><a href="#传播级别" class="headerlink" title="传播级别"></a>传播级别</h2><p>PROPAGATION_REQUIRED<br>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择</p><p>PROPAGATION_SUPPORTS<br>支持当前事务，如果当前没有事务，就以非事务方式执行。</p><p>PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。</p><p>PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。</p><p>PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>PROPAGATION_NESTED  如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> spring boot </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式概念理解</title>
      <link href="/2020/08/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
      <url>/2020/08/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式概念理解"><a href="#分布式概念理解" class="headerlink" title="分布式概念理解"></a>分布式概念理解</h1><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>分区容错性P 指每个服务都会部署多个节点，保证此服务的一个节点挂掉以后，此服务的其他节点仍然可以响应，这就是分区容错性。</p><p>也是分布式系统必须保证的特性。</p><p>在部署好该服务的多个节点以后就要考虑，这些节点之间数据为了保持一致性要进行数据复制，此过程就会出现数据一致性C，必须要等到数据一致以后再返回给调用者响应。这样就会影响服务的可用性A，因为如果网络问题，数据复制太慢了，或者失败了就会导致响应超时，就失去了系统的可用性A。</p><p>如果不强制数据一致性。允许在数据还没有同步完之前返回响应，这样节点数据就有可能不一致，但是这满足了可用性，失去了一致性。</p><p>结论：一个高可用的分布式系统分区容错性P是一定要满足的，在此基础上，只能满足可用性A或者一致性C。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java容器详解</title>
      <link href="/2020/08/19/java%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/19/java%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="java容器详解"><a href="#java容器详解" class="headerlink" title="java容器详解"></a>java容器详解</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> capacity;               <span class="comment">//table数组长度的默认值是16</span></span><br><span class="line"><span class="type">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;    <span class="comment">// 负载因子默认0.75，可以大于1</span></span><br><span class="line"><span class="type">int</span> modCount;               <span class="comment">//用于记录内部结构发生变化的次数，主要用于迭代判失败</span></span><br><span class="line"><span class="type">int</span> size;                   <span class="comment">//实际存在的键值对数量</span></span><br></pre></td></tr></table></figure><p>threshold为HashMap能容纳的最大数据量的Node键值对的个数，threshold = 数组长度 * loadFactor</p><p>数组table的长度是 2的n次方 便于取模与与扩容时的优化。</p><p>首先是求key值在桶中位置的Hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是将key的高位hash与低位hash杂糅，然后利用2的n次方的长度length的特性，h&amp;(length-1)等价于h&amp;length<br>最后通过h&amp;(length-1)得到key在数组中的索引值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">            <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,<span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;         </span><br><span class="line">        <span class="comment">//经过上面一番查找或者插入找到当前key的节点，然后更新</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的resize()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk1.7的resize</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;         </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">             src[j] = <span class="literal">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                 <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                 <span class="comment">//头插法，会将同一条链的元素倒置</span></span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>jdk1.8的resize方法优化了重写计算hash的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;，&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];<span class="comment">//建立新的Bucket</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中，遍历旧bucket</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块，扩容改成了尾插法，主要是防止多个线程的时候头插法出现环</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 暂存下一个节点</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 计算一下这个e的hash值的在新长度下的最高值是0还是1，然后均分，这里oldCap以16为例就是10000，就是扩容以后的最高位，直接与hash值就能求出来，如果是0，说明还是原hash值计算出来的索引就是j，放到新数组的j，用尾插</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap详解</title>
      <link href="/2020/08/18/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/18/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="ConcurrentHashMap详解"><a href="#ConcurrentHashMap详解" class="headerlink" title="ConcurrentHashMap详解"></a>ConcurrentHashMap详解</h1><h1 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h1><p>数据结构由一个Segment数组构成，每个Segment数组元素是一个HashEntry数组，一个HashEntry节点就是一个链表的kv键值对节点。<br>Segment数组的大小由size来表示。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(size &lt; concurrencyLevel) &#123;</span><br><span class="line">++a;</span><br><span class="line">size &lt;&lt;=<span class="number">1</span>;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><p>size的大小为2的n次方，没有指定concurrencyLevel默认值为16，如果指定的话size最大值能到65536。</p><p>每个HashEntry的数组大小用cap来表示，也是2的n次方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span>  <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span>  <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span>  <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒</p><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><p>ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null</p><h2 id="resize操作"><a href="#resize操作" class="headerlink" title="resize操作"></a>resize操作</h2><p>计算ConcurrentHashMap的元素大小是一个有趣的问题，因为他是并发操作的，就是在你计算size的时候，他还在并发的插入数据，可能会导致你计算出来的size和你实际的size有相差（在你return size的时候，插入了多个数据），要解决这个问题，JDK1.7版本用两种方案</p><ul><li>第一种方案他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的</li><li>第二种方案是如果第一种方案不符合，他就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回</li></ul><h1 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h1><p>摒弃了Segment的概念，直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p><h2 id="ConcurrentHashMap基本变量"><a href="#ConcurrentHashMap基本变量" class="headerlink" title="ConcurrentHashMap基本变量"></a>ConcurrentHashMap基本变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// node数组最大容量：2^30=1073741824  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span>  <span class="number">1</span>  &lt;&lt;  <span class="number">30</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认初始值，必须是2的幂数  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span>  <span class="number">16</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//数组可能最大值，需要与toArray（）相关方法关联  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE -  <span class="number">8</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//并发级别，遗留下来的，为兼容以前的版本  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span>  <span class="number">16</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 负载因子  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">float</span>  <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span>  <span class="number">0</span>    <span class="number">.75f</span>;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表转红黑树阀值,&gt; 8 链表转换为红黑树  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span>  <span class="number">8</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span>  <span class="number">6</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span>  <span class="number">64</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span>  <span class="number">16</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="type">int</span>  <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span>  <span class="number">16</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2^15-1，help resize的最大线程数  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (    <span class="number">1</span>  &lt;&lt; (    <span class="number">32</span>  - RESIZE_STAMP_BITS)) -  <span class="number">1</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 32-16=16，sizeCtl中记录size大小的偏移量  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span>  <span class="number">32</span>  - RESIZE_STAMP_BITS;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// forwarding nodes的hash值 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">MOVED</span>     <span class="operator">=</span> -    <span class="number">1</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 树根节点的hash值  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">TREEBIN</span>   <span class="operator">=</span> -    <span class="number">2</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// ReservationNode的hash值  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">RESERVED</span>  <span class="operator">=</span> -    <span class="number">3</span>    ;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可用处理器数量  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="type">int</span>  <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//存放node的数组  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">transient</span>  <span class="keyword">volatile</span>  Node&lt;K,V&gt;[] table;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *当为负数时：-1 代表正在初始化，-N代表有 N-1 个线程正在 进行扩容  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *当为    0    时：代表当时的table还没有被初始化  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *当为正数时：表示初始化或者下一次进行扩容阈值的大小  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">transient</span>  <span class="keyword">volatile</span>  <span class="type">int</span>  sizeCtl;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node是ConcurrentHashMap存储结构的基本单元，继承于HashMap中的Entry，用于存储数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>       &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>     &#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>   &#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Virtualized support for map.get(); overridden in subclasses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="literal">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node数据结构很简单，从上可知，就是一个链表，但是只允许对数据进行查找，不允许进行修改。</p><h2 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h2><p>TreeNode继承与Node，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">                 TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findTreeNode(h, k, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns the TreeNode (or null if not found) for the given key</span></span><br><span class="line"><span class="comment">         * starting at given root.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">findTreeNode</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>;</span><br><span class="line">                <span class="keyword">do</span>  &#123;</span><br><span class="line">                    <span class="type">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                    TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        p = pl;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        p = pr;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                        <span class="keyword">return</span> p;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">                        p = pr;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">                        p = pl;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                              (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                        p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        p = pl;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h2><p>TreeBin从字面含义中可以理解为存储树形结构的容器，而树形结构就是指TreeNode，所以TreeBin就是封装TreeNode的容器，它提供转换黑红树的一些条件和锁的控制。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>ConcurrentHashMap构造方法中是参数的赋值。</p><h2 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">//1、如果数组还没有初始化，先初始化表initTable</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">//2、如果当前索引位置为null，cas操作更新为Node</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3、f经过上面的判断，会取到i索引位置的Node节点，如果Node的hash表示正在扩容，该线程就帮忙进行扩</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//4、如果找到对应的数组节点，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="comment">//找到了节点</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="comment">//到链尾了，就链尾接一个新的</span></span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果链表遍历到链尾数量大于等于了8个就得转成红黑树</span></span><br><span class="line">                <span class="comment">//但是，注意进到这方法里面还有一个判断就是如果table的长度小于64就执行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述流程主要步骤</p><ol><li>首先是initTable，就是通过自旋改状态SIZECTL为-1，然后new数组出来<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//sc大于0，说明sc是要初始化的表长的大小</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        <span class="comment">//设置扩容阈值大小，这个操作相当于n*0.75</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>如果没有hash冲突就直接CAS插入，首先volatile读最新的数组位置节点是不是空，为空就cas加入新的Node<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>f经过上面的判断，会取到i索引位置的Node节点，如果Node的hash表示我正在扩容，该线程就帮忙进行扩</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                   (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">resizeStamp</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>扩容操作稍后详谈！！</p><ol start="4"><li><p>如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入。</p></li><li><p>如果链表遍历到链尾数量大于等于了8个就得这一条链转成红黑树。</p></li><li><p>如果添加成功就调用addCount()方法统计size，并且检查是否需要扩容。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 putVal 传入的参数是 (1， binCount)，binCount 默认是0，只有 hash 冲突了才会大于 1.且他的大小是链表的长度（如果不是红黑数结构的话）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">        CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">        <span class="comment">//这一块儿if是计数</span></span><br><span class="line">        <span class="comment">//如果计数盒子不为空 或者 CAS使用baseCount来计算，如果有争用计数失败了就进if语句块</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//如果计数盒子是空 或者 计数盒子不为空，但是取一个计数盒子内随机索引的值为空 或者 计数盒子取一个随机索引不为空，但是cas向这个盒子的这个索引位置写+x操作失败了 就进入if语句，执行fullAddCount 并结束。</span></span><br><span class="line">            <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                <span class="comment">//fullAddCount包含了CounterCell初始化，扩容，计数累加的功能</span></span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            s = sumCount();<span class="comment">//统计计数盒子里的所有值也就是baseCount+counterCells里的所有值，即目前map里元素数量有多少，size()</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这一块儿if是扩容操作</span></span><br><span class="line">        <span class="comment">//check大于0说明bitCount是大于等于0的说明，在put的时候bitCount默认就是大于等于0的</span></span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">            <span class="comment">//这里开始进行扩容操作，扩容也支持多个线程同时扩，使用SIZECTL记录参与扩容的线程数量。</span></span><br><span class="line">            <span class="comment">//SIZECTL的高16位 是扩容戳，扩容戳计算和当前数组长度有关，resizeStamp</span></span><br><span class="line">            <span class="comment">//SIZECTL的低16位，记录参与扩容的线程数量，线程数量等于低16位-1</span></span><br><span class="line">            <span class="comment">//当map.size()大于等于sizeCtl(表示要进行扩容的阈值) 且 table数组不为空 且 数组长度小于最大容积 </span></span><br><span class="line">            <span class="comment">//当进入这循环的时候如果开启了扩容，这个sizeCtl就一直是复数，想要退出循环，必须等到扩容结束。</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    static final int resizeStamp(int n) &#123;</span></span><br><span class="line"><span class="comment">                        return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    Integer.numberOfLeadingZeros(n)这个方法返回n的二进制形式下最高位到第一个非0位中间0的数量，这个得到的数的范围一定是0~32</span></span><br><span class="line"><span class="comment">                    然后与 1&lt;&lt;15 相或，1左移15位就是在第16位上面，意思就是第16位一定是1，为了后面将其左移16位变为负数。那为什么随便取一个0~32的数就可以用呢？因为后面记录扩容线程数会先 左移16位，除了保证是一个负数以外，低16位也全部变成了0用来记录扩容线程数，至于高16位是什么数不关心，也没有运算会修改它，当作一个本次扩容期间不会变化的标识即可。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">                <span class="comment">//第一个进来的线程一定不小于0，</span></span><br><span class="line">                <span class="comment">//sc小于0说明正在扩容</span></span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//int RESIZE_STAMP_BITS = 16;</span></span><br><span class="line">                    <span class="comment">//int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;</span></span><br><span class="line">                    <span class="comment">//sc右移16位应该与rs标识符相等才对，总之就是这些满足其一就跳出不再进入扩容</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//sizeCtl现在记录的就是扩容线程数，不过只能看其低16位，sc+1也只影响低16位，高16位是跟扩容前数组长度有关的扩容戳标识符，标识此次扩容，不会变的。CAS操作+1 没什么问题 </span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次进来的线程到这儿，如果sizeCtl没被其他其他线程更改，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="literal">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法从名字上来看是对哈希表得元素计数的。<br><strong>计数操作整体思路:</strong><br>如果我们只使用一个Long类型进行扩容。那势必在扩容的时候我们需要对计数器的++操作需要加锁。如果我们使用CAS避免锁操作，但是在多线程的情况下，也只有一个线程能CAS成功，其他线程会浪费CPU的资源。所以为了提高计数效率，ConcurrentHashMap就采用数组进行计数，将多个线程的++操作散列到数组的不同位置，这样可以有效的缓解线程的竞争，提升技术效率。</p><p>当然，如果我们虽然使用了ConcurrentHashMap，但是不存在多线程竞争计数的情况，次数就没必要使用数组技术，可以直接使用一个Long类型即可。</p><p>所以ConcurrentHashMap的计数就分为两部分，一个是baseCount，在不存在线程竞争的情况下使用。如果有多线程竞争计数，则会创建一个CounterCells数组来计数。最终中的数据 = baseCount + 数组数量总和。</p><p>然后我们分析一下fullAddCount(x, uncontended)是如何初始化counterCells的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">fullAddCount</span><span class="params">(<span class="type">long</span> x, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">//从ThreadLocalRandom中获取随机数</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果发现获得的probe值为0，说明ThreadLocalRandom还没有被初始化，需要先进行初始化。</span></span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        <span class="comment">//初始化后，再重新获取一个随机数</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="comment">//如果counterCells为null，说明counterCells还没初始化，所以需要对counterCells进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果counterCells不为null，就获取counterCells相应位置的counterCell</span></span><br><span class="line">            <span class="comment">//如果定位到的counterCell为null，说明counterCells相应位置的counterCell还是null，需要new一个counterCell</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//执行到这儿，说明定位到的位置CounterCell为null，需要给相应位置new一个CounterCell，并赋值。</span></span><br><span class="line">            <span class="comment">//只有cellsBusy为0的情况下，才允许进行CountCells对应数组位置的CountCell初始化操作，因为此时可能正在扩容</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                <span class="comment">//创建一个CounterCell</span></span><br><span class="line">                    <span class="type">CounterCell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="comment">//进行CountCells对应数组位置的CountCell初始化操作，也不允许扩容操作</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="comment">//给数组指定位置赋值</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">//执行到这儿，说明定位到的counterCell一定不为null</span></span><br><span class="line">            <span class="comment">//通过CAS对count进行累加。</span></span><br><span class="line">            <span class="comment">//如果线程的数量很多，即使散列但是依旧存在多线程竞争的情况，这里依旧会失败。</span></span><br><span class="line">            <span class="comment">//如果依旧失败，则会去尝试扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//这里的判断，就是为了看是否还能扩容</span></span><br><span class="line">            <span class="comment">//如果counterCells != as，说明肯定已经有其他线程已经扩容完毕了，因为扩容会创建新的数组，那就不需要再进行扩容了</span></span><br><span class="line">            <span class="comment">//n &gt;= NCPU，如果当前counterCells 数组的长度大于等于CPU的核数，也不能再继续扩容。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">           <span class="comment">//执行到这儿，说明散列后还存在竞争，并且还能够继续扩容</span></span><br><span class="line">           <span class="comment">//通过CAS设置cellsBusy，保证只能有一个线程扩容，并且扩容期间不允许进行CountCells对应数组位置的CountCell初始化操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                    <span class="comment">//counterCells 的长度扩大为原来的两倍，</span></span><br><span class="line">                    <span class="comment">//将counterCell移到新的数组中，</span></span><br><span class="line">                    <span class="comment">//并用新的counterCells替换旧的counterCells </span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对counterCells进行初始化，因为存在多线程，所以通过CAS设置状态值cellsBusy来保证只有一个线程能够初始化成功</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="built_in">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                <span class="comment">//初始化的过程，就是创建一个长度为2的CounterCell数组</span></span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> <span class="title class_">CounterCell</span>[<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">//因为是第一初始化，直接给数组的位置创建一个CounterCell并赋值即可。</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">CounterCell</span>(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//退出的时候恢复cellsBusy </span></span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>一开始，就先获取一个随机数，用于后面的散列操作。fullAddCount计数因为没有hash进行散列，所以他通过ThreadLocalRandom获取随机数的方式来散列实现多线程计数，对ThreadLocalRandom不太熟悉的，可以看 <a href="https://blog.csdn.net/b_x_p/article/details/105237672">Random和ThreadLocalRandom原理分析</a></p></li><li><p>如果counterCells为空，就会对其初始化，初始化之前通过CAS将cellsBusy设置为1，保证只有一个线程能进行初始化。counterCells的初始化长度为2.</p></li><li><p>如果counterCells不为null，则开始计数。如果拿到的counterCells数组对应位置的counterCell为null，则需要初始化当前位置的counterCell。如果不为null，则直接通过CAS进行计数。</p></li><li><p>当在用数组进行计数还是存在竞争导致CAS失败的情况下，判读当前的counterCells数组长度是否大于等于当前操作系统的CPU核数，如果不大于，则进行扩容，如果已经大于等于了，则只能通过不断的CAS完成最终的计数。</p></li><li><p>addCount结束后，会通过sumCount计算总的count数量，用于后面的扩容判断，sunCount实现如下，就是一个累加的操作。</p></li></ul><h2 id="transfer操作-扩容"><a href="#transfer操作-扩容" class="headerlink" title="transfer操作 扩容"></a>transfer操作 扩容</h2><p>最后来聊一聊transfer扩容操作。</p><p>ConcurrentHashMap支持多线程同时扩容，其实描述为支持多个线程同时迁移节点数据到扩容后的新的tab中更为准确。所以可想而知，为了实现多线程迁移数据，必须划定好迁移范围，每个线程迁移一定范围的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数中：tab是原tab，nextTab是扩容后新的tab</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">//扩容过程由于tab长度变化，导致数据在tab中的位置也会发生变化，所以需要转移数据。</span></span><br><span class="line">    <span class="comment">//转移数据支持多个线程共同转移，所以要划分好每个线程转移那一部分。</span></span><br><span class="line">    <span class="comment">//stride就是用于定义每个线程转移tab的长度。每个线程处理的tab数量</span></span><br><span class="line">    <span class="comment">//这里，如果CPU核数为1，则stride = n， 则只一个线程进行处理。</span></span><br><span class="line">    <span class="comment">//如果CPU核数大于1，则将数组分为 （CPU数 * 8）段。允许（CPU数 * 8）个线程处理。</span></span><br><span class="line">    <span class="comment">//但是，最小的线程处理单位长度为16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">//如果是第一个线程来扩容，则创建一个新的tab，长度为原tab的2倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//这里给transferIndex 赋值为原tab的长度lenth</span></span><br><span class="line">        <span class="comment">//下面就会通过这个transferIndex分配每个线程的处理长度</span></span><br><span class="line">        <span class="comment">//后面分配处理的时候，用bound 和i分别指向范围的左端和右端</span></span><br><span class="line">        <span class="comment">//i = transferIndex - 1; bound = transferIndex - stride; transferIndex - bound</span></span><br><span class="line">        <span class="comment">//当然，这里也只有第一个来扩容的线程才会进入到这里进行赋值</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">   <span class="comment">//这里for循环里面，就是真正的迁移。</span></span><br><span class="line">   <span class="comment">//给每个线程分配处理的范围，范围大小为前面计算的stride 。</span></span><br><span class="line">   <span class="comment">//用bound 和i分别指向范围的左端和右端，用全局变量transferIndex来控制每个线程处理范围的不重复。</span></span><br><span class="line">   <span class="comment">//分配好范围后，通过--i来遍历处理每一个Node，如果当前节点Node处理完成，将其置为fwd</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="comment">//这里的while循环：线程第一次来的时候，用于分配处理范围。分配好之后，通过--i实现遍历处理</span></span><br><span class="line">        <span class="comment">//advance：开始处理当前的tab[i]的时候，advance会置为false</span></span><br><span class="line">        <span class="comment">//         当前的tab[i]处理完成的时候，advance会置为true</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//这里需要关注一下，--i就是用于遍历使用的。</span></span><br><span class="line">            <span class="comment">//如果线程第一次来，还没有分配范围，此时i = bound = 0，所以条件不满足，这里走else</span></span><br><span class="line">            <span class="comment">//非第一次来的话，bound &lt; i，i移动到下一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//如果这个if满足条件，说明，tab已经全部分配完了。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行到这里，说明当前线程第一次进入，还没有分配长度，这里就会就行长度分配</span></span><br><span class="line">            <span class="comment">//首先因为是多个线程同时进入，所以通过CAS修改transferIndex。修改成功，说明当前线程获得了此范围的转移权</span></span><br><span class="line">            <span class="comment">//用bound 和i分别指向范围的左端和右端</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在前面的while中分配处理范围的时候，如果已经分配完了，则 i = -1</span></span><br><span class="line">       <span class="comment">//所以这里，只有分配到的最后一个线程才会执行到这里</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">//finishing为true，说明已经全部转移完成了，则重新为sizeCtl 何 tab赋值。</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每个参与扩容的线程，如果扩容结束，就将参与扩容的线程减一</span></span><br><span class="line">            <span class="comment">//只有当所有的参与扩容的线程全部执行结束，才会将finishing 设置为true</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果当前线程减完自己这个线程数量以后 得到的线程数不等于0，说明还有其他线程在跑，当前线程就直接return即可</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//上面的if失败，说明现在的线程是最后一个线程</span></span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit 最后一个线程，你单独将整个桶扫一遍确保，每一个桶都标上了fwd</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)<span class="comment">//原数组在i这个位置是不可能为空的，这里主要做赋值操作</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//已经有线程在移动节点了，那当前线程分配的区间作废</span></span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这里是转移每个槽位的逻辑，需要加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">//说明此时还是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//第一步是找最后可以复用的一段链，最高位是0还是1判断是高位链还是低位链，lastRun就是最后一段相同链的头节点</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//第二步是判断最后一段链是在高位还是在低位，链过去</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//第三步，遍历链，直到lastRun节点</span></span><br><span class="line">                        <span class="comment">//这里是完全创建了新的节点，而非继续使用原节点</span></span><br><span class="line">                        <span class="comment">//这样做，保证了原tab不变，所以在扩容期间，依旧可以进行get。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="comment">//判断节点是高位还是低位，然后new一个新的，头插</span></span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//将低位链设置到原索引，这个set就是unsafe的put操作</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//将高位链设置到原索引+n处</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//这一条链跑完了，就将原链表i索引的节点设成fwd节点，这个节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//这一块区间分配完了，将advanced置true，即又可以进入while(advanced)循环去领区间任务了</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//说明已经是树结构，树结构不分析。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是transfer方法的解析。</p><blockquote><p>问：什么情况下get/put会被阻塞?<br>get：文中已经分析过，任何情况下都可以进行get操作。因为put的时候属于尾插，不影响get。而扩容转移链表数据的时候会创建新的Node，所以扩容过程中也不影响原链表。</p><p>put：put操作的时候会对tab[ i ]进行synchronized加锁，在对tab[i]进行put的时候，会阻塞tab[ i ]上的其他put操作，但是不影响tab[ j ]的put操作。<br>在扩容过程中迁移的时候，也会对tab[ i ]进行synchronized加锁，所以迁移过程中，也会阻塞当前正在迁移的tab[ i ]的put操作。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongAdder详解</title>
      <link href="/2020/08/18/LongAdder%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/18/LongAdder%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><p>建议参考ConcurrentHashMap addCount与fulladdCount方法源码，类似~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ForkJoinPool详解</title>
      <link href="/2020/08/18/ForkJoinPool%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/18/ForkJoinPool%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章参考博客<a href="https://www.jianshu.com/p/de025df55363">分析jdk-1.8-ForkJoinPool实现原理(上)</a>、<a href="https://www.jianshu.com/p/44b09f52a225">分析jdk-1.8-ForkJoinPool实现原理(下)</a></p></blockquote><h1 id="ForkJoinPool详解"><a href="#ForkJoinPool详解" class="headerlink" title="ForkJoinPool详解"></a>ForkJoinPool详解</h1><blockquote><p>介绍一下forkJoinPool?<br>这个线程池是ExecutorsService的另一个分支，用在多核CPU，而且任务可以拆分为子任务去解决的那种情况。里面会默认创建cpu核数的工作线程，每个工作线程具有自己的阻塞队列，从对尾取自己得任务，如果自己阻塞队列里面没有任务了去其他工作线程的队头去偷任务。</p></blockquote><p>分开又合并，分而治之。</p><p>核心算法是work-stealing算法，翻译过来是工作窃取算法。</p><p>有三个重要角色:</p><ul><li>ForkJoinWorkerThread ，包装Thread，后面简称worker线程</li><li>workQueue ， 双向工作队列</li><li>ForkJoinTask ，worker线程执行对象，实现了Future。两种类型，一种叫submission，另一种就叫task。</li></ul><p>ForkJoinPool使用数组保存了所有WorkQueue（workQueue[]），每个worker都有自己的workQueue，不是所有workQueue都有自己的worker。</p><ul><li>没有worker的WorkQueue：保存的是submission，来自外部提交，在WorkQueue[]的下标是偶数；</li><li>属于worker的WorkQueue：保存的是task，在WorkQueue[]的下标是奇数。</li></ul><p>WorkerQueue是一个双端队列，同时支持作为栈的push、pop操作，也支持作为队列的offer、poll操作，worker线程处理自己的workerQueue与之前的线程池取任务不一样，这里是当作栈来使用的，先进后出的方式处理workerQueue里的任务，除此之外worker线程偷其他worker的workerQueue是当作队列来处理的，也就是当队列里有多个任务的时候，worker去取任务不会与其他worker争用任务。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism,</span></span><br><span class="line"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span><br><span class="line"><span class="params">                     UncaughtExceptionHandler handler,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">                     String workerNamePrefix)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    <span class="built_in">this</span>.ueh = handler;</span><br><span class="line">    <span class="built_in">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="type">long</span> <span class="variable">np</span> <span class="operator">=</span> (<span class="type">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="built_in">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>parallelism</strong>：默认是cpu的核心数，ForkJoinPool的线程数量依据与它，但不表示ThreadPoolExecutor的核心线程数和最大线程数。  </p><p><strong>factory</strong>：ThreadFactory，实现newThread方法即可。</p><p><strong>config</strong>：config保存不变的参数，包括parallelism和mode。</p><p><strong>ctl</strong>：是ForkJoinPool中最重要的控制手段，将下面信息按16bit为一组保存在ctl这个long整型里。</p><ul><li>AC: 活动的worker数量</li><li>TC: 总共的worker数量</li><li>SS: WorkerQueue状态，第1位表示active还是inactive，其余十五位表示版本号，ABA</li><li>ID：保存一个WorkQueue在WorkQueue[]的下标，和其他worker通过字段stackPred组成一个TreiberStack。后文讲的栈顶，指这里下标所在的WorkQueue。</li></ul><p>TreiberStack：这个栈的pull和pop使用了CAS，所以支持并发下的无锁操作。</p><h2 id="ForkJoinPool状态修改"><a href="#ForkJoinPool状态修改" class="headerlink" title="ForkJoinPool状态修改"></a>ForkJoinPool状态修改</h2><p>在介绍里面的方法之前先看看线程池的状态</p><ul><li>STARTED</li><li>STOP</li><li>TERMINATED</li><li>SHUTDOWN<br>以上四种，线程池的标准状态</li><li>RSLOCK</li><li>RSIGNAL<br>runState是线程池的状态，在修改状态之前要获得锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState bits: SHUTDOWN must be negative, others arbitrary powers of two</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">RSLOCK</span>     <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">RSIGNAL</span>    <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">STARTED</span>    <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">STOP</span>       <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">TERMINATED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">SHUTDOWN</span>   <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="任务ForkJoinTask"><a href="#任务ForkJoinTask" class="headerlink" title="任务ForkJoinTask"></a>任务ForkJoinTask</h2><p>ForkJoinPool执行任务的对象是ForkJoinTask，它是一个抽象类，有两个具体实现类RecursiveAction和RecursiveTask。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RecursiveAction</span> <span class="keyword">extends</span> <span class="title class_">ForkJoinTask</span>&lt;Void&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title function_">getRawResult</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setRawResult</span><span class="params">(Void mustBeNull)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">exec</span><span class="params">()</span> &#123;</span><br><span class="line">        compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RecursiveTask</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">ForkJoinTask</span>&lt;V&gt; &#123;</span><br><span class="line">    V result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title function_">compute</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getRawResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setRawResult</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        result = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">exec</span><span class="params">()</span> &#123;</span><br><span class="line">        result = compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoinTask的抽象方法exec由RecursiveAction和RecursiveTask实现，它被定义为final，具体的执行步骤compute延迟到子类实现。很容易看出RecursiveAction和RecursiveTask的区别，前者没有result，getRawResult返回空，它们对应不需要返回结果和需要返回结果两种场景。</p><p>ForkJoinTask里很重要的字段是它的状态status，默认是0，当得出结果时变更为负数，有三种结果：</p><p>NORMAL<br>CANCELLED<br>EXCEPTIONAL<br>除此之外，在得出结果之前，任务状态能够被设置为SIGNAL，表示有线程等待这个任务的结果，执行完成后需要notify通知，具体看后文的join。</p><p>ForkJoinTask在触发执行后，并不支持其他什么特别操作，只能等待任务执行完成。CountedCompleter是ForkJoinTask的子类，它在子任务协作方面扩展了更多操作。</p><h2 id="ForkJoinTask在pool里的提交"><a href="#ForkJoinTask在pool里的提交" class="headerlink" title="ForkJoinTask在pool里的提交"></a>ForkJoinTask在pool里的提交</h2><p>有三种，分别是submit、execute、invoke</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        externalPush(task);</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">        ForkJoinTask&lt;T&gt; job = <span class="keyword">new</span> <span class="title class_">ForkJoinTask</span>.AdaptedCallable&lt;T&gt;(task);</span><br><span class="line">        externalPush(job);</span><br><span class="line">        <span class="keyword">return</span> job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">        ForkJoinTask&lt;T&gt; job = <span class="keyword">new</span> <span class="title class_">ForkJoinTask</span>.AdaptedRunnable&lt;T&gt;(task, result);</span><br><span class="line">        externalPush(job);</span><br><span class="line">        <span class="keyword">return</span> job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ForkJoinTask&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        ForkJoinTask&lt;?&gt; job;</span><br><span class="line">        <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">            job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            job = <span class="keyword">new</span> <span class="title class_">ForkJoinTask</span>.AdaptedRunnableAction(task);</span><br><span class="line">        externalPush(job);</span><br><span class="line">        <span class="keyword">return</span> job;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>submit方法支持Runnable和Callable，通过适配器适配成ForkJoinTask。返回的值当前的FoekJoinTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//execute</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Arranges for (asynchronous) execution of the given task.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        externalPush(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AbstractExecutorService methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        ForkJoinTask&lt;?&gt; job;</span><br><span class="line">        <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">            job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            job = <span class="keyword">new</span> <span class="title class_">ForkJoinTask</span>.RunnableExecuteAction(task);</span><br><span class="line">        externalPush(job);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>execute是没有返回值的提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invoke</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        externalPush(task);</span><br><span class="line">        <span class="keyword">return</span> task.join();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>invoke是返回join结果的提交。</p><p>可以看到所有提交的任务都进externalPush方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> ThreadLocalRandom.getProbe();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runState;</span><br><span class="line">        <span class="comment">//工作队列数组不是空，从数组中选定一个queue也不是空，</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (q = ws[m &amp; r &amp; SQMASK]) != <span class="literal">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            ForkJoinTask&lt;?&gt;[] a; <span class="type">int</span> am, n, s;</span><br><span class="line">            <span class="keyword">if</span> ((a = q.array) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                <span class="comment">//在队尾top处添加task</span></span><br><span class="line">                U.putOrderedObject(a, j, task);</span><br><span class="line">                U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                U.putIntVolatile(q, QLOCK, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//那么现在将task加入到队列中，之后要启用worker线程来执行它，signalWork</span></span><br><span class="line">                <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        externalSubmit(task);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">        <span class="type">int</span> r;                                    <span class="comment">// initialize caller&#x27;s probe</span></span><br><span class="line">        <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            ThreadLocalRandom.localInit();</span><br><span class="line">            r = ThreadLocalRandom.getProbe();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            WorkQueue[] ws; WorkQueue q; <span class="type">int</span> rs, m, k;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">move</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//1</span></span><br><span class="line">            <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                tryTerminate(<span class="literal">false</span>, <span class="literal">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                     ((ws = workQueues) == <span class="literal">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                rs = lockRunState();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                        U.compareAndSwapObject(<span class="built_in">this</span>, STEALCOUNTER, <span class="literal">null</span>,</span><br><span class="line">                                               <span class="keyword">new</span> <span class="title class_">AtomicLong</span>());</span><br><span class="line">                        <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                        n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                        n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                        workQueues = <span class="keyword">new</span> <span class="title class_">WorkQueue</span>[n];</span><br><span class="line">                        ns = STARTED;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> q.top;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">submitted</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                        <span class="keyword">if</span> ((a != <span class="literal">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                            (a = q.growArray()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                            U.putOrderedObject(a, j, task);</span><br><span class="line">                            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                            submitted = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">                        signalWork(ws, q);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                move = <span class="literal">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">                q = <span class="keyword">new</span> <span class="title class_">WorkQueue</span>(<span class="built_in">this</span>, <span class="literal">null</span>);</span><br><span class="line">                q.hint = r;</span><br><span class="line">                q.config = k | SHARED_QUEUE;</span><br><span class="line">                q.scanState = INACTIVE;</span><br><span class="line">                rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">                <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    k &lt; ws.length &amp;&amp; ws[k] == <span class="literal">null</span>)</span><br><span class="line">                    ws[k] = q;                 <span class="comment">// else terminated</span></span><br><span class="line">                unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                move = <span class="literal">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">            <span class="keyword">if</span> (move)</span><br><span class="line">                r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上就是线程池提交任务的流程，对于externalSubmit方法是externalPush方法的完整版。<br>只介绍一下externalSubmit:<br>mark1检查运行状态是否已经进入SHUTDOWN，抛出拒收的异常。对于ForkJoinPool的关闭，见后文“关闭ForkJoinPool”一节。</p><p>第一次执行externalSubmit时，运行状态还没有STARTED，执行mark2进行初始化操作：</p><p>按2的幂设置WorkQueue[]的长度<br>设置原子对象stealCounter<br>运行状态进入STARTED<br>第二次循环中，执行mark4，创建第一个WorkQueue。这个工作队列是没有worker线程对应的，因此它位于workQueue[]的偶数位。</p><blockquote><p>ForkJoinPool中的这些WorkQueue和工作线程ForkJoinWorkerThread并不是一对一的关系，而是随时都有多于ForkJoinWorkerThread数量的WorkQueue元素。而这个ForkJoinPool中的WorkQueue数组中，索引位为非奇数的工作队列用于存储从外部提交到ForkJoinPool中的任务，也就是所谓的submissions queue；索引位为奇数的工作队列用于存储归并计算过程中等待处理的子任务，也就是task queue。</p><p>第三次循环中，执行mark3，会找到刚才创建的WorkQueue，从队列的top端加入任务，调用后面要讲的signalWork激活或者创建worker。</p></blockquote><p>WorkQueue在WorkQueue[]的下标，取的是k = r &amp; m &amp; SQMASK。r是线程的probe，来自随机数ThreadLocalRandom；m是WorkQueue[]的长度减一；SQMASK是固定值0x007e，转为二进制是1111110，末尾是0，在&amp;操作后，得出的k必定是偶数。所以创建的第一个WorkQueue没有对应worker，保存的任务是submission，scanState默认是INACTIVE。</p><p>externalSubmit是长了点，不过逻辑清晰，不难理解。除了初始化，大部分时间其实不需要externalSubmit，使用简单版的externalPush即可。</p><p>以上如果队列里只有一个任务，就调用signalWork</p><h2 id="worker管理"><a href="#worker管理" class="headerlink" title="worker管理"></a>worker管理</h2><p>一个worker线程的生命周期里面有注册、创建、执行、注销</p><h2 id="worker的创建"><a href="#worker的创建" class="headerlink" title="worker的创建"></a>worker的创建</h2><p>首先是worker的创建在signalWork()方法里面，signalWork方法就是当任务到队列中等候以后，判断没有空闲线程就创建新的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> &#123;</span><br><span class="line">    <span class="type">long</span> c; <span class="type">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="type">int</span>)c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="literal">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="literal">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">vs</span> <span class="operator">=</span> (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="literal">null</span>)</span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是进入循环的条件，判断了ctl的正负，我们知道ctl的第一个16bit表示AC，为负时表示活动的worker还未达到预定的Parallelism，需要新增或者激活。mark1通过sp判断现在没有空闲worker，需要执行增加，调用tryAddWorker。</p><p>有空闲worker的情况进入mark2，sp取栈顶WorkQueue的下标，具体解挂worker的过程和tryRelease几乎一样，这里合起来介绍。<br>解卦worker的意思是将worker线程解除挂起。  </p><p>在sp上，将状态从inactive改为active，累加版本号 ，解挂线程，通过stackPred取得前一个WorkQueue的index，设回sp里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryAddWorker</span><span class="params">(<span class="type">long</span> c)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">add</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                       (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">            <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">                <span class="type">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">                <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                    add = U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc);</span><br><span class="line">                unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">                <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                    createWorker();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="type">int</span>)c == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">createWorker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ForkJoinWorkerThreadFactory</span> <span class="variable">fac</span> <span class="operator">=</span> factory;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ForkJoinWorkerThread</span> <span class="variable">wt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="literal">null</span> &amp;&amp; (wt = fac.newThread(<span class="built_in">this</span>)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加worker，需要将AC和TC都加1，成功后调用createWorker。</p><p>createWorker的代码很简单，通过线程工厂创建worker的实例并启动。如果没有异常，直接返回就行；否则，需要逆操作撤销worker的注册。worker什么时候注册了？看ForkJoinWorkerThread的构造函数，里面调用ForkJoinPool.registerWorker，所以就是在创建worker的时候会注册工作线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WorkQueue <span class="title function_">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> &#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    wt.setDaemon(<span class="literal">true</span>);                           <span class="comment">// configure thread</span></span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="literal">null</span>)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    <span class="type">WorkQueue</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkQueue</span>(<span class="built_in">this</span>, wt);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> config &amp; MODE_MASK;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws; <span class="type">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// odd-numbered indices</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="literal">null</span>) &#123;                  <span class="comment">// collision</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">probes</span> <span class="operator">=</span> <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2</span></span><br><span class="line">            w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始，线程就被设置为守护线程。重温知识点，当只剩下守护线程时，JVM就会退出，垃圾回收线程也是一个典型的守护线程。</p><p>mark1，前文讲过有对应worker的WorkQueue只能出现在WorkQueue[]奇数index，代码里取初始index用的是：</p><p>i = ((s &lt;&lt; 1) | 1) &amp; m;<br>seed左移再“或”1，是奇数。m是WorkQueue[]长度减1，也是奇数。两者再“与”，保证取得的i是奇数。若该位置已经存在其他WorkQueue，需要重新计算下一个位置，有需要还要扩容WorkQueue[]。</p><p>mark2设置新创建WorkQueue的scanState为index，表示了两种意思：</p><ul><li>非负表示有对应的worker；</li><li>默认scanState使用SCANNING。</li></ul><p>就此描述清楚worker的创建、WorkQueue的创建和加入WorkQueue[]。</p><h2 id="workter执行"><a href="#workter执行" class="headerlink" title="workter执行"></a>workter执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="literal">null</span>) &#123; <span class="comment">// only run once</span></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                onTermination(exception);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="literal">null</span>)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                pool.deregisterWorker(<span class="built_in">this</span>, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(WorkQueue w)</span> &#123;</span><br><span class="line">    w.growArray();                   <span class="comment">// allocate queue</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> w.hint;               <span class="comment">// initially holds randomization hint</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// avoid 0 for xorShift</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="literal">null</span>)</span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))<span class="comment">//这里如果为false，进入到break出了循环，这个线程就结束了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个run方法是ForkJoinWorkerThread里的run，重写了Thread的run方法，当启动这个线程执行的就是这个run。</p><p>调用了ForkJoinPool的runWorker方法。</p><p>worker执行流程就是三部曲：</p><ul><li>scan：尝试获取一个任务；</li><li>runTask：执行取得的任务；</li><li>awaitWork：没有任务进入等待。</li></ul><p>如果awaitWork返回false，等不到任务，跳出runWorker的循环，回到run中执行finally，最后调用deregisterWorker撤销注册。</p><p>首先是scan</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="type">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ss</span> <span class="operator">=</span> w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">origin</span> <span class="operator">=</span> r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="type">int</span> b, n; <span class="type">long</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (a = q.array) != <span class="literal">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                              U.getObjectVolatile(a, i))) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        q.base == b) &#123;</span><br><span class="line">                        <span class="comment">//2</span></span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="literal">null</span>)) &#123;</span><br><span class="line">                                q.base = b + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate</span></span><br><span class="line">                                 w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="type">int</span>)c], AC_UNIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                    oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> ((SP_MASK &amp; ns) |</span><br><span class="line">                               (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                    w.stackPred = (<span class="type">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc))</span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是获得了当前线程对应的workQueue的scanState状态。<br>在mark2的时候要判断这个状态:</p><ul><li>如果是active，那直接拿着偷到的task返回。</li><li>如果是inactive，调用tryRelease激活这个workQueue</li></ul><p>在mark3处，每次循环会校验新取的index是不是等于第一次取的index。如果相等，说明遍历了一圈还没有steal到任务，当前worker是过剩的，执行如下操作：</p><ul><li>当前WorkQueue的scanState修改为inactive；</li><li>当前WorkQueue挂到栈顶，AC减一。</li></ul><p>偷到一个任务以后就执行它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; <span class="comment">// mark as busy</span></span><br><span class="line">        (currentSteal = task).doExec();</span><br><span class="line">        U.putOrderedObject(<span class="built_in">this</span>, QCURRENTSTEAL, <span class="literal">null</span>); <span class="comment">// release for GC</span></span><br><span class="line">        execLocalTasks();</span><br><span class="line">        <span class="type">ForkJoinWorkerThread</span> <span class="variable">thread</span> <span class="operator">=</span> owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>steal到一个任务后，就可以开始执行：</p><ul><li>将WorkQueue的scanState从SCANNING转为RUNNING；</li><li>记录当前任务是steal来的，保存在currentSteal，并执行doExec；</li><li>执行自己WorkQueue里的任务execLocalTasks（根据mode控制取任务是- LIFO还是FIFO，调用doExec执行，直到WorkQueue为空）；</li><li>累加steal数量；</li><li>能执行的都执行了，scanState转回SCANNING。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; <span class="type">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">setCompletion</span><span class="params">(<span class="type">int</span> completion)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> s;;) &#123;</span><br><span class="line">       <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, STATUS, s, s | completion)) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((s &gt;&gt;&gt; <span class="number">16</span>) != <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; notifyAll(); &#125;</span><br><span class="line">           <span class="keyword">return</span> completion;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doExec方法，里面最终调用ForkJoinTask的核心方法exec，前文介绍过，RecursiveAction和RecursiveTask它们override的exce调用了compute。这样子，源码和使用的方法关联起来了。</p><p>当任务执行完成，调用setCompletion，将任务状态改为NORMAL。注意，使用CAS修改状态时，目标状态使用s|NORMAL。</p><ul><li>原状态是NORMAL，无符号右移为0；</li><li>原状态是SIGNAL，无符号右移不为0。<br>如果任务原状态是SIGNAL，表示有线程由于join而进入了wait，等着任务完成，这时需要额外操作notify触发唤醒。</li></ul><p>没有偷到任务就阻塞这个工作线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">awaitWork</span><span class="params">(WorkQueue w, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="literal">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pred</span> <span class="operator">=</span> w.stackPred, spins = SPINS, ss;;) &#123;</span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">                WorkQueue v; WorkQueue[] ws; <span class="type">int</span> s, j; AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                    (v = ws[j]) != <span class="literal">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">                    (v.parker == <span class="literal">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// recheck after spins</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="type">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ac</span> <span class="operator">=</span> (<span class="type">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);</span><br><span class="line">           <span class="comment">//4</span></span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="literal">false</span>, <span class="literal">false</span>)) ||</span><br><span class="line">                (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//5</span></span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="type">int</span>)c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (<span class="type">short</span>)(c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, prevctl))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">            w.parker = wt;</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">                U.park(<span class="literal">false</span>, parkTime);</span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="literal">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, prevctl))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>awaitWork里核心是一个无限循环，我们重点看里面的等待操作和跳出条件。</p><p>mark1判断WorkQueue的scanState，非负表示WorkQueue要不在RUNNING，要不在SCANNING，直接跳出。mark2里，SPINS初始为0，没有启用自旋等待的控制。</p><p>重点来看mark3，只要没有中断，就会一直循环执行（tryTerminate终止ForkJoinPool时会中断所有worker）。啰嗦一句，要分清楚return和break的不同含义：</p><ul><li>break：回到runWorker继续执行scan、runTask、awaitWork；</li><li>return false：worker需要终止了。<br>mark4检查ForkJoinPool的状态，如果走向中止那边，当前worker也就无必要存在，return false。</li></ul><p>mark5判断worker的存在是否有必要，如果满足下面条件：</p><ul><li>AC为零；</li><li>TC超过2个；</li><li>当前WorkQueue在栈顶。</li></ul><p>说明当前worker过剩，存在也没有任务执行，所以WorkQueue从栈顶释放，return false终止worker。</p><p>其他情况计算一个等待时间，挂起线程，被唤醒有两种可能：</p><ul><li>外部唤醒：如果scanState非负，break出循环，继续执行scan；</li><li>时间到达唤醒：还是老样子，自己过剩，return false终止。</li></ul><p>最后回到ForkJoinTask里的方法中。</p><h2 id="ForkJoinTask-Fork"><a href="#ForkJoinTask-Fork" class="headerlink" title="ForkJoinTask Fork"></a>ForkJoinTask Fork</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fork的代码很简单，如果当前线程是一个worker，直接将任务从top端加入自己的WorkQueue。对于非worker提交的task，执行externalPush，这个前面详细分析过了。</p><h2 id="ForkJoinTask-Join"><a href="#ForkJoinTask-Join" class="headerlink" title="ForkJoinTask Join"></a>ForkJoinTask Join</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>join的目的是得到任务的运行结果，核心调用doJoin，根据任务状态返回结果，或者抛出异常。要注意的是，任务在ForkJoinPool中可能处于各种各样的状况，有可能刚好要被执行啊，有可能正在队列里排队啊，有可能已经被别人偷走啊。</p><p>doJoin的return是花一样的一串判断，先分解出头两个判断：</p><ul><li>status为负表示任务执行已经有结果，直接返回；</li><li>区分当前线程是否worker。</li></ul><p>如果当前线程不是ForkJoinWorkerThread这种情况，调用externalAwaitDone</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">externalAwaitDone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> ((<span class="built_in">this</span> <span class="keyword">instanceof</span> CountedCompleter) ? <span class="comment">// try helping</span></span><br><span class="line">             ForkJoinPool.common.externalHelpComplete(</span><br><span class="line">                 (CountedCompleter&lt;?&gt;)<span class="built_in">this</span>, <span class="number">0</span>) :</span><br><span class="line">             ForkJoinPool.common.tryExternalUnpush(<span class="built_in">this</span>) ? doExec() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span> &amp;&amp; (s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, STATUS, s, s | SIGNAL)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(<span class="number">0L</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                            interrupted = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不讲CountedCompleter的协作，将任务状态设置为SIGNAL，然后是使用wait/notify机制，线程进入等待。既然不是worker，不属于ForkJoinPool的管理范围，你挂起等通知就是了。</p><p>然后是dojoin里的剩下的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) </span><br></pre></td></tr></table></figure><p>首先调用tryUnpush，如果WorkQueue的top端任务正好是等待join的任务，毫无疑问，下个就是执行它，直接doExec；否则调用ForkJoinPool的awaitJoin。</p><h1 id="awaitJoin看晕了，有时间再看"><a href="#awaitJoin看晕了，有时间再看" class="headerlink" title="awaitJoin看晕了，有时间再看"></a>awaitJoin看晕了，有时间再看</h1>]]></content>
      
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> java并发 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动装配详解</title>
      <link href="/2020/08/12/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/12/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="comment">//1.5.x版本@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h1><p>首先，import注解导入了AutoConfigurationImportSelector这个Selector类。<br>在这个类中的selectImport方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">AutoConfigurationMetadata</span> <span class="variable">autoConfigurationMetadata</span> <span class="operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">        AutoConfigurationImportSelector.<span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> <span class="built_in">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击getAutoConfigurationEntry方法进去，一层层点进去到loadSpringFactories方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Enumeration&lt;URL&gt; urls = classLoader != <span class="literal">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line">                <span class="type">LinkedMultiValueMap</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> (URL)urls.nextElement();</span><br><span class="line">                    <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">                    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                    <span class="type">Iterator</span> <span class="variable">var6</span> <span class="operator">=</span> properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                        Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                        <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> ((String)entry.getKey()).trim();</span><br><span class="line">                        String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                        <span class="type">int</span> <span class="variable">var10</span> <span class="operator">=</span> var9.length;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var11</span> <span class="operator">=</span> <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">factoryName</span> <span class="operator">=</span> var9[var11];</span><br><span class="line">                            result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cache.put(classLoader, result);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法会将spring.factories文件里的所有类的全限定名读进来。这里先记住导入的AutoConfigurationImportSelector指向selectImport方法会将文件里类的全限定名导入。</p><p>然后来看看@AutoConfigurationPackage</p><h1 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h1><p>AutoConfigurationPackage注解的作用是将 添加该注解的类所在的package 作为 自动配置package 进行管理。</p><p>看看内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span><span class="comment">//导入了一个Registrar包</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看看AutoConfigurationPackages这个类里的静态内部类Registrar</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Registrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (<span class="keyword">new</span> <span class="title class_">AutoConfigurationPackages</span>.PackageImport(metadata)).getPackageName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> <span class="title class_">AutoConfigurationPackages</span>.PackageImport(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实现了ImportBeanDefinitionRegistrar接口，第一个方法就是用来做Bean注册的，或到了当前注解所修饰的主类的类信息并注册成BeanDefinition</p><h1 id="观察selectorImport方法在哪里调用"><a href="#观察selectorImport方法在哪里调用" class="headerlink" title="观察selectorImport方法在哪里调用"></a>观察selectorImport方法在哪里调用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpringBoot生命周期的这个方法里</span></span><br><span class="line"> invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"> <span class="comment">//会执行下面的方法</span></span><br><span class="line"> PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors</span><br><span class="line"> <span class="comment">//方法里面会接着执行</span></span><br><span class="line"> BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry</span><br><span class="line"> <span class="comment">//关注BeanDefinitionRegistryPostProcessor接口的实现类</span></span><br><span class="line"> ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry registry)里</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">        <span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">        <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"> </span><br><span class="line">  processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续点进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        parser.validate();</span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(parser.getConfigurationClasses());</span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>(Arrays.asList(candidateNames));</span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var12</span> <span class="operator">=</span> alreadyParsed.iterator();</span><br></pre></td></tr></table></figure><p>可以看到parse方法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis知识点详解</title>
      <link href="/2020/08/11/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/11/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis知识点详解"><a href="#Redis知识点详解" class="headerlink" title="Redis知识点详解"></a>Redis知识点详解</h1><p>Redis是非关系型的内存键值对数据库，速度很快，可以存储键与五种类型的值之间的对应关系。</p><p>键的类型只支持字符串，值得类型包括: 字符串String、列表List、集合Set、散列表HashMap、有序集合ZSet</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数、浮点数</td><td>对整个字符串或者字符串的一部分进行操作；对整数或浮点数执行自增减操作</td></tr><tr><td>LIST</td><td>列表</td><td>从两段压入、弹出元素</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对；检查键是否存在</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素；根据分值范围或者成员来获取元素；计算一个键值分数的排名</td></tr></tbody></table><h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">//删除 item2</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure><h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;sub-key2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br></pre></td></tr></table></figure><h3 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//向zset-key这个键里面添加分值为728的member1值</span><br><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line">//打印从0开始的所有值</span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line">//按分数打印从0到800的所有值</span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">//删除member1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure><h2 id="Redis数据结构详解"><a href="#Redis数据结构详解" class="headerlink" title="Redis数据结构详解"></a>Redis数据结构详解</h2><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>可以对String类型进行自增自减运算，从而实现计数器功能。</p><p>Redis内存性数据库的读写效率很高，很适合存储频繁读写的计数量。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>将热点数据放到内存中，设置内存最大使用量，以及淘汰策略保证缓存的命中率。</p><h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><p>DNS系统就很适合使用Redis进行存储。也是利用的Redis查找效率高的特性。</p><p>查找表里的数据不能失效，缓存可以失效，因为缓存不作为可靠的数据来源。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul><li>基于List双向列表的 LPUSH+BRPOP 的实现写入和阻塞读取消息。  <ul><li>需要解决空闲连接的问题，如果线程一直阻塞在那儿，没有新的数据到来，服务端一般会主动断开连接，这时候blpop/brpop就会报错，因此要注意捕获异常并重试。</li></ul></li></ul><h3 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h3><p>可以使用Redis来统一存储服务器集群的会话信息。</p><p>当应用服务器不再存储会话状态，用户就可以请求任意服务器。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>在分布式场景下，无法使用单机环境的锁来对多个节点进程进行同步。<br>可以使用Redis自带的SETNX指令来实现分布式锁，除此以外还可以使用官方提供的RedLock分布式锁实现。</p><h3 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h3><p>Set可以实现并集、交集等操作，从而实现共同好友等功能<br>ZSet可以实现有序性操作，比如排行榜</p><h2 id="Redis与Memcached"><a href="#Redis与Memcached" class="headerlink" title="Redis与Memcached"></a>Redis与Memcached</h2><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><p>Memcached仅支持字符串类型，Redis支持五种不同的数据类型。</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Redis支持两种持久化策略:RDB快照和AOF日志，Memcached不支持。</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>Memcached不支持，需要在客户端使用一致性哈希来实现分布式存储，每次存之前都要计算位于哪个节点。<br>Redis Cluster实现了分布式的支持。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>Redis数据不是一直存储在内存中。可以将很久没用的value交换到磁盘，而Memcached的数据一直会在内存中。</p><h2 id="Redis数据淘汰策略"><a href="#Redis数据淘汰策略" class="headerlink" title="Redis数据淘汰策略"></a>Redis数据淘汰策略</h2><p>可以设置内存最大使用量，如果超过就会实现淘汰策略。<br>Redis有6种淘汰策略:<br>|策略|描述|<br>|-|-|<br>|volatile-lru|从设置了过期时间的的数据集中挑选最近最少使用的数据淘汰|<br>|volatile-ttl|从已设置过期时间的数据集中挑选将要过期的数据淘汰|<br>|volatile-random|从已设置过期时间的数据集中挑选任意数据淘汰|<br>|allkeys-lru|从所有数据集中选择最近最少使用的数据淘汰|<br>|allkeys-random|从所有数据集中任意选择数据淘汰|<br>|noeviction|禁止淘汰数据|</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。<br>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis是内存型数据库，为了保证断电后数据不丢失，需要将内存中的数据持久化到硬盘上。</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>即 将某个时间点的快照数据创建为rdb文件（二进制文件）并报存到磁盘里。然后将快照复制到其他服务器里，创建具有相同数据的副本。</p><ul><li>save指令触发RDB，是阻塞的方式，如果文件特别大会导致系统很长时间无响应，如果存在老RDB文件，直接替换掉，O(N)</li><li>bgsave指令触发RDB，会fork一个子线程出来阻塞住完成rdb文件创建保存。不会阻塞客户端命令。</li><li>满足配置文件的任一条件，比如多少秒内修改了多少次，自动触发RDB，bgsave。</li></ul><p>如果系统发生故障，将会丢失最后一次快照以后的数据。</p><h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p>Redis会将将写入修改命令添加到AOF文件的末尾保存。</p><p>使用AOF文件需要设置同步选项，用来确保AOF文件内容即新加入的写命令同步到磁盘里的时机。这是因为对文件写入并不会马上将内存同步到磁盘，而是先放到缓冲区，然后由操作系统决定什么时候同步到磁盘。</p><p>这里Redis提供了触发操作系统同步的选项如下：<br>|选项|同步频俩|<br>|-|-|<br>|always|每个写命令都触发一次同步|<br>|everySec|每秒触发一次同步|<br>|no|让操作系统自己决定什么时候同步比较好|</p><ul><li>always 会严重降低cpu的性能</li><li>everySec 每秒一次比较合适，而且最多丢一秒数据，对性能也没影响</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。  </li></ul><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>Redis还提供了对越来越大的AOF文件的重写机制，去除AOF文件中冗余的命令。</p><ul><li>减少硬盘占用量</li><li>加快恢复的速度</li></ul><p>AOF通过bgrewriteaof指令触发重写，或者通过配置文件设置自动触发时机。</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis中事务不支持原子性、持久性，不支持回滚。</p><p>Redis通过multi、exec命令通过一条连接连续执行多个命令来实现事务。</p><h2 id="Redis事件"><a href="#Redis事件" class="headerlink" title="Redis事件"></a>Redis事件</h2><h2 id="Redis复制"><a href="#Redis复制" class="headerlink" title="Redis复制"></a>Redis复制</h2><p>通过slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。一个服务器只能有一个主服务器，并且不支持主主复制。</p><h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ol><li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令，快照文件发完以后，开始向从服务器发送存储在缓冲区的写命令。</li><li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，完成以后开始接收主服务器发来的写命令。</li><li>之后主服务器每执行一条写命令，就向从服务器发送相同的写命令。</li></ol><h3 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h3><p>如果主服务器负载不断地上升，无法更新所有地从服务器，这时候可以在原来地一对多关系里加一层中间层节点，来分担主服务器地复制工作，中间层服务器是上层服务器地从服务器，是下层服务器的主服务器。</p><p>例：<br>一个主服务器0有对应9个从服务器（编号1~9），现在负载太高，在中间加三个服务器（A、B、C），现在主服务器0的从节点变成了三个，而A服务器的从节点为（1、2、3），B服务器的从节点为（4、5、6），C服务器的从节点为（7、8、9），可以看到每个服务器的负载都为3个，缓解主服务器的超载的情况。</p><h2 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h2><p>上面就是Redis的主从结构，主要是备份关系，数据一致，所以从服务器比较清闲，可以让它提供读服务，主服务器提供写服务，达到读写分离的目的。</p><p>主从结构如果主服务器挂掉了，这时候就要使用哨兵来监听集群中的其他节点，在主服务器下线状态时，自动从从服务器中选举出新的主服务器。</p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><blockquote><p><a href="https://www.jianshu.com/p/d6d2325a5ec7">redis的哨兵模式和集群模式</a></p></blockquote><h3 id="如何保证redis集群高可用和高并发？redis主从复制原理介绍一下？redis的哨兵模式介绍一下？"><a href="#如何保证redis集群高可用和高并发？redis主从复制原理介绍一下？redis的哨兵模式介绍一下？" class="headerlink" title="如何保证redis集群高可用和高并发？redis主从复制原理介绍一下？redis的哨兵模式介绍一下？"></a>如何保证redis集群高可用和高并发？redis主从复制原理介绍一下？redis的哨兵模式介绍一下？</h3><p>redis高可用自然要使用多台机器来保证自己挂掉以后服务不会挂掉。<br>首先是redis的主从架构。 一主多从，主负责写，并将数据复制到其他从节点，从节点负责读。所有的读请求全部走从节点。</p><p><strong>主从复制核心原理</strong>：<br>当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node，如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的新来的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。在保持连接的后续过程中，master node会持续将写命令异步复制给slave node。</p><p><strong>增量复制</strong>：<br>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。<br>master 直接从自己的 repl-backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。<br>master 就是根据 slave 发送的 psync 中的 offset（各个从节点自己维护自己的偏移量） 来从 backlog 中获取数据的。</p><p><strong>那么如何才能做到Redis的高可用呢？</strong><br>就必须保证当master node挂掉以后，能进行故障转移或者主备切换。即将某个slave node 自动切换为 master node。可以通过redis哨兵来实现高可用。</p><h4 id="redis哨兵"><a href="#redis哨兵" class="headerlink" title="redis哨兵"></a><strong>redis哨兵</strong></h4><p>可以做： </p><ul><li>集群监控，负责监控master和slave是否正常工作。</li><li>消息通知，如果集群中有发生故障要进行通知。</li><li>故障转移，将某slave转成master。</li><li>配置中心，如果故障发生了转移要通知client更新master地址。</li></ul><p>当master挂了以后，需要一半以上的哨兵同意才行，涉及分布式选举的问题。<br>哨兵本身也必须是集群部署的，不然哨兵挂了，谁来监控哨兵。  </p><ul><li>哨兵集群必须至少三个实例，保证自己的健壮性。两台哨兵的话要求一半而是两台都能投票，但是如果挂了一台，就没办法投票了。</li></ul><p><strong>主备切换有数据丢失：</strong>  </p><ul><li>异步复制数据导致的数据丢失<br>有可能宕机的master上还有部分数据没有同步到slave，这部分数据就丢了</li><li>脑裂导致数据丢失<br>可能旧master只是暂时脱离网络，但是哨兵认为master宕机了，重新选举了一个slave作为新master，这时候旧的master又恢复了，集群中就有两个master。这时候旧master恢复不久，可能client端还没修改为新master，继续向旧master写数据，但是旧master不久就被作为slave节点，挂到了新master上，数据被清空。新的master也缺少了旧master刚刚恢复阶段被写入的数据。这部分数据就没了。</li></ul><p><strong>主备切换数据丢失解决方案：</strong><br>配置哨兵集群</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>保证 至少有1个slave，数据复制和同步的延迟不能超过10s。那么上面俩问题数据丢失最多维持在10s内。</p><h4 id="sdown-和-odown-转换机制"><a href="#sdown-和-odown-转换机制" class="headerlink" title="sdown 和 odown 转换机制"></a>sdown 和 odown 转换机制</h4><ul><li>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</li><li>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li></ul><h4 id="哨兵集群的自动发现机制"><a href="#哨兵集群的自动发现机制" class="headerlink" title="哨兵集群的自动发现机制"></a>哨兵集群的自动发现机制</h4><p>哨兵互相之间的发现，是通过 Redis 的 pub/sub 系统实现的，每个哨兵都会往 <strong>sentinel</strong>:hello 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 <strong>sentinel</strong>:hello channel 里发送一个消息，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。</p><p>每个哨兵也会去监听自己监控的每个 master+slaves 对应的 <strong>sentinel</strong>:hello channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。</p><p>每个哨兵还会跟其他哨兵交换对 master 的监控配置，互相进行监控配置的同步。</p><h4 id="slave-gt-master-选举算法"><a href="#slave-gt-master-选举算法" class="headerlink" title="slave-&gt;master 选举算法"></a>slave-&gt;master 选举算法</h4><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><p>接下来会对 slave 进行排序：</p><ul><li>首先排除断开时间超过了 down-after-milliseconds 的 10 倍的slave</li><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li></ul><h3 id="Redis-集群模式的工作原理能说一下么？在集群模式下，Redis-的-key-是如何寻址的？分布式寻址都有哪些算法？了解一致性-hash-算法吗？"><a href="#Redis-集群模式的工作原理能说一下么？在集群模式下，Redis-的-key-是如何寻址的？分布式寻址都有哪些算法？了解一致性-hash-算法吗？" class="headerlink" title="Redis 集群模式的工作原理能说一下么？在集群模式下，Redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？"></a>Redis 集群模式的工作原理能说一下么？在集群模式下，Redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？</h3><h4 id="Redis-cluster-介绍"><a href="#Redis-cluster-介绍" class="headerlink" title="Redis cluster 介绍"></a>Redis cluster 介绍</h4><ul><li>自动将数据进行分片，每个 master 上放一部分数据</li><li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li></ul><p>Redis cluster 节点间采用 gossip 协议进行通信。</p><h4 id="分布式寻址算法"><a href="#分布式寻址算法" class="headerlink" title="分布式寻址算法"></a>分布式寻址算法</h4><ul><li>一致性hash算法<br>指的是将hash空间定义成1~2的32次方-1的这么一个圆环，然后将服务器节点的ip或者host通过hash以后，分布在圆环的某一个索引值上。然后对key节点计算hash并计算在圆环上的索引值，从这个索引值出发逆时针寻找到第一个服务器节点作为自己存储的节点。</li></ul><p>这时候要新增服务器节点的话，也只会影响新服务器插入位置的后一个服务器节点的数据。</p><p>如果服务器节点很少，只有俩容易造成数据分布不均，这时候使用虚拟节点，对每一个服务器节点求多个hash索引值，设置多个虚拟节点，比如两台服务器A、B就可以均分圆环，一半的虚拟节点属于A，一半的虚拟节点属于B，如果key值命中了A1就A去处理，命中了B1由B节点去处理。</p><ul><li>Redis cluster 的 hash slot 算法</li></ul><h4 id="Redis-cluster-的高可用与主备切换原理"><a href="#Redis-cluster-的高可用与主备切换原理" class="headerlink" title="Redis cluster 的高可用与主备切换原理"></a>Redis cluster 的高可用与主备切换原理</h4><p>Redis cluster 的高可用的原理，几乎跟哨兵是类似的。</p><ol><li>判断节点宕机<br>如果一个节点认为另外一个节点宕机，那么就是 pfail ，主观宕机。如果多个节点都认为另外一个节点宕机了，那么就是 fail ，客观宕机，跟哨兵的原理几乎一样，sdown，odown。</li></ol><p>在 cluster-node-timeout 内，某个节点一直没有返回 pong ，那么就被认为 pfail 。</p><p>如果一个节点认为某个节点 pfail 了，那么会在 gossip ping 消息中， ping 给其他节点，如果超过半数的节点都认为 pfail 了，那么就会变成 fail 。</p><ol start="2"><li><p>从节点过滤<br>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。<br>检查每个 slave node 与 master node 断开连接的时间，如果超过了 cluster-node-timeout * cluster-slave-validity-factor ，那么就没有资格切换成 master 。</p></li><li><p>从节点选举<br>每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p></li></ol><p>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node （N/2 + 1） 都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。</p><p>从节点执行主备切换，从节点切换为主节点。</p><ol start="4"><li>与哨兵比较<br>整个流程跟哨兵相比，非常类似，所以说，Redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能。</li></ol><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="谈一谈redis的持久化机制"><a href="#谈一谈redis的持久化机制" class="headerlink" title="谈一谈redis的持久化机制"></a>谈一谈redis的持久化机制</h3><p>Redis的持久化机制通过rdb文件与aof日志来实现持久化。<br>rdb文件是redis将某一时刻在内存中的数据保存到这个.rdb二进制文件中生成一个数据快照。可以通过配置文件添加save的触发条件，就是多少秒内修改了多少次触发。<br>aof文件是redis会将每个写指令追加到aof文件的末尾，然后可以通过配置触发多久将aof文件与磁盘进行一次同步。<br>redis重启的时候会将aof里的写指令重新执行一遍。  </p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>就是大量的缓存在同一时间过期，大量的请求直接去访问数据库。会对cpu和数据库产生巨大的压力。<br><strong>解决方案：</strong>  </p><ul><li>redis高可用</li><li>限流降级<br>信号量、<br>线程池+有界阻塞队列+第一种拒绝策略、<br>滑动窗口（用一个窗口在数组上滑动，窗口6格，每格10s，用户在哪个计数就在哪个格子+1，当窗口总和大于100就触发了限流，也就是每10s丢掉最前面格子的访问次数，而最后补上了一个空格子）、<br>令牌桶（就是按照固定速率向桶里添加令牌，超出上限就丢弃令牌，每个请求来要取一个令牌才能通过，获取不到要么等待，要么丢弃请求）、<br>漏桶（将每个到来的请求入队等待，每个处理器固定速率取出请求处理）</li><li>数据预热<br>将可能过期的数据重新添加一遍，设置不同的过期时间，让缓存均匀失效。</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>就是指频繁请求一个数据库没有的数据，那么缓存中自然也不会存，那么每次访问都会去请求数据库。</p><p><strong>解决方案：</strong>  </p><ul><li>布隆过滤器</li><li>数据查询为空也向redis存入空值，超时时间5min</li></ul><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>错误率假设 Hash 函数以等概率条件选择并设置 Bit Array 中的某一位，假定由每个 Hash 计算出需要设置的位（bit） 的位置是相互独立, m 是该位数组的大小，k 是 Hash 函数的个数。<br>位数组中某一特定的位在进行元素插入时的 Hash 操作中没有被置位的概率是：<br>$1-\frac{1}{m}$   </p><p>一个元素在所有 k 次 Hash 操作后该位都没有被置 “1” 的概率是：<br>$(1-\frac{1}{m})$<sup>k</sup>  </p><p>如果我们插入了 n 个元素，那么某一位仍然为 “0” 的概率是：<br>$(1-\frac{1}{m})$<sup>kn</sup> </p><p>该位为 “1”的概率是：<br>$1-(1-\frac{1}{m})$<sup>kn</sup> </p><p>检测某一元素是否在该集合中。标明某个元素是否在集合中所需的 k 个位置都按照如上的方法设置为 “1”，如果这k个位置都恰好为1，那么我们就认为这个数可能存在于集合中，那么就被误判了，这个概率就是错误率，但是该方法可能会使算法错误的认为某一原本不在集合中的元素却被检测为在该集合中（False Positives），该概率由以下公式确定：<br>$(1-(1-\frac{1}{m})^{kn}))^k$ 约等于   </p><p>$(1-e^{-\frac{nk}{m}}))^k$ </p><p>如何使得错误率最小，对于给定的m和n，当  的时候取值最小。</p><h3 id="Memcache与Redis的区别都有哪些？"><a href="#Memcache与Redis的区别都有哪些？" class="headerlink" title="Memcache与Redis的区别都有哪些？"></a>Memcache与Redis的区别都有哪些？</h3><ol><li>memcached所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型</li><li>Redis的速度比memcached快很多</li><li>redis可持久化数据</li><li>支持主从备份。</li><li>redis的value范围最大值为512M，memcached为1M</li></ol><h3 id="为什么redis快"><a href="#为什么redis快" class="headerlink" title="为什么redis快"></a>为什么redis快</h3><ul><li>纯内存操作</li><li>单线程操作，不需要上下文切换</li><li>采用了非阻塞的多路复用io</li></ul><h3 id="redis的过期策略及内存淘汰机制"><a href="#redis的过期策略及内存淘汰机制" class="headerlink" title="redis的过期策略及内存淘汰机制"></a>redis的过期策略及内存淘汰机制</h3><p>redis采用的是定期删除+惰性删除策略。<br>在redis.conf中有一行配置<br>maxmemory-policy volatile-lru</p><h3 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul><li>redis ，使用key作为锁，使用value判断哪个线程获得了锁，value = host + 线程名 + 时间戳。当加锁结束以后，只会有一个线程成功，哪个线程知道自己成功了呢，就再查一遍，看看这个key的value是否跟自己的value相等，相等的加锁成功。</li><li>Mysql<ul><li>悲观锁 ， insert 一条唯一的name作为锁 走索引，数据库保证只有一个线程可以成功，失败的抛异常无影响。成功的就认为加锁成功了继续向后执行，执行完成，delete form table where name = ‘xxx’即可;</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库概念理解</title>
      <link href="/2020/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
      <url>/2020/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库概念知识点"><a href="#数据库概念知识点" class="headerlink" title="数据库概念知识点"></a>数据库概念知识点</h1><blockquote><p>如何设计一个数据库？来，解释一下<br>首先思考一个数据库的文件存在哪儿，文件系统的存储管理。<br>然后文件存完以后要能方便地查询，使用sql语言，因此要支持sql地解析。<br>为了让sql查找快一点，要支持索引。<br>为了让相同的查询能减少性能损害，要支持缓存。<br>保证了速度以后还要保证数据安全，要支持锁。<br>为了保证所做的操作、sql不丢失，要支持日志。<br>为了防止数据被任何登入系统的人修改，要支持权限划分。<br>当数据库宕机以后要保证数据可以及时恢复，要做容灾管理。</p></blockquote><h2 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h2><p>事务是满足ACID特性的一组操作。</p><ul><li>A Atomic原子性 一系列操作要么全部完成要么，要么全部不做</li><li>C Consistency一致性 就是指所有事务（有许多事务）同一时刻对同一数据的读取结果是相同的、一致的</li><li>I Isolation隔离性 指事务如果还没有提交，对其他事务不可见</li><li>D Durability持久性 一旦事务提交数据就会永久保存到数据库中，不因为系统停止或者崩溃而导致数据丢失，执行了一半的事务数据也可以用【重做日志】进行恢复</li></ul><blockquote><p>【回滚日志undo Log】记录的是数据的逻辑修改，【重做日志 redo Log】记录的是数据页的物理修改，【二进制日志binlog】记录的是sql语句或者修改的数据行。  </p></blockquote><blockquote><p> <strong>redo log</strong> 是InnoDB引擎层的日志（层次），记录的是事务修改以后的物理页page的数据内容（存储内容），在事务执行过程中 就会不断写入redo log。作用就是确保事务的持久性，因为redo log有一个redo log buffer 默认8M，redo log事先写到这块内存，然后有三种策略保证redo log buffer的数据保存磁盘:   </p><ol><li>Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。</li><li>每个事务提交时会将重做日志刷新到重做日志文件。</li><li>当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件</li></ol></blockquote><blockquote><p> <strong>bin log</strong> 是mysql层面的二进制日志，记录了所有引擎的日志（层次）。文件记录的格式设为STATEMENT（记录sql）还是ROW（记录每个修改的数据行的修改细节），又或者是MIXED，其记录的都是关于一个事务的具体操作内容，即该日志是逻辑日志（存储内容），bin log在事务提交的时候才会一次性的写入。作用是用于主从复制，数据恢复，增量备份。  </p></blockquote><blockquote><p><strong>undo log</strong> 是InnoDB引擎层的日志（层次），记录的是每个数据行的每个事务提交的多个版本的记录，通过回滚指针连在一起，是逻辑记录（存储内容）。在事务执行过程中 就会不断写入undo log。作用是用于事务回滚与MVCC快照读。    </p></blockquote><p>事务的一致性是结果。</p><p>在单事务情况下无并发，只要满足原子性，就能达成数据一致性。</p><p>在多事务并发情况下，要满足原子性与隔离性才能达成数据一致性。</p><h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>为什么会有并发问题呢？因为破坏了事务的隔离性，为了使多事务并发执行时，在一定程度上满足隔离性。</p><ul><li>用户可以自己加锁来满足隔离性。</li><li>也可以直接使用数据库提供的默认加锁方案，即四种隔离级别。</li></ul><h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><p>Mysql中有两种粒度，一种是行级锁、一种是表级锁<br>锁粒度越低，则系统并发程度越高 且 系统开销越大</p><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li>互斥锁 写锁 X</li><li>共享锁 读锁 S</li></ul><table><thead><tr><th></th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>\</td><td>\</td></tr><tr><td>S</td><td>\</td><td>共享</td></tr></tbody></table><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><blockquote><p>为了解决一个问题，就是在给一个表加X锁之前要检查这个表里的每一行有没有加S锁或者X锁，然后才能决定能不能加X锁，很耗时。</p></blockquote><p>意向锁 IX与IS均为表级锁<br>如果事务想要给表的某一数据行就S锁或X锁，可以先给表加对应的意向锁。</p><blockquote><p>引入意向锁以后，一个事务给一个表加X锁之前只需要判断这个表有没有被其他事务加S/IS/X/IX锁，如果加了，这个事务就加锁失败了。</p></blockquote><table><thead><tr><th></th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>\</td><td>\</td><td>\</td><td>\</td></tr><tr><td>IX</td><td>\</td><td>O</td><td>\</td><td>O</td></tr><tr><td>S</td><td>\</td><td>\</td><td>O</td><td>O</td></tr><tr><td>IS</td><td>\</td><td>O</td><td>O</td><td>O</td></tr></tbody></table><p><strong>注意</strong>:上面的兼容关系只针对表级锁，表级的IX或IS锁与行级的读写锁是兼容的噢。</p><p>即A事务与B事务同时读取表T，A读取行R1，B读取行R2，那么A与B可以同时对表T加意向写锁，然后A对R1加行级写锁，B对R2加行级写锁，两个事务的加锁都能成功。</p><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><h4 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h4><p>事务T要修改一个数据A必须加X锁，直到T结束释放。</p><blockquote><p>加X锁可以避免修改丢失，如果是直接写原数据无所谓，但是如果是读写操作，就要避免数据丢失。</p></blockquote><h4 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h4><p>一级的基础上+读取数据A必须加S锁，读取完释放。</p><blockquote><p>加了读锁能避免脏读，即之前不加锁的话，写之前我读了一下，等</p></blockquote><h4 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h4><p>二级的基础上+读取数据A必须加S锁，直到T结束了释放</p><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p>对所有事务的加锁与解锁操作，分为两个阶段进行，一个阶段完全执行所有事务的加各种锁的操作，加锁操作结束以后进入另一个阶段，即事务可以对其持有的锁开始释放。</p><p>这种方式的并发控制，能够使并发执行的结果与串行执行的事务结果相同。不会出现并发一致性的问题。</p><blockquote><p>lock-x(A)…lock-s(B)…lock-s(C)…unlock(A)…unlock(C)…unlock(B)</p></blockquote><h3 id="隐式锁定与显示锁定"><a href="#隐式锁定与显示锁定" class="headerlink" title="隐式锁定与显示锁定"></a>隐式锁定与显示锁定</h3><p>Mysql的InnoDB存储引擎采用的是两段锁协议，而且根据隔离级别的需要自动加锁，并且所有锁在使用完以后同一时刻被释放，称为隐式加锁。</p><p>在sql语句中指定进行显示加锁:</p><blockquote><p>SELECT … LOCK In SHARE MODE;<br>SELECT … FOR UPDATE;</p></blockquote><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><blockquote><p>具体的加锁实现与InnoDB有关</p></blockquote><ul><li>未提交读 READ UNCOMMITTED  <ul><li>加锁程度最低，</li><li>A事务修改了值还没有提交，B事务就能直接读到这个值，会造成脏读，因为有可能A回滚了，你B读到的就是脏数据了。</li></ul></li><li>读已提交 READ COMMITTED <ul><li>加锁程度次低，</li><li>A事务修改的值只有提交以后，B事务才能读到，会有不可重复读的问题，因为两次读取之间会被其他事务修改。</li></ul></li><li>可重复读 REPEATABLE READ<ul><li>保证一个事务中 多次读取的同一数据的结果是一致的，会有幻读的问题，对于Select操作无法判断数据条数是否变化。</li></ul></li><li>可串行化 SERIALIZABLE<ul><li>事务串行执行，不会有隔离性的问题。</li></ul></li></ul><blockquote><p>幻读的问题？  </p><p>幻读：是指在同一个事务中，前后两次查询相同范围时，得到的结果不一致，后一次查询到新插入的行。 </p><p>在InnoDB中，RR隔离级别下，普通的读是快照读，快照是事务开始前的最后一次Commit，所以快照读在本次事务期间永远不会有变化，所以幻读仅仅发生在当前读情况下。 </p><p>在InnoDB的RR隔离级别下，还有一种锁就是间隔锁，能锁住除当前索引记录外前后间隔，而且只对插入操作互斥，不同的间隔锁兼容。</p></blockquote><h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h2><p>MVCC就是Mysql的InnoDB存储引擎实现隔离级别的一种方式。<br><strong>未提交读</strong> 读取最新的数据行，没有使用MVCC。<br><strong>已提交读</strong><br><strong>可重复读</strong> 这两种方式使用MVCC来实现。<br><strong>可串行化</strong> 要通过加读写锁实现，单纯使用MVCC无法实现</p><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>MVCC利用的是多版本的思想，没有进行加锁操作。写操作更新数据最新版本的快照，读操作读的是旧版本快照，因为没有提交的快照读不到，没有互斥关系。</p><p>MVCC中事务的修改操作(Delete、Insert、Update)这些操作会给数据行新增一个版本快照。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>MVCC里面有两个版本号:</p><ul><li>一个是系统版本号，是递增的数字，每开始一个新的事务就将序号分配给事务，然后自己自动递增一下，用来保证每个事务都是唯一的序号。</li><li>另一个是事务版本号，新开一个事务时，分配的系统版本号。</li></ul><h3 id="MVCC的Undo日志"><a href="#MVCC的Undo日志" class="headerlink" title="MVCC的Undo日志"></a>MVCC的Undo日志</h3><p>MVCC的数据的快照存储在Undo日志中，该日志通过回滚指针ROLL_PTR把一个数据行的所有快照连起来。</p><p>如果进行了下面这样的操作:</p><blockquote><p>INSERT INTO t(id, x) VALUES(1, “a”);<br>UPDATE t SET x=”b” WHERE id=1;<br>UPDATE t SET x=”c” WHERE id=1;  </p></blockquote><p>由于默认的AUTOCOMMIT机制，每个操作都是一个单独的事务，其数据行的快照日志如下:</p><blockquote><p>只有在进行修改操作时才会分配事务id，如果是只读事务，事务id默认为0</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Record      Undo Update     Undo Update     </span><br><span class="line">TRX_ID=3    TRX_ID=2        TRX_ID=1        Undo Insert</span><br><span class="line">DEL=0    -&gt; DEL=0      -&gt;   DEL=0      -&gt;   id=1</span><br><span class="line">id=1        id=1            id=1</span><br><span class="line">x=&#x27;c&#x27;       x=&#x27;b&#x27;           x=&#x27;a&#x27;</span><br></pre></td></tr></table></figure><p>对于INSERT、DELETE、UPDATE操作均会创建一条快照日志，同时记录事务版本号，DELETE是一个特殊的UPDATE操作，DELE字段会置为1。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p><strong>如何判断上面的哪条快照日志已经提交了呢</strong>？<br>MVCC维护了一个ReadView结构，主要是一个包含当前系统 <strong>未提交事务ID的列表</strong> TRX_IDS{TRX_ID1,TRX_ID2,……},这个列表还使用两个指针TRX_ID_MIN和TRX_ID_MAX分别指向这个列表里的事务最小版本号和事务最大版本号（也指系统版本号的下一个版本号），以及一个CREATOR_TRX_ID表示生成该ReadView的事务id，因为给事务版本号所分配的系统版本号是不断递增的，所以事务版本号在使用过程中也是不断递增。</p><blockquote><p><strong>ReadView何时创建</strong> ？<br>在RC隔离级别下，当前事务的每个Select都会获得最新的ReadView。<br>在RR隔离级别下，当前事务的第一个SELECT会获得最新的ReadView</p></blockquote><p>那么就可以根据，这个最大最小版本号来判断事务有没有提交。</p><blockquote><p>并不是所有的大于最小值并且小于最大值事务ID都在这个TRX_IDS列表里面，这个列表仅存未提交的事务ID</p></blockquote><p><strong>当ReadView创建完成以后，要访问某条记录的判断步骤</strong></p><ul><li><p>读取记录回滚指针的最新快照的事务ID，判断是否可读</p><ul><li>TRX_ID &lt; TRX_ID_MIN，表示这个数据行快照的事务在当前事务生成的ReadView前就已经提交了，数据行快照可以使用，直接返回</li><li>TRX_ID &gt; TRX_ID_MAX，表示这个数据行快照在事务在当前事务生成ReadView以后才创建的，还不能使用，回滚指针指向数据行的下一个快照，再次判断是否可读</li><li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，如果被访问的数据行快照的事务id在当前Readview的TRX_ID_MIN和TRX_ID_MAX之间，就判断数据行快照TRX_ID位于TRSX_IDS列表中表示该数据行快照对应的事务在ReadView创建时是活跃的还未提交，该快照不可使用。如果TRX_ID不在这个列表里，那么数据行快照已经提交了是可以使用的。</li></ul></li></ul><blockquote><p>当TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX时，对于TRX_ID的判断逻辑是一致的，但是对于不同隔离级别的ReadView是有区别的。<br>对于<strong>RC</strong>，其ReadView是每次最新的Commit以后的数据行快照，那么每次都能读取到最新的数据。<br>对于<strong>RR</strong>，其ReadView是开启事务第一次读取时的快照，即开启事务前最后一次Commit，在这个事务里面之后每次读取获得的都是这个快照，即便对数据行进行了修改，也无法获得最新的数据行快照的Commit，保证了可重复读。</p></blockquote><p>在读到的数据行不可使用时，沿着回滚指针ROLL_PTR找到下一个快照再次判断，直到找到一个可以使用的。</p><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><p>经过上面对MVCC的分析，应该已经了解到何为快照与当前了</p><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>直接使用Select * from xxx 的语句，读取到的就是快照里的数据，不需要加锁即可读。</p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>获得最新的数据，即最新的Commit以后的数据行快照。<br>对于UPDATE、INSERT、DELETE操作会进行加锁操作来读取最新的数据，因此MVCC只是保证了SELECT不需要加锁。</p><p>在使用SELECT时也可以强制加锁。</p><blockquote><p>SELECT * FROM table WHERE ? lock in share mode;<br>SELECT * FROM table WHERE ? for update;</p></blockquote><h4 id="MVCC与undo-log日志的联系"><a href="#MVCC与undo-log日志的联系" class="headerlink" title="MVCC与undo log日志的联系"></a>MVCC与undo log日志的联系</h4><p>undo log日志保存的是每条记录的不同事务id的数据记录，这些事务id的记录通过回滚指针往回指连接起来。然后系统生成了一个包含全局未提交事务id的readView结构，这时候读取了一条记录，知道了当前的事务id，如果当前读到的是未提交的事务id的记录，那么就到undo log日志里面去找，用回滚指针往前找，直到最新的已经提交的数据。</p><h2 id="InnoDB中的锁"><a href="#InnoDB中的锁" class="headerlink" title="InnoDB中的锁"></a>InnoDB中的锁</h2><h3 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h3><p>记录锁 通过对数据行的索引（不论是唯一索引还是非唯一索引，范围查询还是等于查询）进行加锁，而不是数据行本身，如果表没有设置索引，InnoDB会在主键上创建隐藏的聚簇索引。</p><h3 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h3><p>间隙锁 锁住的是一段不包含记录的区间。</p><ul><li>对于唯一索引，只有在范围查询时会加上Gap锁，等值查询直接在主键索引或者唯一键索引上加上记录锁即可。</li><li>对于非唯一索引，范围查询时会加上Gap锁，等值查询时也会加上Gap锁。</li></ul><p><strong>那么加锁步骤是咋样的</strong>？<br>以非唯一索引的等值查询为例，其他两种范围查询比较好理解。<br>|id|value|<br>|-|-|<br>|1|97|<br>|2|98|<br>|5|100|<br>|6|101|<br>|112|200|<br>以上面表格为例进行一次select当前读查询，使用快照读可能会不加锁观察不到结果，value为非唯一索引</p><blockquote><p>select * from tb where value = 100 lock in share mode;</p></blockquote><p>那么按照非唯一索引的查询步骤，到b+树去查询<br>|97|98|100|101|200|<br>|-|-|-|-|-|<br>|1|2|5|6|112|<br>然后到主键聚簇索引的b+树里去查询<br>|1|2|5|6|112|<br>|-|-|-|-|-|<br>|97|98|100|101|200|<br>查询步骤如下:  </p><ul><li>首先去非唯一索引查询100，在100记录前后加上Gap锁，也就是(98,100)与(100,101)这个范围会加上Gap锁，100这个索引会加上Record锁，然后查询到100记录的主键id为5。</li><li>拿着查询到的主键id=5到主键聚簇索引b+树里面去查询所有数据，事先也会给id=5加上Record锁。</li></ul><p>这下就理解了Gap锁给区间加锁不包括记录的含义。</p><blockquote><p>在show engine innodb status\G输出中:<br>如果是单纯的record lock，显示的是：locks rec but not gap<br>如果是单纯的gap lock， 显示的是：locks gap before rec<br>如果是gap+record，也就是next key lock，显示的是：lock_mode X &lt;空&gt;  </p></blockquote><blockquote><p>在RR隔离级别下才有Gap锁，在RC隔离级别下没有Gap锁，自然也就没有Next Key锁</p></blockquote><blockquote><p>以上Gap锁参考博客<a href="https://www.cnblogs.com/yulibostu/articles/9712417.html">MySQL InnoDB中唯一索引和非唯一索引时的加锁情况</a><br>、<a href="https://www.cnblogs.com/crazylqy/p/7773492.html">Mysql加锁过程详解（8）-理解innodb的锁(record,gap,Next-Key lock)</a></p></blockquote><h3 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next Key Lock"></a>Next Key Lock</h3><p>NextKey Lock由Gap锁与Record锁结合而成，仍然是在RR隔离级别下，innodb_locks_unsafe_for_binlog参数为0即不取消Gap锁，那么Next Key锁会生效。</p><p>即除了锁住索引记录本身，还会锁住索引间的间隙。</p><p>那么对于每一个索引记录，其加锁范围为左开右闭区间。如果between 3 and 10 范围查询操作查到索引记录为 3，4，6，7，8，10，那么锁定的区间范围是:<br>(上一个索引记录,3]<br>(3,4]<br>(4,6]<br>(6,7]<br>(7,8]<br>(8,10]<br>整体看来就是(上一个索引记录,10]这个区间被锁住了。    </p><p><strong>那么什么情况下会加锁呢</strong>？</p><blockquote><p>select…from<br>不加任何类型的锁  </p></blockquote><blockquote><p>select…from…lock in share mode<br>在扫描到的所有索引记录上加共享的NextKey锁，然后到主键聚集索引上加排他锁</p></blockquote><blockquote><p>select…from…lock for update<br>在扫描到的所有索引记录上加排他的NextKey锁，然后到主键聚集索引上加排他锁</p></blockquote><blockquote><p>update…where delete from…where<br>在扫描到的所有索引记录上加排他的NextKey锁，然后到主键聚集索引上加排他锁</p></blockquote><h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>插入意向锁是InnoDB用来提高多事务并发插入能力的锁，名字有意向但其实不是意向锁，而是间隙锁，也不是表锁，是行锁。</p><p>普通的Gap锁是防止在间隙里有新记录插入，只与插入操作冲突。可以说插入的时候是排他锁。<br>但是对于插入意向锁而言，允许多个事务在同一段范围里插入数据，只要数据本身不冲突就不会阻塞。  </p><p>关于插入意向锁与其他锁的兼容关系:<br>||Gap锁|插入意向锁|Record锁|Next-Key锁|<br>|-|-|-|-|-|<br>|Gap锁|兼容|兼容|兼容|兼容|<br>|插入意向锁|<code>冲突</code>|兼容|兼容|<code>冲突</code>|<br>|Record锁|兼容|兼容|<code>冲突</code>|<code>冲突</code>|<br>|Next-Key锁|兼容|兼容|<code>冲突</code>|<code>冲突</code>|</p><blockquote><p>横向锁是已经获得的锁，纵向锁是正在申请的锁</p></blockquote><p>Gap锁自身是兼容的，插入意向锁自身也是兼容的，Record锁自身是冲突的，但这不是重点。</p><p>问题是在已经获得了Gap锁或Next-Key锁以后，即便是同一事务，想要获取插入意向锁也会阻塞。</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>属性不可再分</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>所有的非主属性列完全函数依赖于主键，即符合第二范式。<br>可以将完全函数依赖的非主属性与主键一同拆分出去</p><blockquote><p>{Sno, Cname}为主属性唯一确定一条记录。<br>有依赖关系 Sno, Cname-&gt; Grade，那么可以将这三个记录完全拆分成为一张单独的表。</p></blockquote><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>存在非主属性传递函数依赖于主属性，这里的依赖可以是完全函数依赖也可以是部分函数依赖于主属性。如果是这种情况可以进行拆分。</p><blockquote><p>{Sno, Cname}为主属性唯一确定一条记录。<br>有依赖关系 Sno -&gt; Sdept -&gt; Mname，那么可以将Mname移除原表，Sdept-&gt;Mname拆分为一张新的表。 </p></blockquote><h2 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>是一颗平衡排序二叉树。<br>B+树基于B树与叶子节点的顺序访问指针来实现。具有B树的平衡性查找效率高且稳定，而且能通过顺序访问指针来提高区间的查询性能。</p><p>B+树的叶子节点暂存了所有的数据，中间节点使用叶子节点的数据作为索引来进行查找，最终能获得位于叶子节点的所有数据。</p><p><strong>怎么在B+树上面查找呢？</strong><br>首先从B+树的根节点进行查找经过O(logn)时间以后，找到叶子节点，然后在叶子节点上顺序或者二分查找对于key的data。</p><p>插入和删除操作会破坏树的平衡结构，需要重新对树节点进行分裂、合并、旋转等操作。</p><h3 id="与红黑树比较"><a href="#与红黑树比较" class="headerlink" title="与红黑树比较"></a>与红黑树比较</h3><p>红黑树也可以用来实现索引，但是文件系统与数据库普遍使用B+树来作为索引结构，那么有哪些原因呢？  </p><ul><li>B+树有更低的树高，平衡树的节点可以自定义，其树高为O(h)=O(logdN)【log以d为底的N的对数】，这个d就是一个中间节点出度的个数。红黑树的出度为2，而B+树的出度特别的大，所以红黑树的树高比B+树要高。</li><li>磁盘访问原理，操作系统将内存与磁盘分割成固定大小的块，内存中称为一页，与磁盘以页为单位交换数据。数据库系统将索引的一个节点大小设置为一页的大小，使得一次io就能完全载入一个节点（一个节点就是一个B+树的节点）。</li><li>磁盘预读特性，为了减少io操作，一次磁盘io往往不是严格按需读取，而是每次都会预读，预读的话是在磁盘访问寻道完成以后将找到数据的一页以及其后连续的几页读入内存，只需要少量旋转时间即可，通常预读取大小就是页的整数倍。</li></ul><blockquote><p>磁盘存取，磁盘I/O涉及机械操作。磁盘是由大小相同且同轴的圆形盘片组成，磁盘可以转动(各个磁盘须同时转动)。磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不动，磁盘转动，但磁臂可以前后动，用于读取不同磁道上的数据。磁道就是以盘片为中心划分出来的一系列同心环。磁道又划分为一个个小段，叫扇区，是磁盘的最小存储单元。  </p></blockquote><blockquote><p>磁盘读取时，系统将数据逻辑地址传给磁盘，磁盘的控制电路会解析出物理地址（哪个磁道，哪个扇区），于是磁头需要前后移动到相应的磁道——寻道，消耗的时间叫——寻道时间，磁盘旋转将对应的扇区转到磁头下（磁头找到对应磁道的对应扇区），消耗的时间叫——旋转时间，这一系列操作是非常耗时。</p></blockquote><h3 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h3><p>索引是通过具体的DB引擎实现的，比如InnoDB和Myisam等，不同的引擎，索引具有不同的类型和实现。</p><h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><p>是大多数MYSQL存储引擎的默认索引类型。<br>InnoDB的B+树索引分为聚集索引与辅助索引，聚集索引的叶子节点存储完整的行记录，因此InnoDB必须有且只有一个聚集索引。  </p><ul><li>如果定义了PK，那么PK就是聚集索引</li><li>如果没有PK，那么第一个NOT NULL UNIQUE列是聚集索引</li><li>否则InnoDB会创建一个隐藏的row-id作为聚集索引</li></ul><p>辅助索引的叶子节点存储着主键的值，而非完整记录，因此使用辅助索引先要在辅助索引B+树里面找到聚集索引主键id然后再到聚集索引里面查找数据行。</p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引时间复杂度O(1)很高，但是不能排序，分组，也不能进行范围查询，只能精确查找。</p><p>但是InnoDB有一个特殊的功能叫”自适应哈希索引”，对于频繁使用的某个索引值，会在B+树之上再建立一个哈希索引，是B+树的索引再具有哈希索引的一些优点。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。<br>全文索引使用倒排索引实现，记录着关键词到其所在文档的映射。</p><blockquote><p>倒排索引？doyouknow？<br>就是将整个文章按每一句进行编号，每一件编号里有哪些文章语句和单词，倒过来存，怎么个倒过来存呢？就是将这些文章句子中的关键词提取出来，记录这些关键词出现在了哪几句编号中。  </p></blockquote><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="索引列-必须独立使用"><a href="#索引列-必须独立使用" class="headerlink" title="索引列 必须独立使用"></a>索引列 必须独立使用</h4><p>在进行查询时使用索引，索引列不能位于表达式的一部分，也不能是函数的参数，否则不会使用索引列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>上面的例子不会使用actor_id索引。</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们知道联合索引满足最左前缀原则，即以最左边的列为起点任何连续的索引都能匹配上。</p><p>所以创建索引时，要将最频繁使用的列放到最左边，而且对于or字段，如果or两边有一个字段没有索引，就会放弃使用索引改用全表扫描。</p><p><strong>例</strong>：<br>我们给(a，b，c) 三个属性列创建这个顺序的联合索引，相当于创建了(a)单列索引、(a，b)联合索引、(a，b，c)联合索引这三个索引。</p><p>那么上面这三个索引的叶子节点均保存了对应索引列的全部数据。</p><blockquote><p>参考博文<a href="https://blog.csdn.net/liujun19921020/article/details/103215701">MySql | InnoDB 多个单列索引与联合索引之路</a></p></blockquote><h4 id="索引列的选择性"><a href="#索引列的选择性" class="headerlink" title="索引列的选择性"></a>索引列的选择性</h4><p>让选择性最强的索引列放到最前面。</p><p>在抛开业务需求的基础上，如何选择一个列放在索引的最左边呢？<br>根据索引的选择性(不重复的索引值和记录总数的比值)，最大为1，此时每个记录值都有唯一的索引与他对应，查询的效率最高，以唯一索引为例，。</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>对于BLOB、TEXT、VARCHAR等文本类型的列，必须使用前缀索引，只索引数据开始的部分字符。</p><p>选多长的数据作为前缀，要根据索引的选择性来确定，以使得索引选择性接近1.</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>索引列包含需要查询的所有字段。</p><p>覆盖索引是一种设计思路，其具有以下优点:</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>对于InnoDB引擎，如果辅助索引能够覆盖查询，则无需访问主索引进行回表操作，与直接进行主键查询具有相同的效率。</li></ul><p>覆盖索引常常使用联合索引来实现，叶子节点中包含查询索引列的所有值，不再需要进行回表操作。</p><p>使用explain 能观察到Extra字段显示Using Index，触发了覆盖索引。</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>指的是在使用索引进行查询的时候，查询到非聚集索引的叶子节点的索引的时候，先用where语句对叶子节点存在的部分字段的值进行过滤，然后再用剩下的记录去做回表。</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li>大大减少扫描的数据行数</li><li>索引是有序的，避免进行排序和分组以进行的临时表创建</li><li>将随机io变为顺序io(有序的数据可以相邻存储)</li></ul><h3 id="索引使用条件"><a href="#索引使用条件" class="headerlink" title="索引使用条件"></a>索引使用条件</h3><ul><li>对于小表，不需要建立索引，因为有可能全表查询比索引要快。</li><li>对于中表到大表，索引非常有效率</li><li>对于超大表，建立维护索引的成本也特别高，这种情况下可以进行分表查询。</li></ul><h3 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h3><h4 id="使用Explain分析Select"><a href="#使用Explain分析Select" class="headerlink" title="使用Explain分析Select"></a>使用Explain分析Select</h4><blockquote><p>explain select id,name from user where name = ‘sail’;</p></blockquote><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>user</td><td>ref</td><td>name</td><td>name</td><td>23</td><td>const</td><td>1</td><td>Using where;Using index</td></tr></tbody></table><p>其中比较重要的字段包括：  </p><ul><li>id: id相同认为是同一组，从上到下顺序执行，id不同认为越大优先级越高</li><li>select_type: 查询类型，有简单查询（不包含子查询和UNION）、联合查询、子查询、PRIMARY（里层包含任何复杂的子部分，外层就会标记为这个）等</li><li>key: 有没有使用索引，使用的什么字段索引</li><li>rows: 查询时扫描了多少行，越少越好</li><li>Extra: 十分重要的额外信息，例Using where(使用了where过滤) 等等</li></ul><h4 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h4><ol><li>减少请求的数据量<ol><li>不要使用全表查询，select *等排除使用</li><li>有计划的限制返回的数量，使用limit等</li><li>缓存重复查询数据</li></ol></li><li>减少服务端扫描数据的行数<ol><li>使用索引覆盖查询</li></ol></li></ol><h4 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h4><ol><li><p>切分大查询</p><ul><li>对于大表，如果执行一次性查询，可能速度慢，锁住很多数据，占满事务日志，阻塞其他重要的小查询。  </li><li>因此要切分出来，多次查询，比如使用limit进行分页查询</li><li>对于小表多次查询会影响效率，对于大表反而能提升效率</li></ul></li><li><p>分解大连接查询<br>将联表查询分解为多次的单表查询，然后在业务中关联。</p><ul><li>让缓存更有效率</li><li>根据前一个查询决定后续查询条件，减少联表带来的冗余查询</li><li>减少锁竞争</li><li>在应用层连接</li></ul></li></ol><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>是MYSQL的默认引擎。<br>实现了四个标准的隔离级别。<br>索引分为主索引与辅助索引两部分，主索引为聚集索引，索引中就保存了数据不需要直接读硬盘。<br>支持在线热备份。  </p><h4 id="Myisam"><a href="#Myisam" class="headerlink" title="Myisam"></a>Myisam</h4><p>对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。<br>不支持事务。<br>不支持行锁。  </p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>事务：InnoDB是事务型的支持Commit与RollBack<br>并发：Myisam支持表级锁，InnoDB支持行级锁<br>外键：InnoDB支持外键<br>索引：InnoDB索引是聚集索引，数据放在主键叶子节点，Myisam是非聚集索引，数据与索引分离。<br>行数：InnoDB不保存行数，Myisam保存行数<br>备份：InnoDB支持在线热备份<br>崩溃恢复：Myisam发生崩溃后数据丢失损坏的概率比InnoDB要高，而且速度也慢<br>其他特性：Myisam支持全文索引、压缩表和空间数据索引</p><h3 id="Mysql数据类型"><a href="#Mysql数据类型" class="headerlink" title="Mysql数据类型"></a>Mysql数据类型</h3><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h4 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h4><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h4 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h4><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><h5 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h5><p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h5 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h5><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h3 id="Mysql分表策略"><a href="#Mysql分表策略" class="headerlink" title="Mysql分表策略"></a>Mysql分表策略</h3><blockquote><p>40亿条用户记录存放到mysql中，要使用用户名与手机号进行查询，设计一个方案保证查询效率？<br>首先进行 分库 按照 用户id范围进行分库。<br>然后对每一个库按照 用户id范围进行分表。<br>然后对用户名维护一个按照用户名分库分表的多个表。<br>对手机号维护一个按照手机号分库分表的多个表。<br>那么就是如果要以手机号查询，首先按照hash求得手机号对应得库，再hash求得手机号对应得表，走索引取得记录对应得主键id，拿着主键id，按照id范围获得主键id表的库，再按id范围获得主键id的分表，进而走索引获得对应的用户记录。<br>以用户名查询类似。</p></blockquote><h4 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h4><p>水平切分又称为Sharding，它是将同一个表中记录拆分到多个数据结构相同的表里面。<br>当一个数据表的数据不断地增多，到不论怎么优化都难以使用时，必须要进行Sharding。<br>将数据分散到集群的多个表里面，缓解单个数据库的压力。</p><h4 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h4><p>垂直切分是将一张表的属性字段切分到多个表里面，通常按关系密集程度切分，也可以按使用频率来切分。</p><p>通过切分来缓解表的冗余数据。</p><h4 id="水平切分策略"><a href="#水平切分策略" class="headerlink" title="水平切分策略"></a>水平切分策略</h4><ul><li>哈希取模hash(key)%N (N指切分出的表的数量)</li><li>范围：按id范围或者时间范围，一段ids或者一段时间内的位于一张表里</li><li>映射表：自定义映射关系，使用单独的库表来存储这个映射关系，但是每次查询都是查两次表，路由映射表大了以后也会影响性能。</li></ul><h4 id="水平切分的问题"><a href="#水平切分的问题" class="headerlink" title="水平切分的问题"></a>水平切分的问题</h4><ol><li><p>事务一致性问题<br>使用分布式事务解决 【怎么实现的？】</p></li><li><p>连接问题</p><ol><li>表的连接问题，对于无法连接的表采用单表查询后再条件查询</li></ol></li><li><p>ID唯一性问题。</p><ol><li>使用全局唯一ID</li><li>为每个分表指定一段ID范围</li><li>使用分布式ID生成器 【怎么实现的】</li></ol></li></ol><p>总的来说，分表为了解决存储的压力。</p><h3 id="Mysql复制"><a href="#Mysql复制" class="headerlink" title="Mysql复制"></a>Mysql复制</h3><blockquote><p>为什么 在 RC 级别下，binlog 格式要设置成 row？</p></blockquote><p>先来看下 binlog 的三种格式：</p><ul><li>binlog-format=STATEMENT ：在 Master 向 Slave 同步时，会以原生的 SQL 语句进行同步。</li><li>binlog-format=ROW ：Master 会把被操作后的表中的行记录在日志中， 向 Slave 同步。简单来说同步的就是表中的数据。</li><li>binlog-format=MIXED ：默认会以 STATEMENT 的方式记录，但在一些情况下可以自动的切换成 ROW 方式，比如执行用户自定义的函数 UUID.</li></ul><p>这里采用反证法，如果在 RC 级别下，将 binlog 的格式设置成 Statement 会发生什么？ </p><p>还是使用之前 RR 级别下幻读的例子：<br>|Session A|Session B|<br>|-|-|<br>|begin:||<br>|update t set d=100 where d=5;||<br>||insert into t values(1,1,5);|<br>||update t set d=5 where id=1;|<br>|commit;||</p><p>得到的结果是一样的，Binlog 日志中 Session B 先执行，Session A 后执行，A 会把 id=1 中 d 的值改为 100，出现了 binlog 和 数据库数据不一致的现象。</p><p>而基于 ROW 格式则不同，binlog 日志中记录的是被操作后的数据，不是重新执行 SQL 自然就没有这个问题。</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a><strong>主从复制</strong></h4><p>Mysql有一种二进制日志bin-log，会记录下所有修改数据库的sql语句。</p><ul><li>那么在主服务器中启用binlog线程将数据更改写到日志中  </li><li>在从服务器中启动一条io线程根据MYSQL协议向主服务器请求bin-log日志</li><li>主服务器开启一条Dump线程，检查自己二进制日志的事件，如果请求的事件不带位置参数，那么主服务器会将第一个bin-log开始，一个一个发给从服务器</li><li>从服务器接收到这些数据以后会放到那个中继日志(Relay log)，并记录请求到主服务器哪一个binlog文件的哪一个位置。</li><li>从服务器启动另一个sql线程，解析中继日志并执行一遍。</li></ul><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a><strong>读写分离</strong></h4><p>主服务器处理处理写操作与实时性较高的读操作，而从库处理读操作。<br>读写分离极大地提高了访问的能力，提高的是被写入影响的查询的效率，原因如下：</p><ul><li>主从服务器各自负责写和读，缓解了锁的竞争，提高并发效率。</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销。</li></ul><p>读写分离可以通过中间层来实现，在应用服务器与数据库服务器之间添加一层中间代理层，代理层接收应用层的读写请求，然后决定转发到哪个服务器上。</p><h4 id="主从复制的延迟问题"><a href="#主从复制的延迟问题" class="headerlink" title="主从复制的延迟问题"></a>主从复制的延迟问题</h4><p>从库单线程执行sql的延迟问题，无法从主从复制架构上解决，从上层找解决方案：  </p><ol><li>可以将更新完数据之后的读取相关数据的操作，都去读主库。</li><li>利用分布式缓存，在更新完数据以后的同时将这些数据写入到缓存中，避免立即去读从库。</li></ol><h1 id="Mysql存储的原理"><a href="#Mysql存储的原理" class="headerlink" title="Mysql存储的原理"></a>Mysql存储的原理</h1><p>在InnoDB中数据持久化到磁盘上对应一个.frm文件存放表的定义，对应一个.idb的文件存放数据与索引。</p><p>可以说在InnoDB中所有数据都是索引。</p><h1 id="关于InnoDB的普通索引与唯一索引"><a href="#关于InnoDB的普通索引与唯一索引" class="headerlink" title="关于InnoDB的普通索引与唯一索引"></a>关于InnoDB的普通索引与唯一索引</h1><p>考虑都是非主键索引的情况。</p><p>B+树的叶子节点保存的是索引值与主键id。</p><h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><p>首先会存在一个change buffer，当要更新一个数据页的时候，如果数据页在内存中就直接更新，如果不在内存中，那么等下次查询访问到这一页数据的时候将数据读入内存中以后，执行change buffer中的与当前页相关的修改操作，为了保证持久性，这个change buffer也是会持久化到磁盘的。通过这种方式能减少读磁盘的次数。而且磁盘的数据提前读入内存会占用buffer pool的，提高内存利用率。</p><p>以上对于普通索引是能够提高查询效率，以及磁盘访问效率的。</p><p>对于唯一索引，由于要进行数据唯一性验证，需要先将数据页读入内存，因此就不需要使用change buffer了。</p><p>当插入一条数据的时候，如果插入的物理页在内存中，就直接插入就ok了，如果不在内存中呢，就写到change buffer中，然后将物理页的修改还是插入操作写入到redo log中。</p><p>以上内存操作完成以后，一次磁盘io写入即可，顺序写。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式详解</title>
      <link href="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md</a></p></blockquote><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>主要是为了解耦，模块间减少依赖，职责分明，支持扩展。</p><ol><li>单一职责原则</li><li>里氏替换原则<ul><li>子类必须完全实现父类方法</li><li>子类可以有个性</li><li>子类覆盖或实现父类方法时 入参可以被放大</li><li>子类重写或实现父类方法时 输出结果可以被缩小</li></ul></li><li>依赖倒置原则<ul><li>模块间依赖通过接口或抽象类产生</li></ul></li><li>接口隔离原则</li><li>迪米特法则<ul><li>一个类尽量耦合</li></ul></li><li>开闭原则 <ul><li>对扩展开发，对修改关闭</li></ul></li></ol><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型（6种）"><a href="#创建型（6种）" class="headerlink" title="创建型（6种）"></a>创建型（6种）</h2><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p><p>简单工厂字面意思，简单的工厂，将创建对象的实例化操作封装到一个类里面，客户类对象与工厂类对象解耦，没有关系，客户类通过工厂类生成一个实例，不需要关注生成实例的具体过程，只需要指明要什么对象的实例。</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>定义一个创建对象的接口，由子类决定创建什么样的对象。工厂方法运用了多态，创建对象的具体操作不同子类有不同实现。</p><p>而且侧重方向在方法上，父类中定义了抽象方法的使用逻辑什么时候执行，而子类中对方法具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factoryMethod();</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>就是在工厂方法的基础上进一步的抽象，但是侧重点不在方法，而在拿到什么对象。</p><p>将工厂类Factory的上面再添加一层父类AbstractFactory抽象工厂类，对这个抽象工厂类再添加多个不同的工厂子类实现。<br>那么我获得了什么工厂的子类运用了多态，我就用其这个工厂子类的方法创建什么样的产品的子类也运用了多态，抽象方法在扩展上比较方便，添加一个工厂子类即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA1</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA2</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB1</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB2</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">abstractFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">AbstractProductA</span> <span class="variable">productA</span> <span class="operator">=</span> abstractFactory.createProductA();</span><br><span class="line">        <span class="type">AbstractProductB</span> <span class="variable">productB</span> <span class="operator">=</span> abstractFactory.createProductB();</span><br><span class="line">        <span class="comment">// do something with productA and productB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>顾名思义，生成某个对象的工具，封装一个对象的构造过程，并允许按照步骤构造</p><p>例如子类使用父类的构造器</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>使用原型模式指定要创建对象的类型，但是呢？要通过复制这个原型对象来创建新对象。</p><p>实现一下Clonable接口，重写clone方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer fileId;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; map ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Prototype</span><span class="params">(<span class="type">int</span> fileId,String fileName,Map&lt;String,Integer&gt; map)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.fileId = fileId;</span><br><span class="line">        <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Prototype <span class="title function_">clone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">filePrototype</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//基本数据类型直接复制</span></span><br><span class="line">            filePrototype  = (Prototype) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">//单独处理复杂对象</span></span><br><span class="line">            filePrototype.map = (Map&lt;String,Integer&gt;)((HashMap)<span class="built_in">this</span>.map).clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filePrototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Prototype</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Prototype</span>(<span class="number">1</span>,<span class="string">&quot;fileName&quot;</span>,<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">    <span class="type">Prototype</span> <span class="variable">newType</span> <span class="operator">=</span> type.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="行为型（12种）"><a href="#行为型（12种）" class="headerlink" title="行为型（12种）"></a>行为型（12种）</h2><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p>使多个对象都有机会处理某个数据，将这些对象以链式的方式拼接和删除，然后将数据沿着这条链传递，直到某个对象处理完终止。</p><p>避免数据的发送者和接收者之间的耦合关系。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>命令被封装成对象以后，就可以单个单个的使用执行器来执行。</p><p>具有以下作用：<br>使用命令来参数化其它对象<br>将命令放入队列中进行排队<br>将命令的操作记录到日志中<br>支持可撤销的操作   </p><p>执行器依赖命令的父类，在execute方法中传入不同的命令，即可执行对应命令的操作。</p><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>为语言创建解释器，通常由语言语法和语法分析来定义.</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>提供一种聚合访问元素对象的的方法，聚合对象里面可能有一些列子对象，迭代器提供了不暴露内部结构的方式，遍历内部聚合对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Item[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(Item[] items)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[position++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; items.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">提供一个迭代器对象，而聚合对象内部提供一个方法，生成这个迭代器对象，并传入聚合对象给迭代器，然后将这个迭代器返回。</span><br></pre></td></tr></table></figure><h3 id="中介者"><a href="#中介者" class="headerlink" title="中介者"></a>中介者</h3><p>顾名思义，定义一个中间接口，用于处理各个单位之间的通信。</p><p>定义一个中介</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doEvent</span><span class="params">(String eventType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个组件Unit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Unit</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义多个组件实例 洗澡、刷牙、睡觉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shower</span> <span class="keyword">extends</span> <span class="title class_">Unit</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;洗澡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doShower</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在洗澡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrushTeeth</span> <span class="keyword">extends</span> <span class="title class_">Unit</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;刷牙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBrushTeeth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在刷牙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sleep</span> <span class="keyword">extends</span> <span class="title class_">Unit</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义中介的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Shower shower;</span><br><span class="line">    <span class="keyword">private</span> BrushTeeth brushTeeth;</span><br><span class="line">    <span class="keyword">private</span> Sleep sleep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteMediator</span><span class="params">(Shower shower,BrushTeeth brushTeeth,Sleep sleep)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.shower = shower;</span><br><span class="line">        <span class="built_in">this</span>.brushTeeth = brushTeeth;</span><br><span class="line">        <span class="built_in">this</span>.sleep = sleep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doEvent</span><span class="params">(String eventType)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;睡觉&quot;</span>:</span><br><span class="line">                doSleepEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;洗澡&quot;</span>:</span><br><span class="line">                doShower();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;刷牙&quot;</span>:</span><br><span class="line">                doTeeth();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSleepEvent</span><span class="params">()</span>&#123;</span><br><span class="line">        shower.doShower();</span><br><span class="line">        brushTeeth.doBrushTeeth();</span><br><span class="line">        sleep.doSleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Shower</span> <span class="variable">shower</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shower</span>();</span><br><span class="line">        <span class="type">Sleep</span> <span class="variable">sleep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sleep</span>();</span><br><span class="line">        <span class="type">BrushTeeth</span> <span class="variable">bruthTeeth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BruthTeeth</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>(shower,bruthTeeth,sleep);</span><br><span class="line">        <span class="comment">// 睡觉事件到达，调用中介者就可以操作相关对象</span></span><br><span class="line">        <span class="comment">// 在onEvent里传一个标识对象给中介，中介来决定做哪个组件的操作</span></span><br><span class="line">        sleep.onEvent(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p><h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>定义对象之间一对多的的依赖关系，当目标对象状态改变时，其他所有依赖对象均会收到通知并作出响应。<br>Subject是被观察的对象，而Observer是观察者对象。</p><p>这样一个关系，那么Subject具有的方法就是 注册观察者、删除观察者、通知所有观察者。<br>观察者具有的方法就是 Subject修改以后的回调方法，其注册操作使用Subject的注册方法去注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被观察者 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WearherStation</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="comment">//温度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="comment">//湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="comment">//气压</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherStation</span><span class="params">()</span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWeather</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TvShow</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TvShow</span><span class="params">(Subject weatherStation)</span> &#123;</span><br><span class="line">        weatherStation.reisterObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;StatisticsDisplay.update: &quot;</span> + temp + <span class="string">&quot; &quot;</span> + humidity + <span class="string">&quot; &quot;</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">WeatherStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherStation</span>();</span><br><span class="line">    <span class="type">TvShow</span> <span class="variable">show</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TvShow</span>(station);</span><br><span class="line">    <span class="comment">//这里发布一下数据，其他观察者都能收到信息。</span></span><br><span class="line">    station.updateWeather(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件传播机制<br>监听者作为观察者，不同的事件作为被观察者。<br>第一种方式，将listener注册到不同的事件类型上，有对应事件类型的事件到来，就是publishEvent，取出对应的监听者列表 传入事件对象 去执行。<br>第二种方式，Spring是将listener统一管理，有事件类型来，从listener列表中选出对应事件的监听者去执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneEvent</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> key;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventListener</span>&lt;OneEvent&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(OneEvent e)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> e.key;</span><br><span class="line">        ...doSomething</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SpringBoot中维护一个listeners列表。</span><br><span class="line"></span><br><span class="line">每次publishEvent(<span class="keyword">new</span> <span class="title class_">Event</span>());</span><br><span class="line"></span><br><span class="line">就从listeners列表中取出对应事件的targetListeners=getApplicationListeners(event, type);</span><br><span class="line"></span><br><span class="line">循环执行targetListeners，传入event，执行onApplicationEvent(event);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>状态模式，顾名思义，允许对象在其状态发生变化以后修改其方法的行为，即相同的方法在不同的状态下具有不同的操作。<br>状态机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GumballMachine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State hasQuarterState;</span><br><span class="line">    <span class="keyword">private</span> State noQuarterState;</span><br><span class="line">    <span class="keyword">private</span> State soldState;</span><br><span class="line">    <span class="keyword">private</span> State soldOutState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GumballMachine</span><span class="params">(<span class="type">int</span> numberGumballs)</span>&#123;</span><br><span class="line">        count = numberGumballs;</span><br><span class="line">        hasQuarterState = <span class="keyword">new</span> <span class="title class_">HasQuarterState</span>(<span class="built_in">this</span>);</span><br><span class="line">        noQuarterState = <span class="keyword">new</span> <span class="title class_">NoQuarterState</span>(<span class="built_in">this</span>);</span><br><span class="line">        soldOutState = <span class="keyword">new</span> <span class="title class_">SoldOutState</span>(<span class="built_in">this</span>);</span><br><span class="line">        soldState = <span class="keyword">new</span> <span class="title class_">SoldState</span>(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(numberGumballs&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            state = noQuarterState;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            state = soldOutState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        state.insertQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        state.ejectQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        state.turnCrank();</span><br><span class="line">        state.dispense();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseBall</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A gumball comes rolling out the slot...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            count -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getSoldOutState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> soldOutState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getNoQuarterState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> noQuarterState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getHasQuarterState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasQuarterState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getSoldState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> soldState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">//投入分钱</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//退回分钱</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//转动曲柄</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//发放糖果</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoldState</span> <span class="keyword">implements</span> <span class="title class_">State</span>&#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoldState</span><span class="params">(GumballMachine gumballMachine)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Please wait, we&#x27;re already giving you a gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorry, you already turned the crank&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Turning twice doesn&#x27;t get you another gumball!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        gumballMachine.releaseBall();</span><br><span class="line">        <span class="keyword">if</span> (gumballMachine.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            gumballMachine.setState(gumballMachine.getNoQuarterState());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Oops, out of gumballs&quot;</span>);</span><br><span class="line">            gumballMachine.setState(gumballMachine.getSoldOutState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoldOutState</span> <span class="keyword">implements</span>  <span class="title class_">State</span>&#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoldOutState</span><span class="params">(GumballMachine gumballMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You can&#x27;t insert a quarter, the machine is sold out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You can&#x27;t eject, you haven&#x27;t inserted a quarter yet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You turned, but there are no gumballs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoQuarterState</span> <span class="keyword">implements</span> <span class="title class_">State</span>&#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NoQuarterState</span><span class="params">(GumballMachine gumballMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You insert a quarter&quot;</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.getHasQuarterState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You haven&#x27;t insert a quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You turned, but there&#x27;s no quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You need to pay first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasQuarterState</span> <span class="keyword">implements</span> <span class="title class_">State</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">GumballMachine</span> <span class="variable">gumballMachine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HasQuarterState</span><span class="params">(GumballMachine gumballMachine)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You can&#x27;t insert another quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quarter returned&quot;</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.getNoQuarterState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You turned...&quot;</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.getSoldState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>策略方法Stratagy接口，定义了一系列方法。</p><p>Context上下文中依赖这个Strategy，并在Context的方法里调用Strategy定义的方法，并且可以使用SetStrategy(strategy)动态地改变strategy对象，也就是动态改变Context的算法。</p><p>状态模式 与 策略模式 的区别<br>状态模式通过状态转移（状态转移是指在运行过程中根据状态变化而使用预定义好的方法的一种）来改变Context所组合的State对象，策略模式是通过Context本身的决策在一组定义好的算法簇里面选择一个合适的策略算法来 改变组合对象的Strategy对象，策略模式不强调一个变化过程，强调选择一个最合适的算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个鸭子，改变其叫声的策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quack</span> <span class="keyword">implements</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quack!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Squeak</span> <span class="keyword">implements</span> <span class="title class_">QuackBehavior</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;squeak!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performQuack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (quackBehavior != <span class="literal">null</span>) &#123;</span><br><span class="line">            quackBehavior.quack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">        duck.setQuackBehavior(<span class="keyword">new</span> <span class="title class_">Squeak</span>());</span><br><span class="line">        duck.performQuack();</span><br><span class="line">        duck.setQuackBehavior(<span class="keyword">new</span> <span class="title class_">Quack</span>());</span><br><span class="line">        duck.performQuack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>定义算法框架，将步骤的实现放到子类中。</p><p>不同子类可以重写定义每个步骤的实现。</p><h3 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h3><p>为一个对象结构（比如组合结构）增加新能力。</p><h3 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h3><p>就是指用空对象来代替无效的NULL，避免没有空指针检查而报NPE。</p><h2 id="结构型（7种）"><a href="#结构型（7种）" class="headerlink" title="结构型（7种）"></a>结构型（7种）</h2><h3 id="适配器-Adapter"><a href="#适配器-Adapter" class="headerlink" title="适配器(Adapter)"></a>适配器(Adapter)</h3><p>把一个类接口转换成另一个类/用户需要的接口。</p><h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p>将抽象与实现分离开，使他们可以独立变化，怎么让这俩东西分离开，脱耦呢？通过关联关系而不是继承关系。<br>假设现在有两个东西电视机与遥控器，他们具有一定的关系，但是也要求双方自由的变化，而不影响另一方。<br>电视机tv接口 通过继承/实现 子类 来变化<br>遥控器control接口 通过继承/实现 子类 来变化<br>电视机与遥控器通过关联关系来联系，比如遥控器依赖电视机，电视机tv作为遥控器的一个成员变量，这个变量是可以修改为不同电视机的，在遥控器初始化的时候构造方法里传入电视机的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sony</span> <span class="keyword">extends</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sony.on()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sony.off()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sony.tuneChannel()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RCA</span> <span class="keyword">extends</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RCA.on()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RCA.off()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RCA.tuneChannel()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteControl</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteRemoteControl1</span> <span class="keyword">extends</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteRemoteControl1</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl1.on()&quot;</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl1.off()&quot;</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl1.tuneChannel()&quot;</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteRemoteControl2</span> <span class="keyword">extends</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteRemoteControl2</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl2.on()&quot;</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl2.off()&quot;</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl2.tuneChannel()&quot;</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RemoteControl</span> <span class="variable">remoteControl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteRemoteControl1</span>(<span class="keyword">new</span> <span class="title class_">RCA</span>());</span><br><span class="line">        remoteControl1.on();</span><br><span class="line">        remoteControl1.off();</span><br><span class="line">        remoteControl1.tuneChannel();</span><br><span class="line">        <span class="type">RemoteControl</span> <span class="variable">remoteControl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteRemoteControl2</span>(<span class="keyword">new</span> <span class="title class_">Sony</span>());</span><br><span class="line">         remoteControl2.on();</span><br><span class="line">         remoteControl2.off();</span><br><span class="line">         remoteControl2.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合模式就是将对象以树形结构来表示整体/部分的层次。<br>组件类Component是 组合类Composite 和 叶子类Leaf 的父类，可以理解为树结构的结点。</p><p>一个组件对象拥有一个或者多个组件对象，因此当前组合对象的操作可以委托给其组件对象去处理，而委托的组件对象也可以是另一个组合对象或者叶子对象</p><h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><p><strong>设计原则</strong>: 对扩展开放，对修改关闭，即添加新功能时不需要修改代码。<br>在对原对象没有影响的情况下为对象动态添加功能。所以对原始对象与装饰对象在设计之初 实现同一接口 为了装饰完对象以后，对象不受影响。</p><p>原始目标对象与装饰对象基于的接口为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饮料，有个方法计算售价</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Beverage</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深烘培咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkRoast</span> <span class="keyword">implements</span> <span class="title class_">Beverage</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首选咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseBlend</span> <span class="keyword">implements</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在要给这俩咖啡加料</span></span><br><span class="line"><span class="comment">//首先定义饮料的装饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Beverage</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Beverage beverage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//牛奶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Milk</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Milk</span><span class="params">(Beverage beverage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//糖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sugar</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sugar</span><span class="params">(Beverage beverage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端，使用牛奶和糖装饰咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseBlend</span>();</span><br><span class="line">        beverage = <span class="keyword">new</span> <span class="title class_">Mocha</span>(beverage);</span><br><span class="line">        beverage = <span class="keyword">new</span> <span class="title class_">Milk</span>(beverage);</span><br><span class="line">        System.out.println(beverage.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>外观设计模式，提供一个统一的接口，用来访问子系统的一群接口，让子系统更易用。</p><p>实际就是将各子类系统集成到一个大类里面实现一个整体的功能，子系统完成整个系统的一部分步骤。<br>那么给用户交互，用户直接使用整个系统提供的方法完成一个功能，而不是用户要去找不同的子系统一步一步操作来完成这一个功能。</p><h3 id="享元（FlyWeight）"><a href="#享元（FlyWeight）" class="headerlink" title="享元（FlyWeight）"></a>享元（FlyWeight）</h3><p>缓存小对象<br>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理类优点：代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合）<br>代理类很多情况下 用来做增强功能。<br>缺点:一个类如果要代理他就要单独定义一个代理类，类多了以后就很难维护了。 </p><ul><li>静态代理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Image</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpgImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> URL imageURL;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JpgImage</span><span class="params">(URL imageURL)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.imageURL = imageURL;</span><br><span class="line">        <span class="built_in">this</span>.startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.width = <span class="number">600</span>;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Real Image: &quot;</span> + imageURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在要生成图片类的代理类 对showImage方法进行优化，因为如果图片本身没有加载完，为了避免单纯的卡住，可以做一些延时加载并不停给用户提示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JpgImage jpgImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(JpgImage jpgImage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jpgImage = jpgImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!jpgImage.isLoad()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Temp Image: &quot;</span> + jpgImage.getWidth() + <span class="string">&quot; &quot;</span> + jpgImage.getHeight());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jpgImage.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageViewer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> <span class="string">&quot;http://image.jpg&quot;</span>;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(image);</span><br><span class="line">        <span class="type">JpgImage</span> <span class="variable">jpgImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JpgImage</span>(url);</span><br><span class="line">        <span class="type">ImageProxy</span> <span class="variable">imageProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(jpgImage);</span><br><span class="line">        imageProxy.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>动态代理</li></ul><p>有jdk是通过反射的方式动态生成的目标类的代理类的/</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>io详解</title>
      <link href="/2020/07/24/io%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/07/24/io%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="网络io详解"><a href="#网络io详解" class="headerlink" title="网络io详解"></a>网络io详解</h1><h2 id="io模型"><a href="#io模型" class="headerlink" title="io模型"></a>io模型</h2><p>一个数据操作通常包括:</p><ul><li>等待数据到达，复制到内核的缓冲区</li><li>把数据从内核缓冲区复制到应用程序缓冲区<br>在Linux网络模型中介绍了5种io模型:</li><li>阻塞式io</li><li>非阻塞式io</li><li>多路复用io</li><li>信号驱动io</li><li>异步io</li></ul><h3 id="阻塞式io"><a href="#阻塞式io" class="headerlink" title="阻塞式io"></a>阻塞式io</h3><p>用户线程/进程发出io系统调用read，cpu会检查内核空间数据有没有复制到内核缓冲区，如果数据ok了，就将数据由内核缓冲区复制到应用程序的缓冲区，应用程序读出数据；如果数据还没有准备好，用户线程/进程就会阻塞并让出cpu，直到内核将数据填充到应用程序的缓冲区并唤醒进程/线程。</p><p>此过程中进程/线程会阻塞，但是cpu会调度其他进程执行，所以cpu的利用率挺高的。只是执行io系统调用的进程/线程会一直阻塞住。</p><p><img src="%E9%98%BB%E5%A1%9E%E5%BC%8Fio.png" alt="阻塞式io"></p><h3 id="非阻塞式io"><a href="#非阻塞式io" class="headerlink" title="非阻塞式io"></a>非阻塞式io</h3><p>用户进程发起io系统调用，如果数据没有准备好，就立即返回error状态码。应用程序可以继续执行。但是如果应用程序一定需要io数据的话，就必须不停地轮询进行io系统调用，一旦获得数据就跳出自旋，使用数据。这种方式虽然非阻塞了，但是轮询又浪费了cpu，cpu效率不高。</p><p><img src="%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8Fio.png" alt="非阻塞式io"></p><h3 id="多路复用io"><a href="#多路复用io" class="headerlink" title="多路复用io"></a>多路复用io</h3><p>这种方式多路指的是多个io资源，复用指的是一个线程管理多个io资源。当这些资源没有一个是可读可写的时候，线程会被阻塞并等待，当一个io资源可读可写说明数据已经就绪，复制到了内核缓冲区中，唤醒线程以非阻塞的方式read，将内核缓冲区的数据复制到用户程序缓冲区中。</p><p>可以使用多进程/多线程+阻塞io的方式实现多路复用io的情形，但是如果连接数过多，线程创建与切换会影响cpu的使用率。</p><p><img src="%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io.png" alt="多路复用io"></p><h3 id="信号驱动io"><a href="#信号驱动io" class="headerlink" title="信号驱动io"></a>信号驱动io</h3><p>在信号驱动io模型中，会给socket注册一个信号驱动的函数sigaction，数据未就绪，进程会继续执行，内核在数据到达时向应用进程发送SIGIO信号，然后信号处理函数会将数据从内核复制到应用进程中，然后在这个函数中进行io处理。这种方式一般用于UDP，类似于待处理的数据。</p><h3 id="异步io"><a href="#异步io" class="headerlink" title="异步io"></a>异步io</h3><p>在异步io模型中，用户线程发起一个aio_read()以后会立即返回，线程不会阻塞可以去做其他的事情，内核会等待数据准备完成，然后将数据由内核拷贝到应用程序，这一切完成以后会通知用户线程，用户线程可以直接去使用数据了。</p><p>异步io与信号驱动io的区别是:</p><ul><li>在异步io模型中，收到信号表示io两阶段操作都已完成，直接使用数据即可。</li><li>在信号驱动io模型中，收到信号表示数据已经准备好，需要用户线程进行read系统调用去获取数据。</li></ul><p><img src="%E5%BC%82%E6%AD%A5io.png" alt="异步io"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前四个io模型均为同步io，只有最后一个是真正的异步io。</p><ul><li>同步io中，数据由内核缓冲区复制到应用程序缓冲区中，应用程序会阻塞。</li><li>异步io中，io操作第二阶段也不会阻塞。</li></ul><p>在同步io中，只有阻塞式io的第一阶段会被阻塞。</p><h2 id="io多路复用详解"><a href="#io多路复用详解" class="headerlink" title="io多路复用详解"></a>io多路复用详解</h2><p>select/poll/epoll</p><h3 id="谈谈select"><a href="#谈谈select" class="headerlink" title="谈谈select"></a>谈谈select</h3><p>select方法是linux里的一种系统调用方法。select的fd_set是一个1024大小的长整型数组。select与poll都是水平触发模式。即本次轮询结束时有就绪的fd没有处理，下一次再调用会立即返回。</p><ul><li>将多个socket注册到select中的fd_set中</li><li>使用copy_from_user将fd集合从用户空间拷贝到内核空间</li><li>注册文件描述符的回调函数__pollwait</li><li>然后就是轮询fd集合调用poll方法，也就是上面的回调函数，回调函数会返回一个读写是否就绪的掩码，根据这个掩码给fd_set赋值</li><li>如果遍历完fd_set后没有就绪的io设备，就挂起当前进程，直到有设备就绪或者主动超时的时候唤醒当前进程，重新遍历fd_set，判断有没有就绪的fd</li><li>如果有就绪的fd了，select立即返回，然后还要再去遍历一遍fd_set获得就绪的文件描述符，读取文件，这一步就是将fd_set由内核再拷贝到用户空间。</li></ul><h4 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h4><ul><li>select每次执行都要将fd集合由用户空间拷贝到内核空间，开销太大。</li><li>每次都是轮询整个fd集合，效率不好。</li><li>能一次管理的文件描述符有限1024个。</li></ul><h3 id="谈谈poll"><a href="#谈谈poll" class="headerlink" title="谈谈poll"></a>谈谈poll</h3><p>poll与select类似，解决了select的最后一个缺点就是数量限制，fd_set由数组修改为链表实现。</p><h3 id="谈谈epoll"><a href="#谈谈epoll" class="headerlink" title="谈谈epoll"></a>谈谈epoll</h3><p>epoll解决了select前两个缺点。将原先的一个函数拆分为3部分:</p><ul><li>调用epoll_create方法创建一个epoll对象</li><li>调用epoll_ctl向epoll对象中添加socket集合</li><li>调用epoll_wait等待事件发生</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这就是一个epoll对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span> &#123;</span><br><span class="line">　　...</span><br><span class="line">　　<span class="comment">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，</span></span><br><span class="line"><span class="comment">　　也就是这个epoll监控的事件*/</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;</span><br><span class="line">　　<span class="comment">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">list_head</span> rdllist;</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个事件都会包装成epitem节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> &#123;</span><br><span class="line">　　...</span><br><span class="line">　　<span class="comment">//红黑树节点</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;</span><br><span class="line">　　<span class="comment">//双向链表节点</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink;</span><br><span class="line">　　<span class="comment">//事件句柄等信息</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd;</span><br><span class="line">　　<span class="comment">//指向其所属的eventepoll对象</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line">　　<span class="comment">//期待的事件类型</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">　　...</span><br><span class="line">&#125;; <span class="comment">// 这里包含每一个事件对应着的信息。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><p>在调用epoll_create方法的时候，内核会构建一个eventpoll结构体，包含两个与epoll相关的成员:</p><ul><li>struct rb_root rbr 是构建红黑树的头节点，用于存储epoll_ctl传来的socket</li><li>struct list_head rdllist 是构建一个双向链表，保存epoll_wait返回给用户的、满足就绪条件的事件</li></ul><h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><p>epoll_ctl就是epoll的事件注册函数。用于将文件描述符的添加到epoll对象的红黑树中，这样的话，添加、删除、修改事件的时候从红黑树中寻找也非常有效率，然后向内核注册事件的回调函数，用于数据就绪中断发生的时候将事件节点添加到双端链表里面。这个方法在调用时会将所有的fd拷贝到内核空间，而不是在epoll_wait的时候重复拷贝，保证了整个过程中只拷贝一次。</p><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>epoll_wait就会遍历双链表里面有没有就绪的事件节点，不用再遍历所有的文件描述符集合，然后将这里面的事件复制到用户态内存的event数组中，然后将事件数量返回给用户，然后应用程序就可以遍历event数组，进行对应事件的读写操作。  </p><p>例子看看：   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; )</span><br><span class="line">&#123;</span><br><span class="line">    nfds = <span class="built_in">epoll_wait</span>(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(events[i].data.fd==listenfd) <span class="comment">//有新的连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            connfd = <span class="built_in">accept</span>(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class="comment">//accept这个连接</span></span><br><span class="line">            ev.data.fd=connfd;</span><br><span class="line">            ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class="comment">//将新的fd添加到epoll的监听队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events&amp;EPOLLIN ) <span class="comment">//接收到数据，读socket</span></span><br><span class="line">        &#123;</span><br><span class="line">            n = <span class="built_in">read</span>(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>    <span class="comment">//读</span></span><br><span class="line">            ev.data.ptr = md;     <span class="comment">//md为自定义类型，添加数据</span></span><br><span class="line">            ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class="comment">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">//有数据待发送，写socket</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class="comment">//取数据</span></span><br><span class="line">            sockfd = md-&gt;fd;</span><br><span class="line">            <span class="built_in">send</span>( sockfd, md-&gt;ptr, <span class="built_in">strlen</span>((<span class="type">char</span>*)md-&gt;ptr), <span class="number">0</span> );        <span class="comment">//发送数据</span></span><br><span class="line">            ev.data.fd=sockfd;</span><br><span class="line">            ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class="comment">//修改标识符，等待下一个循环时接收数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//其他的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说:<br>select/poll/epoll都是对linux里设备驱动的poll函数的封装，用来在注册事件的回调函数，并且将当前进程挂当对应设备驱动的等待队列上，由于会依次循环不同事件的poll函数，所以认为每一个事件如果没有就绪都会将进程添加到其等待队列里。</p><h5 id="水平触发与边缘触发"><a href="#水平触发与边缘触发" class="headerlink" title="水平触发与边缘触发"></a>水平触发与边缘触发</h5><p>因为读写操作是用户去做的，如果epoll_wait返回了就绪的读写事件，但是用户不去读写的话，就会面临一些问题，所以用下面两种模式来约束一下。</p><ul><li>水平触发模式 :只要这个文件描述的缓冲区数据没有读干净，那么每次epoll_wait都会返回读事件，提醒用户操作。</li><li>边缘触发模式 :当有io事件发生，如果是可读的，就必须将这个文件描述符一直读到空，否则下次不会返回余下的数据，会丢掉事件，但是数据遗留在缓冲区，所以如果读写操作不是非阻塞的，那么最后一次没有数据在就绪的时候就会阻塞住。</li></ul><h2 id="java中的网络io模型"><a href="#java中的网络io模型" class="headerlink" title="java中的网络io模型"></a>java中的网络io模型</h2><p>java中的io模型包括BIO、NIO、AIO三种。</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO是java中Socket的经典的网络编程模型，对于客户端而言就是在某时间去与服务端建立连接，在单线程下对于服务端而言包括下面步骤:</p><ul><li>socket.accept() 这里会阻塞住等待客户端的连接</li><li>socket.getIputStream().read(buffer) 这个方法就是一个阻塞式io，如果数据没有准备好（比如客户端由键盘输入数据，输入完成并发送到达之前，服务端都是阻塞的），这里会阻塞住等待。</li><li>接受到数据后处理，客户端断开连接</li></ul><p>可以看出，BIO在一次通信过程中会阻塞两次。<br>所以BIO要进行并发必须是一个io连接对应一个线程，所以BIO服务器的问题就是大量的连接建立但是又不发送消息长时间占用连接，会使服务器性能下降。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BIO 服务端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> newServerSocket(<span class="number">8080</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动并监听8080端口&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器正在等待连接...&quot;</span>);</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器已接收到连接请求...&quot;</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器正在等待数据...&quot;</span>);</span><br><span class="line">                socket.getInputStream().read(buffer);</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器已经接收到数据&quot;</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> newString(buffer);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到的数据:&quot;</span>+ content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BIO 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> newSocket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> newScanner(System.in);</span><br><span class="line">            message = sc.next();</span><br><span class="line">            socket.getOutputStream().write(message.getBytes());</span><br><span class="line">            socket.close();</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>jdk1.4开始引入了NIO类库，这里的NIO指的是New IO，NIO有标准输入输出NIO与网络编程NIO，主要使用Selector多路复用器来实现，windows通过select实现，linux通过epoll实现。</p><p>io是以字节流的方式处理数据，nio是以块的方式处理数据。<br>其中Buffer和Channel是标准NIO的核心对象，写数据或者读数据都要通过一个Channel对象，而Buffer比较类似于要发的数据的载体。在NIO中准备发送的数据要先放到Buffer中，Buffer通过Channel传递数据，然后再通过Buffer从Channel中读取数据，再从Buffer中取数据，最后清理Buffer。</p><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>Buffer是一个数组，通常是字节数组，但是也有其他基本数据类型的Buffer。<br>Buffer中使用几个变量来保存当前状态</p><ul><li>capacity 容量 缓冲区能容纳的元素数量</li><li>position 当前位置，指向的是下一次发生读取、写入操作的起始位置</li><li>limit 界限，指的是Buffer里有效数据结束以后的第一个索引的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//介绍完几个参数来看看方法flip，将limit设置为之前数据的最后一个，将position设置为0，意味着后面的操作从第一个数据开始，一直到所有有效数据结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clear 将postion置0，limit置为最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffer操作顺序:  </p><ul><li>写数据到Buffer</li><li>调用filp()方法，转换Buffer的模式</li><li>从Buffer中读数据</li><li>clear()或compact()，清理缓冲区，clear会清空所有数据，compact()会清除已经读过的数据。未读的数据会移动到缓冲区的起始位置，新写的数据跟在未读的数据后面</li></ul><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel是一个对象，用来读取和写入数据。</p><ul><li>Channel是双向的，可读可写</li><li>Channel具有异步操作的能力</li><li>Channel读写通过Buffer</li></ul><p>Channel对象主要有以下几种:</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel </li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileUseNIO</span><span class="params">(String src,String dst)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="comment">//声明源文件和目标文件</span></span><br><span class="line">            FileInputStream fi=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(src));</span><br><span class="line">            FileOutputStream fo=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(dst));</span><br><span class="line">            <span class="comment">//获得传输通道channel</span></span><br><span class="line">            FileChannel inChannel=fi.getChannel();</span><br><span class="line">            FileChannel outChannel=fo.getChannel();</span><br><span class="line">            <span class="comment">//获得容器buffer</span></span><br><span class="line">            ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">//判断是否读完文件</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">eof</span> <span class="operator">=</span>inChannel.read(buffer);</span><br><span class="line">                <span class="keyword">if</span>(eof==-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//重设一下buffer的position=0，limit=position</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">//开始写</span></span><br><span class="line">                outChannel.write(buffer);</span><br><span class="line">                <span class="comment">//写完要重置buffer，重设position=0,limit=capacity</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            inChannel.close();</span><br><span class="line">            outChannel.close();</span><br><span class="line">            fi.close();</span><br><span class="line">            fo.close();</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>Selector多路复用器提供了一种单线程管理多个连接的非阻塞io方法。将Channel与Channel事件一起注册到Selector中，使Selector监听这个Channel的这个事件。当事件发生select立即返回，并获得就绪事件的集合，在java中就绪事件使用SelectedKey包装，从key中获得Channel，并判断就绪的事件是什么来进行具体地操作。</p><p>Selector底层是调用linux的epoll 和poll方法来实现的，EPollArrayWrapper中封装了epoll的三个方法，有时间再看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看到SelectionKey里面关联了Channel、Selector、以及监听的事件、就绪的事件等。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SelectionKey</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">interestOps</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title function_">interestOps</span><span class="params">(<span class="type">int</span> ops)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">readyOps</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//监听读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//监听写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//监听connect操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//监听accept操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// -- Attachments --</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">Object</span> <span class="variable">attachment</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;SelectionKey,Object&gt;</span><br><span class="line">        attachmentUpdater = AtomicReferenceFieldUpdater.newUpdater(</span><br><span class="line">            SelectionKey.class, Object.class, <span class="string">&quot;attachment&quot;</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">attach</span><span class="params">(Object ob)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> attachmentUpdater.getAndSet(<span class="built_in">this</span>, ob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">attachment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> attachment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionKeyImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractSelectionKey</span> &#123;</span><br><span class="line">    <span class="comment">//SelectionKey关联的Channel</span></span><br><span class="line">    <span class="keyword">final</span> SelChImpl channel;</span><br><span class="line">    <span class="comment">//SelectionKey关联的Selector</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SelectorImpl selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">//关联的事件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> interestOps;</span><br><span class="line">    <span class="comment">//就绪的事件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> readyOps;</span><br><span class="line"></span><br><span class="line">    SelectionKeyImpl(SelChImpl var1, SelectorImpl var2) &#123;</span><br><span class="line">        <span class="built_in">this</span>.channel = var1;</span><br><span class="line">        <span class="built_in">this</span>.selector = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureValid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isValid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancelledKeyException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interestOps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensureValid();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.interestOps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改SelectionKey关联的事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> SelectionKey <span class="title function_">interestOps</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensureValid();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.nioInterestOps(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readyOps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensureValid();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.readyOps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nioReadyOps</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.readyOps = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nioReadyOps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.readyOps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SelectionKey <span class="title function_">nioInterestOps</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((var1 &amp; ~<span class="built_in">this</span>.channel().validOps()) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.channel.translateAndSetInterestOps(var1, <span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">this</span>.interestOps = var1;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nioInterestOps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.interestOps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        socketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ready</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (ready == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">accept</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    <span class="keyword">if</span> (accept == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    accept.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    accept.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 读事件</span></span><br><span class="line">                    deal((SocketChannel) key.channel(), key);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="comment">// 写事件</span></span><br><span class="line">                    resp((SocketChannel) key.channel(), key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注：处理完成后要从中移除掉</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selector.close();</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deal</span><span class="params">(SocketChannel channel, SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">responseBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            responseBuffer.put(buffer);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;socket close&quot;</span>);</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">        key.attach(responseBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resp</span><span class="params">(SocketChannel channel, SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        channel.write(buffer);</span><br><span class="line">        <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">            key.attach(<span class="literal">null</span>);</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nio的零拷贝"><a href="#nio的零拷贝" class="headerlink" title="nio的零拷贝"></a>nio的零拷贝</h4><ul><li>要等待dma将数据从硬件设备里面拷贝到</li></ul><p>要解释零拷贝，首先了解一下，普通的操作系统io数据拷贝过程:</p><ul><li>由磁盘/socket缓冲区将数据拷贝到内核空间缓冲区。(等待数据就绪) DMA</li><li>由内核缓冲区拷贝到应用程序的缓冲区。(读数据) cpu参与复制</li><li>由应用程序的缓冲区拷贝到内核缓冲区。(写数据) cpu参与复制</li><li>由内核缓冲区拷贝数据到硬盘/网络socket等io设备。DMA    </li></ul><p>可以看到数据流转过程中经过两次读/写，经过了两次内核态与用户态的切换，所以如果数据仅仅的简单的传输，可以使用零拷贝减少不必要的复制过程。</p><p>linux2.4以前 通过sendFile系统调用传送文件:</p><ul><li>通过 DMA copy 将数据从磁盘读取到 kernel buffer 中 </li><li>通过 CPU copy 将数据从 内核缓冲区 copy 到 sokcet的内核缓冲区 中</li><li>通过DMA 将socket内核缓冲区的数据拷贝到网卡设备中</li></ul><p>可见减少了内核态与用户态切换，减少了一次cpu的复制操作。</p><p>linux2.4及以后对 sendFile模式进行了改善:  </p><ul><li>通过DMA将网卡或者磁盘的数据拷贝到内核缓冲区中</li><li>CPU不再拷贝数据，而是将位于内核缓冲区的数据的位置和偏移量发给socket 的内核缓冲区  (这一步cpu不拷贝数据，只是把数据地址发给socket的内核)</li><li>DMA通过socket内核缓冲区里的数据在内核缓冲区里的内存地址的数据拷贝到网卡磁盘里</li></ul><p>这样就实现了零拷贝，CPU不再参与数据的拷贝，内核态与用户态之间的数据拷贝次数为0，两次拷贝数据通过DMA完成。</p><p>java.nio中通过Channel的transferTo方法实现,将数据由一个Channel传入到另一个可写的Channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferTo</span><span class="params">(<span class="type">long</span> position,<span class="type">long</span> count,WritableByteChannel target)</span>;</span><br></pre></td></tr></table></figure><p>最终依赖sendFile系统调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fileCopyWithFileChannel</span><span class="params">(File fromFile, File toFile)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannelInput</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannelOutput</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fromFile);</span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(toFile);</span><br><span class="line">            <span class="comment">//得到fileInputStream的文件通道</span></span><br><span class="line">            fileChannelInput = fileInputStream.getChannel();</span><br><span class="line">            <span class="comment">//得到fileOutputStream的文件通道</span></span><br><span class="line">            fileChannelOutput = fileOutputStream.getChannel();</span><br><span class="line">            <span class="comment">//将fileChannelInput通道的数据，写入到fileChannelOutput通道</span></span><br><span class="line">            fileChannelInput.transferTo(<span class="number">0</span>, fileChannelInput.size(), fileChannelOutput);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fileChannelInput != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileChannelInput.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fileOutputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fileChannelOutput != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileChannelOutput.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="nio的直接内存"><a href="#nio的直接内存" class="headerlink" title="nio的直接内存"></a>nio的直接内存</h4><p>DirectByteBuffer从内存中分配一段连续的内存，对内存的操作与普通Buffer没有区别，区别在于是使用Unsafe类native方法直接分配的堆外内存。那么堆外内存的释放也由Unsafe类的native方法完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意DirectByteBuffer继承了MappedByteBuffer内存映射的类，而普通的HeapBuffer没有实现内存映射的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectByteBuffer</span> <span class="keyword">extends</span> <span class="title class_">MappedByteBuffer</span> <span class="keyword">implements</span> <span class="title class_">DirectBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Bits.unsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> arrayBaseOffset;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> unaligned;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object att;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner cleaner;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h5 id="那么为什么要使用直接内存呢？"><a href="#那么为什么要使用直接内存呢？" class="headerlink" title="那么为什么要使用直接内存呢？"></a>那么为什么要使用直接内存呢？</h5><p>首先了解一下数据的拷贝过程，对于Channel的write方法都依赖于IOUtil的write方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="type">long</span> var2, NativeDispatcher var4)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//如果是DirectBuffer，直接写</span></span><br><span class="line">    <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> writeFromNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//非DirectBuffer</span></span><br><span class="line">        <span class="comment">//获取已经读取到的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> var1.position();</span><br><span class="line">        <span class="comment">//获取可以读到的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> var1.limit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> var5 &lt;= var6;</span><br><span class="line">        <span class="comment">//申请一个源buffer可读大小的DirectByteBuffer</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> var5 &lt;= var6 ? var6 - var5 : <span class="number">0</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">var8</span> <span class="operator">=</span> Util.getTemporaryDirectBuffer(var7);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> var10;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            var8.put(var1);</span><br><span class="line">            var8.flip();</span><br><span class="line">            var1.position(var5);</span><br><span class="line">            <span class="comment">//通过DirectBuffer写</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">var9</span> <span class="operator">=</span> writeFromNativeBuffer(var0, var8, var2, var4);</span><br><span class="line">            <span class="keyword">if</span> (var9 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                var1.position(var5 + var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var10 = var9;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//回收分配的DirectByteBuffer</span></span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(var8);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当Buffer是DirectBuffer时会直接调用writeFromNativeBuffer方法，当Buffer是HeapBuffer时会先申请一个直接内存，然后将堆内存拷贝到直接内存，然后在进行write操作系统调用。</p><h5 id="可以知道，nio在使用堆内存进行io操作之前会先拷贝到堆外内存，是为什么呢？"><a href="#可以知道，nio在使用堆内存进行io操作之前会先拷贝到堆外内存，是为什么呢？" class="headerlink" title="可以知道，nio在使用堆内存进行io操作之前会先拷贝到堆外内存，是为什么呢？"></a>可以知道，nio在使用堆内存进行io操作之前会先拷贝到堆外内存，是为什么呢？</h5><p>因为指向native方法的线程被认为是处于safepoint，可能会发生GC，导致堆内存重排。</p><p>传统的BIO的write方法数据使用字节数组传递，而NIO的write方法为了提高效率，数据仅仅通过内存地址传递，所以如果在native方法时发生了GC就会导致HeapBuffer的内存地址变化，因此要使用DirectBuffer来暂存保证内存地址不会被修改。</p><p>所以HeapBuffer数据拷贝的顺序应该是</p><blockquote><p>网络 –&gt; 临时的DirectByteBuffer –&gt; 应用 HeapByteBuffer –&gt; 临时的DirectByteBuffer –&gt; 网络</p></blockquote><p>如果直接使用DirectByteBuffer的数据拷贝顺序是</p><blockquote><p>网络 –&gt; 应用 DirectByteBuffer –&gt; 网络</p></blockquote><h5 id="申请堆外内存意味着java需要对这一块内存进行管理"><a href="#申请堆外内存意味着java需要对这一块内存进行管理" class="headerlink" title="申请堆外内存意味着java需要对这一块内存进行管理"></a>申请堆外内存意味着java需要对这一块内存进行管理</h5><p>DirectByteBuffer中使用Bits对象申请堆外内存，其中有一个变量totalCapacity记录已经分配的堆外内存的总大小，然后jvm通过-XX:MaxDirectMemorySize参数设置堆外内存的大小限制。</p><p>在DirectByteBuffer的构造方法里会预分配堆外内存，如果分配空间不足就会调用System.gc()方法来触发full gc期待能回收一点堆外内存，如果gc以后还是不足会抛OOM(因此如果堆外内存不够的话也是会抛OOM的),如果内存足够了就会使用Unsafe类去分配内存，返回内存基址。</p><h5 id="DirectByteBuffer的回收"><a href="#DirectByteBuffer的回收" class="headerlink" title="DirectByteBuffer的回收"></a>DirectByteBuffer的回收</h5><p>DirectByteBuffer是一个冰山对象，存在于堆里的对象DirectByteBuffer很小，包括内存基地址、大小等属性以及Cleaner对象用来做内存回收，但其指向了一大堆内存。</p><p>DirectByteBuffer对象的Cleaner对象实现了PhantomReference接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cleaner</span> <span class="keyword">extends</span> <span class="title class_">PhantomReference</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; dummyQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Cleaner</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Cleaner</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Cleaner</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable thunk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cleaner</span><span class="params">(Object var1, Runnable var2)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1, dummyQueue);</span><br><span class="line">        <span class="built_in">this</span>.thunk = var2;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.thunk.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                            (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.exit(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Cleaner实现了虚引用接口，其构造方法将DirectByteBuffer对象与虚引用队列传递给了父类，也就是给DirectByteBuffer对象加上了虚引用。当DirectByteBuffer对象被回收以后，就会将cleaner对象放到虚引用队列里面，然后使用一个ReferenceHandle线程处理这个队列，如果从队列里面取出了Cleaner对象就执行它的clean方法，执行trunk.run方法，这个trunk其实是Deallocator类实现了Runnable接口的嵌套类，其run方法会调用unsafe.freeMemory(long address)方法来释放堆外内存。</p><p>当然还有个问题就是，如果DirectByteBuffer对象经过几次Y gc进入了老年代以后很难回收掉，就会长期占用堆外内存。因此使用堆外内存要求手动回收。</p><h4 id="nio的内存映射"><a href="#nio的内存映射" class="headerlink" title="nio的内存映射"></a>nio的内存映射</h4><p>linux中使用mmap内存映射，将文件映射到应用程序的缓冲区，那么文件位于哪儿？文件描述符经由我们open系统调用后获得，自然是位于内核缓冲区，将位于内核空间的文件映射到应用程序缓冲区，减少了由内核空间到用户空间的数据拷贝，以及用户态与内核态的切换。</p><ul><li>发出mmap系统调用，导致用户空间到内核空间的上下文切换(第一次上下文切换)。通过DMA引擎将磁盘文件中的内容拷贝到内核空间缓冲区中(第一次拷贝: hard drive ——&gt; kernel buffer)。</li><li>mmap系统调用返回，导致内核空间到用户空间的上下文切换(第二次上下文切换)。接着用户空间和内核空间共享这个缓冲区，而不需要将数据从内核空间拷贝到用户空间。因为用户空间和内核空间共享了这个缓冲区数据，所以用户空间就可以像在操作自己缓冲区中数据一般操作这个由内核空间共享的缓冲区数据。</li><li>发出write系统调用，导致用户空间到内核空间的上下文切换(第三次上下文切换)。将数据从内核空间缓冲区拷贝到内核空间socket相关联的缓冲区(第二次拷贝: kernel buffer ——&gt; socket buffer)。</li><li>write系统调用返回，导致内核空间到用户空间的上下文切换(第四次上下文切换)。通过DMA引擎将内核空间socket缓冲区中的数据传递到协议引擎(第三次拷贝: socket buffer ——&gt; protocol engine)</li></ul><p>在java中使用FileChannel.map方法来将文件映射到MappedByteBuffer中，有三种模式:</p><ul><li>FileChannel.MapMode.READ_ONLY:产生只读缓冲区，对缓冲区的写入操作将导致ReadOnlyBufferException</li><li>FileChannel.MapMode.READ_WRITE:产生可写缓冲区，任何修改将在某个时刻由内核缓冲区写回到磁盘文件中，而这某个时刻是依赖OS的，其他映射同一个文件的程序可能不能立即看到这些修改，多个程序同时进行文件映射的确切行为是依赖于系统的，但是它是线程安全的</li><li>FileChannel.MapMode.PRIVATE:产生可写缓冲区，但任何修改是缓冲区私有的，不会回到文件中</li></ul><p>这种方式处理大文件很方便，避免了文件的拷贝，而且由于零拷贝无法修改数据，因此有数据修改需求的时候可以使用内存映射缓冲区来做，修改完的数据就是映射到的内核空间的数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点记录</title>
      <link href="/2020/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="数据成帧"><a href="#数据成帧" class="headerlink" title="数据成帧"></a>数据成帧</h3><p>链路层对数据封装成帧，给网络层传下来的分组添加首部尾部，标记为一个帧。</p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明传输传的是转义字符，为了避免数据帧与结束标识符相同，需要给数据帧中的结束标识符前面加上转移标识符，在取出数据的时候会消掉，因此是透明的</p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>循环冗余检验（CRC）来检查比特差错。</p><h3 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h3><h4 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h4><p>这种是一对多，同时有多个节点要使用广播信道，因此就要避免冲突。<br>避免冲突的方式有 信道复用技术 与 CSMA/CD协议 </p><h4 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h4><p>这种一对一通信，比较简单使用ppp协议进行控制</p><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><h4 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h4><p>不同节点主机 同时使用信道，但是占用不同的频率带宽资源。  </p><h4 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h4><p>不同节点主机 占用相同的频率带宽，但是占用不同的时间片</p><h4 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h4><p>以上两种都是提前规定了信道使用的方式，利用率很低。<br>这种 不固定不同主机使用时分复用帧的顺序或者位置，有数据来就集中起来组成统计时分复用帧发生。</p><h4 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h4><p>光的频分复用。对于光 常使用波长来表示光载波。  </p><h4 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h4><p>即给每个用户分配 m bit的码片，不同用户的码片相交 是等于0，那么m bit位组成一个串S就可以表示一个用户的 1 ，!S反码表示0。这样组成一个二进制串，是原串长度的m倍，接收的时候使用S对接收的数据进行内积运算，为0是其他用户的码片数据，为1就是我自己的比特数据1，为-1就是我自己的比特数据0.  </p><h3 id="CMSA-CD协议"><a href="#CMSA-CD协议" class="headerlink" title="CMSA/CD协议"></a>CMSA/CD协议</h3><p>载波监听、多点接入/碰撞检测</p><ul><li>载波监听： 每个主机不停地监听信道，发送前信道在使用就必须等待。</li><li>多点接入： 总线型网络，许多主机以多点的方式连接到总线上。</li><li>碰撞检测： 在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p>  PPP 的帧格式 顺序依次向下：</p><p>  F 字段为帧的定界符<br>  A 和 C 字段暂时没有意义<br>  上层使用协议<br>  信息部分的长度不超过 1500<br>  FCS 字段是使用 CRC 的检验序列<br>  F 字段为帧的定界符</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>以太网是一种星型拓扑结构局域网。</p><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><p>以太网帧格式：</p><p>类型 ：标记上层使用的协议；<br>数据 ：长度在 46-1500 之间，如果太小则需要填充；<br>FCS ：帧检验序列，使用的是 CRC 检验方法；</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p><p>接口指的是连接到交换机上的那一条线路的MAC地址。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="ip首部"><a href="#ip首部" class="headerlink" title="ip首部"></a>ip首部</h3><p>ip首部大小固定20字节:<br><strong>4位的版本号</strong>：有 4（IPv4）和 6（IPv6）两个值；<br><strong>4位的首部长度</strong>：最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。<br><strong>1个字节的区分服务</strong><br><strong>2个字节的首部加数据长度</strong><br><strong>2个字节的标识符</strong>：用来唯一标识一份数据报，每发送一个加1<br><strong>3位标志和13位片偏移</strong>：标志表明这些分组属于同一数据报，片偏移表示当前数据报数据首部位置位于总数据报数据段的位置，但是这里片偏移的单位是8字节，即真实的偏移量是1400字节的话，这个表里填175<br><strong>1个字节的生存时间</strong>：TTL,表示路由器跳数<br><strong>1个字节的协议字段</strong>：表示数据包上层移交给哪个协议<br><strong>2个字节的首部校验和</strong><br><strong>4个字节的源地址</strong><br><strong>4个字节的目的地址</strong></p><h3 id="ip地址编址方式"><a href="#ip地址编址方式" class="headerlink" title="ip地址编址方式"></a>ip地址编址方式</h3><ul><li>分类 A、B、C、D 四类</li><li>子网划分 </li><li>无分类 CIDR (网络前缀号+主机号)</li></ul><h3 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h3><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p>ARP 实现由 IP 地址得到 MAC 地址。</p><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><ol><li>Ping<br>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</li></ol><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><ol start="2"><li>Traceroute<br>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</li></ol><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><p>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；<br>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。<br>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。<br>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p><h3 id="VPN-虚拟专用网"><a href="#VPN-虚拟专用网" class="headerlink" title="VPN 虚拟专用网"></a>VPN 虚拟专用网</h3><p>指的是多个专用网络通过互联网作为各个网络间通信的载体，<br>比如我本地一台服务器要通过香港的服务器访问谷歌，中间要经过互联网传输，在出我本地专用网的时候的路由器R1会把我访问谷歌的ip包加密，然后包裹上香港专用网的路由器ip，经过互联网发送到香港服务器，然后进入香港专用网之前的路由器R2，给我删去头部，解密数据报，交付与谷歌进行通信。</p><p>虚拟隧道技术。</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p>路由器负责路由选择与分组转发。</p><h4 id="路由分组转发过程"><a href="#路由分组转发过程" class="headerlink" title="路由分组转发过程"></a>路由分组转发过程</h4><p>首先要了解路由表里存了些什么，目的网络(网络号)、下一跳ip(网关字段)(路由器的ip或者可以直接交付的目的主机ip)、目的网络的子网掩码、同局域网的交换机(网络号相同) 等等</p><ul><li>从数据报首部获得目的主机的ip地址，</li><li>然后用这个ip与各个条目的子网掩码相与得到网络号，</li><li>判断这个计算出来的网络号是不是等于下一跳的网络号，如果是的，交付给进入目标网络的路由器ip</li><li>如果不仅网络号相同，并且下一跳就是目标网络，那就直接交付目的主机ip</li><li>如果没有匹配的，路由表里还有目的网络、子网掩码全0 的默认路由，这条路由一定能匹中，能就将数据报交给网关去传。</li></ul><h4 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h4><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><p>自治系统内部的路由选择：RIP 和 OSPF<br>自治系统间的路由选择：BGP</p><ol><li>内部网关协议 RIP<br>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</li></ol><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><p>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；<br>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<br>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；<br>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。<br>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。<br>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><ol start="2"><li>内部网关协议 OSPF<br>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</li></ol><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF 就是dijkstra算法。</p><p>OSPF 具有以下特点：</p><p>每个路由器节点会向本自治系统中的所有路由器发送信息，这种方法是洪泛法。<br>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。<br>只有当链路状态发生变化时，路由器才会发送信息。<br>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><ol start="3"><li>外部网关协议 BGP<br>BGP（Border Gateway Protocol，边界网关协议）</li></ol><p>AS 之间的路由选择很困难，主要是由于：</p><p>互联网规模很大；<br>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；<br>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。<br>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层主要是UDP与TCP。</p><h3 id="介绍一下UDP。"><a href="#介绍一下UDP。" class="headerlink" title="介绍一下UDP。"></a>介绍一下UDP。</h3><p>用户数据报协议 是无连接的、尽最大努力交付、没有拥塞控制、而且是面向报文的即不拆分也不合并、支持一对一、一对多、多对多的交互通信方式。</p><h3 id="介绍一下TCP。"><a href="#介绍一下TCP。" class="headerlink" title="介绍一下TCP。"></a>介绍一下TCP。</h3><p>传输控制协议 是面向连接的，提供可靠交付，具有流量控制，拥塞控制，支持全双工通信，面向字节流的即能根据字节序号拆分合并数据块，只能点对点通信。</p><h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><p>UDP首部字段只有8个字节，源端口2字节，目的端口2字节，整个数据包的长度2字节，检验和2字节。</p><h3 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h3><p>与ip首部固定的大小相同为20字节。<br>2个字节的源端口，<br>2个字节的目的端口，<br>4个字节的序号，用于对字节流进行编号，序号为100表示第一个字节的编号为100，如果这个报文段长度为100，那么下一个报文段的序号就是200，<br>4个字节的确认号，期望收到的下一个报文段的序号，如果收到的报文段序号为100，长度为100，那么期望收到的下个报文段的序号就是200，<br>下面的数据占2字节:<br>4位数据偏移表示tcp首部的长度，<br>6位保留位，暂时没用<br>6个标志位:  </p><ul><li>URG : 当URG==1 表示高优先级数据，不按原来的顺序发送，插入到报文段数据最前面。</li><li>ACK : 确认号，用于建立连接时以及连接建立以后都得置1。</li><li>PSH : 当PSH==1 表示要求尽快交付的数据，接收端收到这个报文段以后立即交付，不用等缓存填满后再交付。</li><li>RST : 当RST==1 用来拒绝一个非法报文段或者拒绝一个连接。</li><li>SYN : 同步号，用来建立连接时同步序号，当SYN置1表示这是一个连接请求或者连接接受报文。</li><li>FIN : 当FIN==1 表示发送完毕，并且要求释放连接。</li></ul><p>2个字节的窗口，是接收方发给发送方的接收方一端数据缓存的大小限制。<br>2个字节的校验和，包括首部与数据范围。<br>2个字节的紧急指针，指出紧急数据末尾的字节数。<br>4个字节的选项。</p><h3 id="TCP粘包拆包"><a href="#TCP粘包拆包" class="headerlink" title="TCP粘包拆包"></a>TCP粘包拆包</h3><p>粘包指的是一个数据包中包含了两个数据包的情况，并且接收端不知道数据包的界限，所以对于接收端来说很难处理。</p><ol><li>要发送的数据大于TCP的缓冲区剩余大小，会发生拆包。</li><li>待发送数据大于MSS，TCP在传输前会拆包。</li><li>要发送的数据小于TCP缓冲区的大小，TCP就会多次写入缓冲区然后一次发送出去，这里会发生粘包。</li><li>接收数据端的应用层没有及时读取接收缓冲区的数据将发生粘包。</li></ol><p>解决方案：  </p><ol><li>在每一个数据包添加首部，在首部中包含一个数据包的长度，这样接收方收到以后通过读取首部字段就能知道。</li><li>发送端将数据包封装为固定长度，不够补0，接收端每次从接收缓冲区里面取固定长度即可</li><li>可以在数据包之间设置边界，特殊符号，通过匹配特殊符号来区分数据包。</li></ol><h3 id="Tcp报文大小"><a href="#Tcp报文大小" class="headerlink" title="Tcp报文大小"></a>Tcp报文大小</h3><p>MTU: Maxitum Transmission Unit 最大传输单元<br>MSS: Maxitum Segment Size 最大分段大小<br>在链路层的以太网协议中MTU的值为1500字节<br>所以减去ip层首部20个字节，减去tcp层首部20个字节，在以太网中TCP的MSS为1460字节大小。</p><h3 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h3><ul><li>A为客户端，B为服务端。</li><li>A向B发送请求连接的报文，SYN=1，ACK=0，选择一个初始的序号x。</li><li>B收到连接请求的报文，如果同意建立连接，则向A发送连接确认的报文，SYN=1,ACK=1,确认号为x+1，同时也选择一个初始的序号y。</li><li>A收到B的确认连接的报文后，向B发出确认报文，ACK=1,确认号为y+1，序号为x+1。</li><li>B收到A的确认报文后，连接正常建立。</li></ul><h4 id="为什么要进行第三次握手"><a href="#为什么要进行第三次握手" class="headerlink" title="为什么要进行第三次握手?"></a>为什么要进行第三次握手?</h4><p>第三次握手是为了防止失效的连接请求到达服务器以后，让服务器打开错误的连接，如果A发给B的请求连接报文在网络中阻塞了，A这边超时重传了一个与B建立了连接，如果没有第三次确认，服务器收到了两个请求连接的报文，打开了两个连接，如果有三次握手，客户端会忽略服务器对网络阻塞的那个报文的连接确认报文，不再进行第三次握手，不会再次开启连接。</p><h3 id="TCP四次挥手过程"><a href="#TCP四次挥手过程" class="headerlink" title="TCP四次挥手过程"></a>TCP四次挥手过程</h3><ul><li>A为客户端，B为服务端。</li><li>A向B发送连接释放报文，ACK=1，FIN=1，序号当前已经记录到u了。</li><li>B收到A的释放连接报文以后，B服务器这边的连接就半关闭状态（表示客户端没有数据要发了，但是服务器如果还有数据，仍然可以发给客户端接收），然后给A发送释放连接确认报文，ACK=1，序号记录到v了，确认号就是u+1</li><li>当B发完最后的数据以后，B向A发送连接释放报文，ACK=1，FIN=1，序号为w（服务器发完所有数据以后的），确认号为u+1（没变过），发送完后B就LAST_ACK状态，不会再发数据</li><li>A收到B的连接释放报文以后，发送确认报文，ACK=1，序号为u+1，确认号为w+1，之后客户端进入TIME_WAIT状态，等待2MSL（报文最大生命时间）以后，客户端关闭，而服务端在收到这个确认报文后就关闭了</li></ul><blockquote><p>如何尽快结束time wait状态？</p></blockquote><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手?"></a>为什么要四次挥手?</h4><p>如果仅仅进行三次挥手，就向握手一样，在客户端释放连接的确认报文中释放服务端的连接，会导致服务端有剩余的数据还没有发完，因此服务端连接释放请求拆分出来，等待数据传送完毕以后服务端主动发送连接释放报文。</p><h4 id="为什么要等待2MSL？"><a href="#为什么要等待2MSL？" class="headerlink" title="为什么要等待2MSL？"></a>为什么要等待2MSL？</h4><p>确保最后一个确认报文能到达服务器端，因为如果这个确认报文丢了，服务器端超时会重传FIN报文，如果客户端在2MSL时间里面再次收到了服务器端的FIN报文就会再次等待2MSL，如果2MSL时间里也没有再次收到FIN报文，客户端认为服务器端是收到确认报文了，因此关闭连接。<br>还一个作用是让本次连接的产生的所有报文段都从网络中消失。</p><h3 id="三次握手-四次挥手-实例图"><a href="#三次握手-四次挥手-实例图" class="headerlink" title="三次握手 四次挥手 实例图"></a>三次握手 四次挥手 实例图</h3><p><img src="%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%9B%BE.jpg" alt="三次握手四次挥手图"><br>前三次为握手过程，中间为数据传输加确认，最后四次为挥手过程。</p><h3 id="简单说一下TCP怎么保证可靠传输？"><a href="#简单说一下TCP怎么保证可靠传输？" class="headerlink" title="简单说一下TCP怎么保证可靠传输？"></a>简单说一下TCP怎么保证可靠传输？</h3><p>TCP的所有机制都是为了保证传输的可靠性。<br>1、校验和<br>2、序号+确认应答+滑动窗口  TCP基于字节流传输，因此每个数据都有自己的序号，接收方会按序接收<br>3、超时重传  TCP具有超时重传的策略，一个已经发送的报文段在超时时间内没有收到确认，就重传这个报文段。<br>4、流量控制<br>5、拥塞控制</p><h3 id="简单说一下TCP的滑动窗口？"><a href="#简单说一下TCP的滑动窗口？" class="headerlink" title="简单说一下TCP的滑动窗口？"></a>简单说一下TCP的滑动窗口？</h3><p>滑动窗口可以理解为发送方与接收方的缓存，发送方和接收方各有一个窗口，发送方的窗口根据接收方发来的TCP数据报里的窗口进行设置。<br>窗口的单位是字节，通过TCP的序号排列在窗口中，对于已经发送并确认的字节，窗口会右移直到第一个字节不是已发送并且已经确认的状态，<br>那么对于大小有限的窗口，其中包含的就是已发送未确认以及允许发送还没发的字节，<br>接收窗口左部的字节如果已经发送确认并交付主机，就右移直到未发送确认的字节，接收窗口会按序接收，并且只对最后一个连续的字节进行确认，<br>比如，接收窗口里从第一个字节开始序号依次是51、52、53、54、55…… 那么，如果接收到的序号是51、54、55，那么接收方只会对51进行确认。</p><p>发送方接收到的确认序号能保证，这个序号之前的字节都已经确认接收了。</p><h3 id="简单说一下流量控制？"><a href="#简单说一下流量控制？" class="headerlink" title="简单说一下流量控制？"></a>简单说一下流量控制？</h3><p>流量控制是为了控制发送方的发送速率，保证接收方能及时接收。<br>接收方通过确认报文里的TCP首部的窗口字段来控制发送方的的窗口大小。如果接收到的窗口大小为0，那么发送方就将停止发送数据。</p><h3 id="简单说一下拥塞控制？"><a href="#简单说一下拥塞控制？" class="headerlink" title="简单说一下拥塞控制？"></a>简单说一下拥塞控制？</h3><p>拥塞是网络状况出现问题分组可能丢失，需要控制发送方的速度，与流量控制很像，但是目的不一样，流量控制是为了接收方能及时接收发送方发来的数据，而拥塞控制是为了降低整个网络的拥塞情况。</p><p>TCP主要通过4个算法进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p>首先发送方维护一个叫拥塞窗口的变量cwnd，这只是一个状态变量，实际发送方能发多少数据取决于发送方的窗口。<br>首先假设没有发生流量控制，发送方窗口不会影响cwnd。<br>然后假设cwnd窗口的单位为报文段。</p><h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><blockquote><p>下面的轮次的意思是指当前cwnd大小的报文段全部被确认。</p></blockquote><p>发送刚开始cwnd窗口值为1，发送方只能发送一个报文段；当整个报文段都被确认以后，cwnd加倍，所以每个轮次的cwnd窗口值得报文段数据被确认以后，cwnd翻倍，依次为1、2、4、8……。<br>这样窗口会增长得特别快，当达到慢开始门限ssthresh，cwnd&gt;=ssthresh的时候就进入拥塞避免阶段，每轮次cwnd仅加1，如果出现了超时重传，就将慢开始门限设置为之前的一半ssthresh/2，然后重新cwnd=1开始慢开始阶段。</p><h4 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h4><p>快重传机制是对超时重传机制的一种补充。<br>接收方每次接收到报文段都应该对最后一个已收到的连续报文段发送确认报文段，比如已经收到了M1、M2与M4，那么最终能确认的是ACK=2，如果此时又收到了M5、M6那么都会发送ACK=2的确认报文，如果发送方连续三次收到了冗余的相同的确认报文，这里就是ACK=2的报文段。那么发送方认为下一个序号的报文段丢失了，即M3，就会立即重传M3。</p><p>如果只是这种情况丢失个别报文段，可以执行快恢复，将慢查询门限ssthresh设置为当前窗口值cwnd的一半，并将窗口值cwnd设置为当前门限值开始，直接进入拥塞避免状态。</p><p>慢启动指的是从cwnd=1开始，而快恢复指的是从ssthresh/2的位置开始。是指cwnd值的大小，不是窗口增长速率。</p><p>当发生网络拥塞时会判断是网络拥塞还是仅仅丢了几个包，如果确认是网络拥塞的话就慢启动，如果仅仅只是丢了几个包，采用快恢复。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>套接字 ip+port-&gt;ip+port  是一对。左边与右边一起唯一确认<br>192.168.1.121:22-&gt;192.168.1.122:80 是一个套接字，左边的的主机端口也可以重复使用<br>192.168.1.121:22-&gt;192.168.1.121:80 这样两个套接字可以同时存在与192.168.1.121这个主机里面，即便套接字右边的客户端使用了同一个端口</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="什么是DNS系统？"><a href="#什么是DNS系统？" class="headerlink" title="什么是DNS系统？"></a>什么是DNS系统？</h3><p>DNS是一个分布式数据库，提供域名与ip地址的相互转换的服务。每个站点只保存自己的一部分数据。域名系统具有层次结构，从上到下为根域名、顶级域名、二级域名。DNS系统使用UDP或者TCP进行传输，端口号都为53，大多数情况下使用UDP，因此要求域名服务器自己进行超时重传与可靠性保证。</p><ul><li>两种情况使用TCP，返回的数据超过512字节</li><li>区域传送，主域名服务器向辅助域名服务器同步变化的数据的时候。</li></ul><h3 id="FTP文件传输协议？"><a href="#FTP文件传输协议？" class="headerlink" title="FTP文件传输协议？"></a>FTP文件传输协议？</h3><p>使用TCP来建立连接，传输一个文件需要建立两个连接:</p><ul><li>控制连接: 由客户端主动建立连接，服务端打开21号端口等待客户端的连接，连接建立以后，使用这个连接将客户端的命令传输给服务器端，并传回服务器的应答。</li><li>数据连接: 有两种模式:<ul><li>由服务器端主动建立的连接，这个服务器端的端口号是20号端口，客户端端口号随机，必须大于1024。</li><li>服务器的被动模式，由客户端主动建立这个连接，客户端端口号自己指定，服务端端口号随机。</li></ul></li></ul><h3 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h3><p>这个协议提供了即插即用的联网方式，不需要手动配置ip等信息。<br>这个协议自动配置了ip地址、子网掩码、网关ip地址。<br>DHCP配置过程如下：</p><ul><li>由客户端主动发送Discover报文，目的地址是255.255.255.255:67是这个网段的广播地址，这个报文会使用UDP广播到子网的所有主机上面。如果客户端与DHCP服务器不在一个子网，还需要使用中继代理。</li><li>DHCP服务器收到这个Discover报文以后就会给客户端发送offer报文段给客户端，包含客户端需要的ip信息。由于可能有多个DHCP服务器发送给客户端，客户端会进行选择。</li><li>客户端选择某个DHCP服务器以后，发送Request报文。</li><li>DHCP服务器收到Request报文后回送ack报文，表示客户端此时可以使用它提供的信息。</li></ul><h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><h3 id="Web页面请求过程"><a href="#Web页面请求过程" class="headerlink" title="Web页面请求过程"></a>Web页面请求过程</h3><h4 id="使用DHCP为主机分配ip"><a href="#使用DHCP为主机分配ip" class="headerlink" title="使用DHCP为主机分配ip"></a>使用DHCP为主机分配ip</h4><h4 id="浏览器访问目标域名"><a href="#浏览器访问目标域名" class="headerlink" title="浏览器访问目标域名"></a>浏览器访问目标域名</h4><h4 id="向DNS域名解析系统查询域名的ip地址"><a href="#向DNS域名解析系统查询域名的ip地址" class="headerlink" title="向DNS域名解析系统查询域名的ip地址"></a>向DNS域名解析系统查询域名的ip地址</h4><h4 id="使用arp地址解析协议获取对应ip主机的mac地址"><a href="#使用arp地址解析协议获取对应ip主机的mac地址" class="headerlink" title="使用arp地址解析协议获取对应ip主机的mac地址"></a>使用arp地址解析协议获取对应ip主机的mac地址</h4><h4 id="三次握手建立TCP连接"><a href="#三次握手建立TCP连接" class="headerlink" title="三次握手建立TCP连接"></a>三次握手建立TCP连接</h4><h4 id="浏览器发送http请求给服务端"><a href="#浏览器发送http请求给服务端" class="headerlink" title="浏览器发送http请求给服务端"></a>浏览器发送http请求给服务端</h4><h4 id="服务端返回http响应给浏览器"><a href="#服务端返回http响应给浏览器" class="headerlink" title="服务端返回http响应给浏览器"></a>服务端返回http响应给浏览器</h4><h4 id="浏览器解析视图页面"><a href="#浏览器解析视图页面" class="headerlink" title="浏览器解析视图页面"></a>浏览器解析视图页面</h4><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>http是是应用层的无状态的超文本协议，基于tcp协议实现。</p><h4 id="http首部"><a href="#http首部" class="headerlink" title="http首部"></a>http首部</h4><p>http请求报文的http首部由 请求行 与 首部字段 组成：</p><ul><li>请求行包括 请求方法、URI、http版本</li><li>首部字段包括通用首部字段、请求首部字段、实体首部字段</li><li>请求首部字段：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Host、Connection（keep-alive）</li><li>通用首部字段：Allow（客户端能支持的所有方法）、Content-Type、Content-Length、Content-Encoding、Content-Language、Cookie、Cache-Control（缓存控制）</li></ul><p>http响应报文的http首部由 请求行 与 首部字段 组成：</p><ul><li>请求行包括 http版本、响应码</li><li>首部字段包括通用首部字段、响应首部字段、实体首部字段</li><li>Expires（指定缓存过期时间节点）、Set-Cookie、Location、Content-Type、Content-Length、Content-Encoding、Content-Language</li></ul><h4 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h4><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><p>通常用于请求获取服务器的资源</p><h5 id="post"><a href="#post" class="headerlink" title="post"></a>post</h5><p>用于向服务器发送数据</p><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p>用于向服务器修改数据</p><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p>用于请求服务器删除数据</p><h5 id="options"><a href="#options" class="headerlink" title="options"></a>options</h5><p>预请求，用于判断接下来的请求是否可行</p><h5 id="GET和POST的比较"><a href="#GET和POST的比较" class="headerlink" title="GET和POST的比较"></a>GET和POST的比较</h5><p>GET的参数以键值对的方式拼接在url后面，而POST的参数存储在报文正文里面。不能因为post的参数存储在实体里面就认为安全性能比GET高，在不加密的情况下POST的包仍然可以通过抓包获得。</p><p>由于url只支持ascii码，因此对于中文字符空格等进行百分号编码。而post实体参数支持标准字符集，现在一般是utf-8。<br>GET方法是幂等的安全的只读的，不会修改服务器状态，因此可以进行缓存，而POST不是，POST请求肯定是要求服务器做某件事情的，在不人为保证幂等的情况下，每次请求都是不同的，重复请求肯定会出问题的。</p><p>浏览器中的GET和POST和接口中的GET和POST是不一样的。</p><ul><li><p>浏览器中的GET请求可以理解为没有body，只有url，请求数据放在queryString中，POST都来自表单提交，数据都放在body里面，两种格式application/x-www-form-urlencoded、multipart/form-data。</p></li><li><p>接口中的GET请求和POST请求很自由，数据均可以放在head、queryString、body中，因此使用REST接口规范对GET、POST、PUT、DELETE进行了规定。</p></li></ul><h6 id="关于POST发两个请求吗？"><a href="#关于POST发两个请求吗？" class="headerlink" title="关于POST发两个请求吗？"></a>关于POST发两个请求吗？</h6><p>发两个请求是指先发请求头给服务端，根据返回结果如果是100 Continued继续发请求体，如果是4xx系列或者其他状态码就停止发送。</p><p>是一种优化策略，但不是一定的，也可以一次性发给服务端。</p><p>可以根据请求头部的鉴权信息决定是否继续发送请求体。</p><p>可以根据请求体的大小决定是否需要分开发。等等~</p><p><strong>XMLHttpRequest</strong>:<br>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p><p>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。<br>而 GET 方法 Header 和 Data 会一起发送。</p><h4 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h4><h5 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h5><p>100 表示目前为止正常，可以继续也可以忽略</p><h5 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h5><p>200系列均表示请求成功。</p><h5 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h5><p>300系列表示这个请求经过重定向，被分配了新的url。</p><h5 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h5><p>400系列表示客户端的错误。</p><ul><li>400表示报文格式语法不对。</li><li>401表示未鉴权，鉴权失败。</li><li>403表示请求资源被拒绝。</li><li>404表示资源没找到。</li><li>405表示请求超时。</li></ul><h5 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h5><p>500系列表示服务端的错误。</p><ul><li>500表示服务端执行时出错，npe或者代码bug</li><li>503表示服务未启动，或者服务挂了。</li></ul><h4 id="长连接与短链接"><a href="#长连接与短链接" class="headerlink" title="长连接与短链接"></a>长连接与短链接</h4><p>http 1.0版本是默认短连接支持长连接，短连接指的是一次请求响应以后就会断开tcp连接。<br>http 1.1版本是默认长连接支持短连接，长连接指的是建立一次tcp连接就能进行多次http通信。</p><h4 id="pipeling"><a href="#pipeling" class="headerlink" title="pipeling"></a>pipeling</h4><p>http 1.1支持的流水线方式，默认情况下即一次请求等到响应回来再进行下一次请求，由于受到网络延迟和带宽的影响，在下一个请求到来之前，可能需要等待很长时间，pipeline支持的是在一条tcp连接上面连续发出请求，不用等待响应返回，但是响应的接收仍然是按照请求顺序接收的。</p><h4 id="什么是Cookie-什么是session？区别？"><a href="#什么是Cookie-什么是session？区别？" class="headerlink" title="什么是Cookie? 什么是session？区别？"></a>什么是Cookie? 什么是session？区别？</h4><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>http协议是无状态的，为了能高效的处理事务所以没有复杂的设计，因此需要使用Cookie来保存状态信息。<br><strong>Cookie</strong>是第一次请求服务器时发送浏览器并保存在本地的一块数据，之后访问同一个服务器时每个请求都会被携带上。<br><strong>Cookie用途</strong>：   </p><ul><li>会话状态管理</li><li>个性化设置</li><li>浏览器行为追踪</li></ul><p>在第一次请求响应的头部会包含Set-Cookie字段，客户端浏览器把Cookie保存在浏览器中。之后的请求头部都会携带上Cookie字段，发送给服务器。</p><p><strong>有效期</strong>：<br>默认的Cookie当浏览器被关闭后会被自动删除，仅在会话期有效。如果指定了过期时间(Expires)或者有效期(max-age)后就能持久存在。</p><h5 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h5><p><strong>Session</strong>是在服务端用来记录会话状态标识具体用户的机制。存储在服务端的数据更安全，而且可以存储任意类型的数据，可以存储在服务器文件上、内存里、数据库里、redis中 等。</p><p>使用Session维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>对于极其安全的场景，不能仅仅使用Session维持登录状态，需要重新验证密码。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>Cookie只能存储Ascii码字符串，而Session可以存储任意类型数据。<br>Cookie存储在浏览器端，隐私安全数据不建议存储在Cookie中，如果一定要存储在Cookie中一定要进行加密。Session保存在服务端也更安全。</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h5 id="为什么要使用代理？"><a href="#为什么要使用代理？" class="headerlink" title="为什么要使用代理？"></a>为什么要使用代理？</h5><p>使用代理可以做哪些事情呢？一是作为缓存，在代理服务器上暂存网络资源。二是作负载均衡使用，代理服务器将请求以一定策略分发到不同的主机上面。三是作网络访问控制，将目标主机隐藏起来，或者访问内网的时候都经过代理服务器。四是访问日志记录。</p><h6 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h6><p>正向代理就是指由客户端经过代理服务器访问目标服务器的过程。举例就是浏览器不能直接访问谷歌，因此先人为指定一个代理服务器，由这个代理服务器访问谷歌，然后由代理服务器将访问结果返回给浏览器。</p><h6 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h6><p>反向代理是指在一个内网里面，代理服务器接受到来自互联网的请求，并将这个请求转发或者分发给内网中的其他服务器主机。</p><h4 id="https"><a href="#https" class="headerlink" title="https"></a>https</h4><h5 id="http面临的问题"><a href="#http面临的问题" class="headerlink" title="http面临的问题"></a>http面临的问题</h5><ul><li>http使用明文通信，内容可能被窃听。</li><li>通信方的身份不进行验证，有可能被伪装。</li><li>无法证明报文的内容完整性，内容有可能被修改。</li></ul><p>https是协议是指让http先和ssl通信，再让ssl和tcp通信。通过使用ssl，https具有了内容加密、身份认证、和内容完整性保护。</p><h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><h6 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h6><p>加密和解密使用同一密钥。优缺：运算速度快、无法安全的传输密钥。</p><h6 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h6><p>密钥分为公钥和私钥一对。<br>公钥所有人都可以获得，私钥并不在网络上传输。优缺：可以将公钥传输给对方，加密速度慢。</p><ul><li>可以使用发送方公钥加密，接受方私钥解密，保证加密文件传输的安全性。</li><li>可以使用发送方私钥加密，接受方公钥解密，这是数字签名技术，即使用发送者的公钥解密了发送者的私钥，说明认证了发送方。</li></ul><h6 id="https的加密"><a href="#https的加密" class="headerlink" title="https的加密"></a>https的加密</h6><p>https的加密同时使用了这两种加密技术。</p><ul><li>对于数据的加密使用对称加密方式SecretKey进行通信保证效率。</li><li>对于数据对称加密的密钥SecretKey采用非对称加密的方式，保证安全性。</li></ul><p>以上解决了数据加密、以及内容篡改的问题，但是对于身份认证，需要一个中立机构来签发证书，证明公钥。</p><p>https ssl通道建立的过程：  </p><ul><li><p>在使用HTTPS是需要保证服务端配置正确了对应的安全证书</p></li><li><p>客户端发送请求到服务端</p></li><li><p>服务端返回公钥和证书到客户端</p></li><li><p>客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端</p></li><li><p>服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做私钥对需要发送的数据进行对称加密</p></li><li><p>客户端在接收到加密后的数据使用私钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户</p></li><li><p>SSL加密建立</p></li></ul><h5 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h5><p>CA（Cerficate Authority）数字证书认证机构是客户端与服务端都信任的第三方机构。</p><ul><li>服务器向CA提交公钥申请，CA认证完服务器的身份以后就会使用CA的私钥对这个服务器的公钥进行数字签名，将签名完以后的公钥与服务器证书绑定在一起。</li><li>那么浏览器在与服务器进行https通信之前，会先与CA进行https通信获得，使用CA的公钥解密服务器的公钥，以保证安全获得对应服务器的公钥。</li><li>然后与服务器进行https通信，拿着服务器的公钥解密数据对称加密的密钥SecretKey进行解密，获得解密后的SecrtKey，然后对数据进行解密。</li></ul><h5 id="https缺点"><a href="#https缺点" class="headerlink" title="https缺点"></a>https缺点</h5><ul><li>加密解密影响效率</li><li>CA认证费用高昂</li></ul><h4 id="http版本问题"><a href="#http版本问题" class="headerlink" title="http版本问题"></a>http版本问题</h4><h5 id="http1-x缺陷"><a href="#http1-x缺陷" class="headerlink" title="http1.x缺陷"></a>http1.x缺陷</h5><ul><li>客户端需要同时建立多个连接才能实现并发</li><li>不压缩请求和响应首部，浪费网络流量</li><li>不支持资源优先级，tcp利用率不高</li></ul><h5 id="http1-1新特性"><a href="#http1-1新特性" class="headerlink" title="http1.1新特性"></a>http1.1新特性</h5><ul><li>默认长连接</li><li>支持流水线方式</li><li>支持同时打开多个tcp连接</li><li>新增缓存处理指令cache-control max-age </li><li>支持虚拟主机</li><li>新增状态码 100</li><li>支持分块传输编码</li></ul><h5 id="http2-0介绍"><a href="#http2-0介绍" class="headerlink" title="http2.0介绍"></a>http2.0介绍</h5><blockquote><p>http2.0比1.x多了什么特性，首先http2.0支持首部压缩，减少网络流量损耗，将首部字段同时存在客户端与服务端，没有修改就不携带，压缩之后的首部使用二进制帧形式，分为header帧与data帧，同一个http请求的两个帧首部具有相同的stream标识符，这样就可以实现一个tcp连接交错发送http请求与接收响应，最后只需要根据帧头标识符组装即可。</p></blockquote><h6 id="二进制帧"><a href="#二进制帧" class="headerlink" title="二进制帧"></a>二进制帧</h6><p>于http1.x的文本字符消息的报文不同，http2.0将报文分为HEADERS帧和DATA帧，里面存储的是压缩过的原数据，它们都是二进制帧的形式，对于不同的帧格式他们的首部9个字节是相同的，用于标识一个帧。<br>在通信过程中只有一个tcp连接，但是可以同时进行多条双向数据流Stream，假定一次请求和响应为一条数据流，具有唯一数据流标识和优先级信息</p><p>这样不同数据流的帧就可以交错发送，然后根据帧头的数据流标识重新组装，这也是http2.0能实现多路复用的前提，打破了一个请求等待一个响应的相对顺序。</p><h6 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h6><p>浏览器在请求一个资源的时候，http2.0会将相关资源一并返回给客户端。</p><h6 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h6><ul><li>http2.0要求客户端和服务端对首部字段同时维护一个字段表，如果字段更新了就添加到首部，如果没有更新就读取本地存储的。</li><li>http2.0使用huffman编码对首部字段进行压缩。  </li></ul><h3 id="css攻击"><a href="#css攻击" class="headerlink" title="css攻击"></a>css攻击</h3><p>css攻击又称为xss攻击，指的是一种代码注入攻击，分为反射型xss攻击、存储型xss攻击、dom型xss攻击。  </p><p>反射型xss:  </p><p>攻击者构造出一个特殊的包含恶意代码拼接在url后面，然后诱骗用户点击这个url，如果网站本身会回显用户输入的内容的话，那么这就是个漏洞，诱骗用户的url里面是一串js脚本，当目标网站回显的时候就会执行这段脚本，可以获得用户的敏感信息。cookie、SessionId等 。</p><p>存储型xss:<br>就是将一段恶意脚本调服务端接口先存入到数据库中，其他用户如果访问到了这条数据被查询到html页面中，就有可能被执行恶意操作。比如以用户的cookie发送到攻击者制作的网站，就能获得用户的cookie。</p><p>后端对入库的特殊字符进行转义编码或者过滤。</p><p>dom型xss:<br>dom型主要是恶意代码利用js操作页面的dom节点，获取用户数据。</p><h3 id="csrf攻击"><a href="#csrf攻击" class="headerlink" title="csrf攻击"></a>csrf攻击</h3><p>跨站请求攻击<br>就是用户在持有安全网站的cookie的时候，点击了危险网站，危险网站悄悄地去访问安全网站，这时候是带上了浏览器本地地cookie的，危险网站的请求就能成功。</p><p>提前下发一个加密的Token，在访问安全网站的时候都带上这个token，或者放到header里面，访问其他网站的时候就无法获取这个token</p><h3 id="Ddos攻击"><a href="#Ddos攻击" class="headerlink" title="Ddos攻击"></a>Ddos攻击</h3><p>分布式的拒绝服务攻击。<br>就是拒绝服务攻击，占着茅坑不拉屎。</p><p>但是由于ip地址各不相同，且短时间大量不同的ip同时请求</p><ul><li>限流</li><li>ip黑名单</li><li>带宽扩容<ul><li>增加服务器数量，提高请求处理能力，流量分发到不同服务器</li></ul></li><li>CDN网络，就近访问<ul><li>只有CDN服务器没有的资源才会请求</li></ul></li></ul><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>在https中尽管数据被加密，对方身份被验证，但是东西多了，还是存在中间人攻击。</p><p>指的是https的通信双方，还存在一个中间人，中间人给https两端传输 从加密到数据通信 的全过程。</p><p>这里面可以找出的漏洞在证书。</p><p>1、如果一个证书没有被CA机构认证，就可以做成一个中间人。<br>2、某些应用可以在浏览器本地埋一些证书，导致我不再向CA机构认证证书的身份。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS原理详解</title>
      <link href="/2020/07/04/AQS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/07/04/AQS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS原理-源码详解"><a href="#AQS原理-源码详解" class="headerlink" title="AQS原理/源码详解"></a>AQS原理/源码详解</h1><p>AQS全称为AbstractQueuedSynchronizeder（抽象队列同步器），juc包中Lock、CountDownLatch、CyclicBarrier、Phaser、Exchanger等线程同步工具都是基于AQS实现的。</p><p>AQS的基本思想是 如果共享资源是空闲的，那么将当前请求资源的线程设定为获得这个资源的有效线程，将共享资源设置为锁定的状态不能被其他线程访问，这时候新来的线程发现这个资源处于占用的状态，无法获得使用资源的锁，就将这些线程阻塞并加入到队列中等待。</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>AQS中定义了一个Node静态内部类，维护双向的fifo链表。包装需要阻塞的线程进入队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">/** 表示这个节点在等待的锁是共享的模式 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">/** 表示这个节点等待的锁是独占的模式 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 表示取消状态，可以理解为线程失效了 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 此节点状态为SIGNAL表示他的next节点可以被唤醒  */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 表示这个节点的线程是从condition里的单向等待队列移出来的，也是可以唤醒的节点，根据后面代码的操作，不能唤醒额节点为 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个状态用于共享模式，解释待定稍等一下啊</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">     *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">     *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">     *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">     *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">     *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">     *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">     *               on failure, block.</span></span><br><span class="line"><span class="comment">     *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">     *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">     *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">     *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">     *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">     *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">     *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">     *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">     *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">     *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">     *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">     *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">     *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">     *               since intervened.</span></span><br><span class="line"><span class="comment">     *   0:          None of the above</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">     * Non-negative values mean that a node doesn&#x27;t need to</span></span><br><span class="line"><span class="comment">     * signal. So, most code doesn&#x27;t need to check for particular</span></span><br><span class="line"><span class="comment">     * values, just for sign.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">     * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">     * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment">     * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment">     * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment">     * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment">     * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment">     * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment">     * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment">     * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment">     * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment">     * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment">     * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment">     * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment">     * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment">     * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment">     * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment">     * to be null, we can scan prev&#x27;s from the tail to</span></span><br><span class="line"><span class="comment">     * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment">     * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment">     * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">     * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">     * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">     * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">     * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">     * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">     * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">     * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">     * mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">     * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">     * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还包括双向同步队列的头指针尾指针和state同步状态，以及对state进行原子性更新的cas操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment"> * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment"> * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment"> * CANCELLED.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment"> * method enq to add new wait node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="独占锁的获取"><a href="#独占锁的获取" class="headerlink" title="独占锁的获取"></a>独占锁的获取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法用于获取一个独占锁，首先尝试获取一下锁，如果获取失败就会调用 <kbc>addWaiter</kbc> 方法添加到线程到同步队列的末尾，然后通过 <kbc>acquireQueued</kbc> 方法再次尝试加锁，以及判断是否应该中断线程。</p><p><kbc>tryAcquire</kbc>为模板方法，其操作由其子类去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">//队尾节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//通过cas操作，将队尾节点设置为node，注意这里仅仅进行了一次cas，如果其尾节点已经被修改了，这里的cas操作就会失败。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果尾节点为空，或者上面cas操作失败了，就接下来继续进行循环的cas操作，直到入队成功</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="comment">//这里紧接着就把当前线程的node返回出去了</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//循环着的cas操作，设置尾节点或者在尾节点插入当前节点，如果失败了就重新获得尾节点再插直到成功。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上面分析可知，新来的线程如果获得state失败，就会通过自旋的方式插入同步队列的末尾。</p><p>下面接着分析<kbc>acquireQueued</kbc>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//又见一个自旋操作，自旋的设置为头节点，如果不成功就阻塞掉</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//首先获得前置节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//在同步队列中，头部节点是正在占用资源的节点，能够获得资源的节点必须是头部节点的下一个节点  </span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果上面的操作失败，就判断是否应该阻塞当前线程node，如果前一个节点的waitStatus状态为SIGNAL，则阻塞，如果前一个节点waitStatus没有初始化，则改为SIGNAL</span></span><br><span class="line">            <span class="comment">//parkAndCheckInterrupt()阻塞当前线程，并检查是否中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">//一旦当前线程node的前置节点设置为SIGNAL，直接返回true，要注意上面那个方法 shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt() 这个连接结构，如果前面的方法返回为true了，后面的才会执行</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 过滤掉CANCELED状态的node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 又是一个cas操作，通过外层循环，不断设置前置节点的状态为SIGNAL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果shouldParkAfterFailedAcquire成功设置前一个节点为SIGNAL状态以后，就阻塞当前线程，并检查是否中断</span></span><br><span class="line"><span class="comment">//因为只有当前一个节点为SIGNAL状态后才表明后一个节点可以被唤醒，才能将后一个节点阻塞，不一定立即被唤醒，比较队列前面也可能有很多阻塞节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上解释了AQS的独占模式的获取state。</p><h2 id="独占锁的释放"><a href="#独占锁的释放" class="headerlink" title="独占锁的释放"></a>独占锁的释放</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//调用tryRelease释放资源，释放成功就state-arg，然后就LockSupport.unpark头节点的下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">//首先cas将当前节点waitStatus初始化为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">//考虑异常情况，找到head的下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒这个节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryRelease方法也是模板方法，要求子类实现。</p><p><strong>release方法总结</strong>：线程资源释放调用release方法，使用tryRelease尝试释放资源，如果成功将state-1，再调用AQS的父类AbstractOwnableSynchronizer设置独占线程为null，再使用LockSupport.unpark头节点的next节点。</p><h2 id="共享锁的获取与释放"><a href="#共享锁的获取与释放" class="headerlink" title="共享锁的获取与释放"></a>共享锁的获取与释放</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//模板方法要求子类实现，尝试获得共享资源 小于0表示失败，0表示成功但是没有剩余资源，大于0表示成功还有剩余资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//在同步队列尾添加共享模式节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//如果前置节点是头节点，占用资源的线程，那么当前节点可能被唤醒，因此再次尝试获取资源</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//成功以后设置为头节点，资源有剩余的情况下唤醒下一个节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里的方法与独占模式相同，如果没有获得资源就将前置节点状态设为SIGNAL表明下一个节点可唤醒，然后阻塞当前线程，同时判断是否需要中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//除了设置为头节点以为，如果还有剩余资源，或者头节点为SIGNAL状态</span></span><br><span class="line">    <span class="comment">//这里的语义是 资源有剩余 || h(旧头节点)为空 || h(旧头节点)状态&lt;0 || 赋值为新到head，且新head为空 || 新head状态&lt;0</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以知道，与独占模式的区别在于当前节点设为头节点的时候，如果有剩余资源会继续唤醒线程doReleaseShared。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//模板方法，尝试释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 作用总的来说是不断唤醒下一个节点，可以唤醒多余的节点（没有获取资源就又park掉），但是不能主动让唤醒链断掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//初始化头节点的waitStatus状态</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//这个方法是unpark h.next节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里的操作是 如果后继节点还没有将head设置为SIGNAL，表示可能无需唤醒后继节点或者还没有加入后继节点，将其设置为PROPAGATE，用意是为了防止唤醒hang住。     </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是唤醒当前头节点的下一个节点，然后在setHeadAndPropagate方法中设置新头。</p><p>其中有一个没有显式使用的状态 <strong>PROPAGATE</strong> 需要重点关注下， 首先关注上述唤醒下一个节点的操作，这里有两个操作，一个是SIGNAL状态那就直接唤醒下一个节点，还一个如果是初始化状态就设置为PROPAGATE状态，然后如果head被改过了就重来一遍，然后结束。</p><p>第一个操作好理解，问题是第二个操作的用意是什么，为什么要将0状态的head改为PROPAGATE状态，要知道上面的操作还将SIGNAL初始化成0了，为什么呢？</p><p>因为首先要考虑被唤醒以后的操作，在doAcquiredShare方法里park位置被唤醒，然后判断前置节点是父节点就尝试获取锁，（如果不成功就又被park不考虑）如果成功了，就setHeadAndPropagate，这个方法除了设置新头节点外，有下面这个判断条件决定是否唤醒下一个节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">    (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">        doReleaseShared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中资源大于0自然可以唤醒下一个，旧头等于空也尝试唤醒（虽然很可能没有回收），旧头的waitStatus状态小于0也尝试唤醒，新头为空尝试唤醒（可能很小），新头waitStatus小于0尝试唤醒，重点关注下这俩waitStatus。</p><p>根据这篇博文的叙述<a href="https://www.cnblogs.com/lqlqlq/p/12991275.html">AQS中Propagate的作用解释</a>。</p><p>当前队列唤醒一个节点A以后，其waitStatus状态未被修改，为0，那么A执行尝试获取资源成功，修改头节点，在执行到上述if语句的的时候，新来一个线程node B加入队列，B尝试获取资源失败，执行shouldParkAfterFailedAcquire方法之前，A判断if propagate==0 || (old)h!=null || (old)h.ws==0 (唤醒下个节点前会设置成0)|| (new)h!=null ||(new)h.ws==0  然后就判断失败了，不继续唤醒下一个节点，然后B执行shouldParkAfterFailedAcquire完成设置前置节点的状态，此时B不再被唤醒。</p><p>说实话，如果仅仅是因为这个原因，感觉没有PROPAGATE，问题也不严重，这个问题待定。</p><h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionObject</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>condition内部维护的第一条单向链表的头尾节点。</p><h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">//把当前线程封装成node节点加入condition单向列表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">//这个方法会调用AQS的release方法，释放同步资源，然后唤醒同步队列头节点的下一个节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里是判断当前node是不是在AQS的同步队列里，如果不在，堵塞线程。</span></span><br><span class="line">        <span class="comment">//这里之所以循环就是 当signal还没有将节点移到同步队列上时，即使唤醒了仍然阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">//这里就是condition等待队列阻塞的位置</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">//这里是唤醒以后检查中断标志</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是被从condition队列里唤醒以后，再在同步队列里等待获取资源</span></span><br><span class="line">        <span class="comment">//再次尝试给node获取同步资源，如果不成，将node park</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法很明确，就是将线程封装成node添加到单向队列尾</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//传进来的node是当前线程node</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得同步状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">//调用AQS的release释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//如果释放失败的话，就会将当前node置为canceled状态</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法也很明确吖，就是判断这个node在不在AQS同步队列里</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">     * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">     * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">     * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">     * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">     * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>await</strong> 方法总结：调用condition.await()方法，意味着当前线程进入等待状态。将当前节点包装成node节点，放入condition链表的尾部。然后调用AQS的release方法，释放state，locksupport.unpack()双向node链表的头结点线程。之后，再将自身线程堵塞。</p><h3 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//这里是将first的下一个等待队列节点置空</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//下面这个transfer方法就是将当前node即等待队列第一个节点移动到AQS同步队列的末尾，同时修改ws状态</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//cas操作将当前node状态设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过自旋将node添加到同步队列末尾,返回前置节点，设置前置节点的状态为SIGNAL</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时简单看一下signalAll里面的方法，就是遍历condition的等待队列，全部移动到AQS的同步对列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>signal</strong>方法总结：signal就是将condition的等待队列的第一个node移动到AQS的同步队列中同时修改ws状态，signalAll就是将condition的等待队列所有node移动到AQS的同步队列中同时修改ws状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> aqs </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池原理详解</title>
      <link href="/2020/07/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/07/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池的原理详解"><a href="#线程池的原理详解" class="headerlink" title="线程池的原理详解"></a>线程池的原理详解</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>线程池是由任务队列和工作线程组成，可以重用线程来避免线程创建的开销，在任务过多时，通过排队来避免创建过多的线程，来减少系统资源的消耗和竞争，确保任务有序完成。</p><h2 id="线程池的构成"><a href="#线程池的构成" class="headerlink" title="线程池的构成"></a>线程池的构成</h2><p><strong>ExecutorService</strong>是真正的线程池接口。</p><p><strong>Executors</strong>是java提供的生产线程池的静态工厂，生产各种线程池实例。</p><p><strong>Executor</strong>是线程池的顶级接口，用来执行线程，通过execute方法。</p><p><strong>AbstractExecutorService</strong>实现了ExecutorService接口的部分方法，为抽象类。</p><p><strong>ThreadPoolExecutor</strong>继承了AbstractExecutorService，实现了ExecutorService的接口。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPoolExecutor参数最全的一个构造类，来一一记录</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>corePoolSize</strong> 这是核心池的大小，默认是没有线程，有任务到来则创建线程分配给任务，（除非预创建线程，默认情况下为0），当线程池中线程数量达到corePoolSize，就会把后来的任务放到缓存队列里。<br><strong>maximunPoolSize</strong> 线程池的最大的线程数量，指线程池中最多只能有这么些个线程。<br><strong>keepAliveTime</strong> 表示空闲线程没有任务执行时最多能存活的时间。默认情况下，这个参数只针对大于corePoolSize数量的线程，空闲超过了这个时间就会终止。调用allowCoreThreadTimeOut(boolean)方法以后就会对所有线程起作用。<br><strong>unit</strong> keepAliveTime的单位。<br><strong>threadFactory</strong> 线程工厂，主要用来生成线程对象，实现newThread方法即可。<br><strong>workQueue</strong> 阻塞队列，存储等待执行的任务，后面来讲不同的阻塞队列。<br><strong>handler</strong> 当新的任务数量大于maxiumPoolSize的时候的任务的处理策略。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出，RejectedExecutionException异常，默认是这个。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure><h2 id="java提供的默认实现"><a href="#java提供的默认实现" class="headerlink" title="java提供的默认实现"></a>java提供的默认实现</h2><ol><li><strong>newFixedThreadPool</strong><br>固定线程池，核心线程数目与最大线程数目相同，空闲存活时间为0ms，无法发挥作用，工作队列为Integer.MAX_VALUE大小的阻塞队列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>newCachedThreadPool</strong><br>缓存线程池，核心线程数为0，最大线程数为Integer.MAX_VALUE，空闲线程存活时间60s，工作队列SynchronousQueue这个队列是一个单任务就同步阻塞的队列，但是由于最大线程数这里可以理解为无限，即我提交一个任务不用阻塞等待被消耗，因为立即就有线程来消耗（包括线程池里现存的或者新创建一个），所以这个线程池要注意线程数量如果过多，很容易OOM。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>newSingleThreadExecutor</strong><br>单线程线程池，核心线程数与最大线程数都是1，空闲存活时间这个参数没有效果，如果任务数量超过了1就只能入对等待。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>newScheduledThreadPool</strong><br>调度线程池，按一定的周期执行任务，定时任务，其实仍然是ThreadPoolExecutor，采用的队列是DelayedWorkQueue是一个优先级队列。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>newWorkStealingPool</strong><br>这是jdk1.8新增的一种线程池，是基于ForkJoinPool实现的一种可抢占式的线程池，即某一个线程处理的任务比较耗时，其他空闲线程从这个耗时的线程任务队列中偷取任务进行处理，这个线程池与ThreadPoolExecutor系列线程池是兄弟关系，其父类为AbstractExecutorService。能合理地使用cpu进行耗时地并行操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">        (parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor源码详解"><a href="#ThreadPoolExecutor源码详解" class="headerlink" title="ThreadPoolExecutor源码详解"></a>ThreadPoolExecutor源码详解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来标记线程池状态(高三位)，线程个数(低29位)，默认RUNNING状态，线程个数0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//Integer的二进制位数-3，指的是表示线程个数的位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//线程最大个数为(2^29)-1个 00011111 11111111 11111111 11111111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池状态</span></span><br><span class="line"><span class="comment">//RUNNING 11100000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//SHUTDOWN 00000000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//STOP 00100000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//TIDYING 01000000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//TERMINATED 01100000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得 ctl 的高三位，即线程状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//获得ctl 的低29位，即线程个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//将高三位的状态与低29位的个数相或，计算一个新的ctl值出来。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h3 id="线程池状态及转换"><a href="#线程池状态及转换" class="headerlink" title="线程池状态及转换"></a>线程池状态及转换</h3><p><strong>RUNNING</strong>  :接受新任务，并处理阻塞队列的任务<br><strong>SHUTDOWN</strong> :拒绝新任务，但是处理阻塞队列的任务<br><strong>STOP</strong>     :拒绝新任务，抛弃阻塞队列的任务，中断正在处理的任务<br><strong>TIDYING</strong>  :所有任务都结束，阻塞队列里也没有任务时所处的状态，将要调用terminated方法<br><strong>TERMINATED</strong>:终止状态，terminated方法调用完后的状态</p><p><strong>RUNNING</strong> -&gt; <strong>SHUTDOWN</strong> :显式调用shutdown()方法，隐式调用finalize()方法<br><strong>RUNNING</strong> OR <strong>SHUTDOWN</strong> -&gt; <strong>STOP</strong> :调用shutdownNow()方法以后<br><strong>SHUTDOWN</strong> OR <strong>STOP</strong> -&gt; <strong>TIDYING</strong> :当线程池中没有存活的线程以后。<br><strong>TIDYING</strong> -&gt; <strong>TERMINATED</strong> :当terminated()方法执行完成以后  </p><h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="comment">//任务为空，则抛出NPE</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">//获得ctl ctl表示线程状态与线程个数的组合</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//如果线程个数小于核心线程数，则新开线程执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果线程数目大于核心线程数以后，就将任务入阻塞对列</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">//重新获得ctl</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="comment">//判断如果线程状态不是RUNNING就移除新任务</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                <span class="comment">//执行拒绝策略</span></span><br><span class="line">                reject(command);</span><br><span class="line">                    <span class="comment">//如果线程池状态OK的，判断线程池里线程数目为0，就再添加一个线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">//上面的操作失败了说明阻塞队列满了，下面就新开线程执行，如果也失败了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">            <span class="comment">//就只能执行拒绝策略了</span></span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，线程池处理任务的逻辑与大佬们整理的流程是一样的。<br>做下总结：调用execute()方法以后，如果工作线程数目小于核心线程数，则新建线程并开启线程执行，如果比核心线程数要大，就添加任务进阻塞队列等待，如果阻塞队列加满了，则新建工作线程执行任务，直到大于最大线程数就只能执行拒绝策略了。</p><p>接下来看看新增线程的操作。</p><h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获得ctl</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//线程池的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//非RUNNING的其他状态时（rs&gt;=0） 或者</span></span><br><span class="line">        <span class="comment">//SHUTDOWN状态并且有第一个任务 或者</span></span><br><span class="line">        <span class="comment">//SHUTDOWN状态并且阻塞队列为空</span></span><br><span class="line">        <span class="comment">//以上情况返回false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//线程数目</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">//线程数目大于CAPACITY 或者</span></span><br><span class="line">            <span class="comment">//core为true时  线程数目大于等于核心线程数</span></span><br><span class="line">            <span class="comment">//core为false时  线程数目大于等于最大线程数</span></span><br><span class="line">            <span class="comment">//以上情况返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//一次cas添加线程数目，成功了就break出去</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//这里就是cas操作失败了</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">//线程状态发生了变化，就continue再次循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果最后跳出上面的循环说明添加工作线程数目成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//包装任务为Worker</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//加独占锁，</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">//确认线程池的状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//为RUNNING状态 或者</span></span><br><span class="line">                <span class="comment">//为SHUTDOWN并且进来的任务为空 就成立</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">//往保存所有工作线程集合（HashSet，所以要加锁）中添加任务</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果任务已经添加成功，就开启线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        <span class="comment">//如果任务开启失败了，就</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>retry</strong> :第一次见到这个标记，记录一下，标记循环方法里的操作（break、continue）跳转的位置。所以retry一般与循环一起出现，【retry:】这个下一行就是for循环，在for循环里的break或continue紧跟一个【retry】，就表示break或continue结束以后就从【retry:】的位置开始下一次循环或者跳出，一般用于跳出双层循环。  </p><p>关于addWorker方法做下总结，首先是一个双层循环，外层循环判断一下线程池的状态。内层循环是一个自旋操作给工作线程数目+1，成功的话就跳出双层循环，否则就继续内存自旋，或者线程状态改变以后重新进双层循环校验一下。然后就是给任务创建一个工作线程，然后加锁添加到workers中（这是一个HashSet非线程安全，包含所有的工作线程的集合），添加成功的话就开启执行。</p><p>下面研究一下这个Worker是什么东东？</p><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//实现了AQS</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">     <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">     <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">     <span class="keyword">final</span> Thread thread;</span><br><span class="line">     <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">     Runnable firstTask;</span><br><span class="line">     <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">     <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">     Worker(Runnable firstTask) &#123;</span><br><span class="line">         <span class="comment">//首先修改state为-1，避免shutDownNow方法里判断这个worker的state&gt;=0中断线程</span></span><br><span class="line">         setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">         <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">         <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         runWorker(<span class="built_in">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//重写了AQS的tryAcquire</span></span><br><span class="line">     <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">         <span class="comment">//通过cas将state 0改成1</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">             setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">         setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">         setState(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> &#123;</span><br><span class="line">         Thread t;</span><br><span class="line">         <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 t.interrupt();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Worker实现了AQS的加锁解锁操作（<a href="https://saaaaaail.gitee.io/2020/07/04/AQS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">AQS原理/源码详解</a>），实现了Runnble接口。关注一下run方法里的runWorker方法。</p><h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">//获得当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获得当前任务</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//这里修改了state的同步标志为0</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里整个getTask会从阻塞队列里面取任务出来</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置这个工作线程worker被独占</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">//保证线程池没有停止</span></span><br><span class="line">            <span class="comment">//保证线程没有中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//点进去是一个空方法</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//也是一个空方法</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//统计这个工作线程完成了多少个任务</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">//解除独占</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行一些清理工作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="comment">//如果之前执行的时候worker异常中断了，就减少工作线程数目</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计整个线程池完成的任务个数，并从工作集里面删除当前worker</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试设置线程池状态为TERMINATED</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">//线程池状态为RUNNING状态</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果当前线程数目大于核心线程数目就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新增一个工作线程从阻塞队列里取任务</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker方法大概清楚了，Worker就是一个实现AQS能自我阻塞，实现了Runnable能被线程调用的工作线程，里面封装了从threadFactory获得的thread与当前Runnable任务，开启worker线程执行run方法实际执行的是包装的Runnable任务的run方法。</p><p>再研究一下runWorker方法里的getTask方法。</p><h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋操作</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="comment">//获得线程池状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="comment">//如果线程池为STOP及以上的状态 或者</span></span><br><span class="line">            <span class="comment">//线程池为SHUTDOWN状态且阻塞队列为空</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="comment">//自旋操作，工作线程数目减1</span></span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获得工作线程数目</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="comment">//要么开启了全员存活时间（全部线程都有空闲存活时间），或者线程数大于核心线程数</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            <span class="comment">//所以这里主要是针对大于核心线程数目的线程</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                    <span class="comment">//阻塞队列为空，cas减少工作线程数目</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果time为true要么是全员都有空闲存活时间，要么线程数目大于核心线程数目</span></span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                    <span class="comment">//poll是队列里面有元素直接返回，没有元素等待这个时间后返回false</span></span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    <span class="comment">//take是有元素直接返回，没有元素就阻塞住</span></span><br><span class="line">                    workQueue.take();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//取到了r就直接返回，否则再次循环</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getTask方法从阻塞队列里面取一个任务出来执行，取一次不成功就减少工作线程的数目，这也是为什么addWorker可以传一个空任务进去。</p><p>最后研究一下shutDown方法。</p><h3 id="shutDown方法"><a href="#shutDown方法" class="headerlink" title="shutDown方法"></a>shutDown方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//权限检查</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//检查线程池的状态，如果已经是SHUTDOWN直接返回</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkShutdownAccess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//权限检查</span></span><br><span class="line">        security.checkPermission(shutdownPerm);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                security.checkAccess(w.thread);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">advanceRunState</span><span class="params">(<span class="type">int</span> targetState)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//如果已经是目标状态 或者</span></span><br><span class="line">        <span class="comment">//cas设置目标状态</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||</span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">()</span> &#123;</span><br><span class="line">    interruptIdleWorkers(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历工作线程集合</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="comment">//注意到这里工作线程会尝试加锁并中断自己的线程</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>worker为什么不使用ReentrantLock实现</strong>？<br>比较worker与ReentranlLock发现，ReentrantLock是可重入的，worker只能被加锁一次，避免被相同线程重入。</p></blockquote><blockquote><p><strong>在执行runWorker方法的时候为什么要对每个工作线程执行任务时候加锁</strong>?<br>可以知道在执行工作线程的时候会对工作线程加锁，以及在shutDown的InterruptIdleWorkers方法中会尝试对工作线程加锁并中断自身线程，因为执行任务的时候要加锁。</p></blockquote><h2 id="阻塞队列-与-拒绝策略-与-应用场景"><a href="#阻塞队列-与-拒绝策略-与-应用场景" class="headerlink" title="阻塞队列 与 拒绝策略 与 应用场景"></a>阻塞队列 与 拒绝策略 与 应用场景</h2><p><strong>workQueue</strong> 阻塞队列，存储等待执行的任务，后面来讲不同的阻塞队列。<br><strong>handler</strong> 当新的任务数量大于maxiumPoolSize的时候的任务的处理策略。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出，RejectedExecutionException异常，默认是这个。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure><h3 id="关于阻塞队列"><a href="#关于阻塞队列" class="headerlink" title="关于阻塞队列"></a>关于阻塞队列</h3><p>线程池中包含的阻塞队列包括</p><ul><li>ArrayBlockingQueue ： 由数组构成的有界阻塞队列</li><li>LinkedBlockingQueue ：由链表构成的有界阻塞队列 有界最大值为Integer.MAX_VALUE</li><li>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列</li><li>DelayQueue ： 支持优先级的延迟无界队列</li><li>SynchronizedQueue ：size为0的LinkedTransferQueue，一个offer等待一个poll，反之亦然</li><li>LinkedTransferQueue ：由链表构成的无界阻塞队列</li><li>LinkedBlockingDeque ： 由链表构成的双向阻塞队列</li></ul><h3 id="简单谈谈这些队列"><a href="#简单谈谈这些队列" class="headerlink" title="简单谈谈这些队列"></a>简单谈谈这些队列</h3><h4 id="关于ArrayBlockingQueue和LinkedBlockingQueue的区别"><a href="#关于ArrayBlockingQueue和LinkedBlockingQueue的区别" class="headerlink" title="关于ArrayBlockingQueue和LinkedBlockingQueue的区别"></a><strong>关于ArrayBlockingQueue和LinkedBlockingQueue的区别</strong></h4><ol><li><p>ArrayBlockingQueue中只使用了一把锁，等待写与等待读使用了两个condition等待队列。</p></li><li><p>LinkedBlockingQueue中生产与消费的锁分离，生产的锁为putLock，消费的锁为takeLock。</p></li><li><p>ArrayBlockingQueue生产和消费消息就是在队尾队头添加和删除对象即可</p></li><li><p>LinkedBlockingQueue生产和消费消息是先将对象包装成链表Node节点，然后对头队尾添加和删除，会影响效率</p></li><li><p>初始化ArrayBlockingQueue必须指定队列大小</p></li><li><p>LinkedBlockingQueue可指定可不指定，不指定默认是Integer.MAX_VALUE;</p></li></ol><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>是一个支持优先级的无界阻塞队列。默认情况下，元素自然升序排列，可以自定义Comparator，不能保证同优先级的顺序。</p><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>支持延时获得元素的无界阻塞队列。队列中元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中取出当前元素，只有延迟期满时才能从队列中提取元素。可以实现有时限的缓存。</p><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>是一个不存储元素的阻塞队列。每个put必须等待一个take，反之亦然。非常适合生产者线程和消费组线程在一个点同步数据</p><h3 id="关于拒绝的处理策略"><a href="#关于拒绝的处理策略" class="headerlink" title="关于拒绝的处理策略"></a>关于拒绝的处理策略</h3><p>第一个AbortPolicy，如果超过了最大线程数量，就抛弃刚刚提交的任务，并抛出一个异常。<br>第二个discardPolicy，如果超过了最大线程数量就抛弃刚刚提交的任务，然后什么也不做。<br>第三个DiscardOldestPolicy，如果超过了最大线程数量就抛弃队列最头部的任务，然后重新插入。<br>第四个callersRunsPolicy，由提交这个任务的线程执行，一般情况下，一个线程池的任务是主线程提交的，因此由主线程来执行这个任务，会造成阻塞</p><p>要注意咯！无界队列可以抛出OOM也是无法执行拒绝策略的，因为线程数量不会大于最大线程数。  </p><p>第一种策略比较适合关键业务，在不能承载更大并发量的适合及时发现。</p><p>第二种适合无关紧要的业务，比如访问量的统计。好像还可以使用线程池+有界阻塞队列+这种拒绝策略来限流，用第一种好像更好一点。</p><p>第三种喜新厌旧，适合有时效的任务，只要最新的数据的那种。</p><p>第四种调用者自己执行，然后阻塞了影响后续任务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> java并发 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理详解</title>
      <link href="/2020/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="linux操作系统原理详解"><a href="#linux操作系统原理详解" class="headerlink" title="linux操作系统原理详解"></a>linux操作系统原理详解</h1><p>最近要系统性的复习操作系统准备面试，决定结合linux来一起看看操作系统原理。参考《深入理解Linux内核(第三版)》</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程被定义为程序执行时的一个实例。</p><h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a><strong>进程描述符</strong></h3><p>进程描述符为进程控制块PCB，与进程一一对应，由进程描述符指针指向，在Linux中定义为task_struct类型的结构，描述进程的基本信息和运行状态。</p><p>进程描述符和进程的内核态堆栈存放在一个单独的8kb内存区中。esp寄存器指针指向栈顶。这俩东西配对存储，使得很容易通过esp指针获得进程描述符的指针。<br>这俩东西的起始地址方向相反，进程描述符指针+8k就得到了内核栈的栈顶指针。</p><blockquote><p>linux内核2.4中的定义 </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">stack</span>[INIT_TASK_SIZE/<span class="keyword">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>内核堆栈与task_struct分配在一个8kb的物理块，内核堆栈约占7kb，栈顶位于高位地址，然后由高地址向低地址扩展，当内核栈栈顶指针到达task_struct时会发生栈溢出，task位于8kb物理块的低位地址约占1kb大小</p></blockquote><p><strong>PCB通常包含的内容</strong>:<br>|进程描述信息|进程控制和管理信息|资源分配清单|处理机相关信息|<br>|-|-|-|-|<br>|进程标识符(PID)|进程当前状态|代码段指针|通用寄存器值|<br>|用户标识符(UID)|进程优先级|数据段指针|地址寄存器值|<br>||代码运行入口地址|堆栈段指针|控制寄存器值|<br>||程序的外存地址|文件描述符|标志寄存器值|<br>||进入内存时间|键盘|状态字|<br>||处理机占用时间|鼠标||<br>||信号量使用|||          </p><h4 id="进程的堆栈"><a href="#进程的堆栈" class="headerlink" title="进程的堆栈"></a><strong>进程的堆栈</strong></h4><p>每个进程都有自己的堆栈，内核在创建一个新的进程时，在创建进程控制块task_struct的同时，也为进程创建自己堆栈。一个进程有2个堆栈，用户堆栈和内核堆栈；用户堆栈的空间指向用户地址空间，内核堆栈的空间指向内核地址空间。当进程在用户态运行时，CPU堆栈指针寄存器指向的用户堆栈地址，使用用户堆栈，当进程运行在内核态时，CPU堆栈指针寄存器指向的是内核栈空间地址，使用的是内核栈；</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a><strong>进程状态</strong></h3><p>在操作系统概念中的状态为：<br>可运行状态、阻塞状态、终止状态</p><p>在linux中的状态：<br><strong>可运行状态</strong>:要么占用CPU执行，要么准备执行。<br><strong>可中断的等待状态</strong>:进程被挂起，直到一个条件，一个信号传递过来唤醒进程。<br><strong>不可中断的等待状态</strong>:进程必须等待，不能响应软中断，直到特定的事件发生。<br><strong>暂停状态</strong>:进程的执行被暂停，调试的时候会被暂停，资源被回收。<br><strong>僵死状态</strong>:进程执行结束，资源被回收除了task_struct结构，但是父进程还没有进行wait系列的系统调用返回死进程的信息。在发布wait()系统调用之前，内核不能丢弃包含在死进程描述符里的数据，父进程可能还需要他。</p><blockquote><p>僵尸进程与孤儿进程：<br>僵尸进程： 一个父进程利用fork创建子进程，如果子进程退出，而父进程没有利用wait 或者  waitpid 来获取子进程的状态信息，那么子进程的状态描述符依然保存在系统中。<br>孤儿进程：一个父进程退出， 而它的一个或几个子进程仍然还在运行，那么这些子进程就会变成孤儿进程，孤儿进程将被init进程（进程号为1）所收养，并由init进程对它们完成状态收集的工作<br>init进程：<br>在内核启动阶段就会创建init进程，init进程是所有进程的父进程。</p></blockquote><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a><strong>进程切换</strong></h3><p>进程切换只发生在内核态</p><h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a><strong>进程上下文</strong></h4><p>进程切换现场称为进程上下文(context)，包含了一个进程所具有的全部信息，一般包括：进程控制块（Process Control Block，PCB）、有关程序段和相应的数据集。</p><h4 id="用户栈切换到内核栈"><a href="#用户栈切换到内核栈" class="headerlink" title="用户栈切换到内核栈"></a><strong>用户栈切换到内核栈</strong></h4><p>当进程由于中断或系统调用从用户态转换到内核态时，进程所使用的栈也要从用户栈切换到内核栈。系统调用实质就是通过指令产生中断，称为软中断。进程因为中断（软中断或硬件产生中断），使得CPU切换到特权工作模式，此时进程陷入内核态，进程进入内核态后，首先把用户态的堆栈地址保存在内核堆栈中（保存用户堆栈指针是为了能从内核态切换回来的时候恢复现场），然后设置CPU堆栈指针寄存器的地址为内核栈地址，这样就完成了用户栈向内核栈的切换。</p><blockquote><p>进入内核态以后回来的时候能知道用户栈栈顶指针的位置，那么当进入内核态的时候如何知道的内核态堆栈指针的位置了，根据进程描述符的指针就可以算出内核态堆栈栈顶指针的位置，因为进程控制块与内核堆栈分配在一个连续的8kb空间里面。</p></blockquote><h4 id="进程切换-1"><a href="#进程切换-1" class="headerlink" title="进程切换"></a><strong>进程切换</strong></h4><p>进程切换发生在内核态，这时候即将切换的进程已经陷入到了内核态。</p><p>当一个进程的时间片用完，经过线程调度以后要切换为其他进程，首先要保存线场当前进程的cpu里的寄存器的值都入栈，然后将进程的页表切换为目标进程的页表，然后切换内核堆栈与硬件上下文。</p><ol><li>调用switch_mm()函数进行进程页表的切换；</li><li>调用 switch_to() 函数进行 CPU寄存器切换；</li></ol><h4 id="硬中断与软中断"><a href="#硬中断与软中断" class="headerlink" title="硬中断与软中断"></a>硬中断与软中断</h4><p>硬中断通常是由外部设备所产生的，通过中断线的电信号到达中断控制器，由中断控制器将中断号发给cpu，然后cpu去确定中断处理程序入口地址，置为PC，然后cpu执行。硬中断的特定就是响应迅速，处理快。</p><p>软中断通常是由运行着的进程所产生的中断。通过特定的指令产生中断，而且软中断的中断号是自己指定的，然后cpu去执行，而且常常是使用内核代码处理硬中断未完成的工作 ，属于中断的下半部。</p><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a><strong>进程创建</strong></h3><p>在linux系统中，系统启动以后第一个进程由系统来创建，其余进程都必须由已存在的进程来创建，创建一个子进程的系统调用为fork()，我们都知道一个进程的数据包含BSS段（存未初始化的全局变量）、数据段（存初始化后的全局变量）、代码段（存放程序代码）、堆（存放malloc动态分配的内存）、栈（存局部变量）五部分，fork()创建进程会复制父进程的这些数据结构，但是不是与父进程共享而是单独分配的内存，fork在linux中使用的写时复制技术，刚开始是共享父进程数据段，在写数据段时才会进行复制。</p><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a><strong>内核线程</strong></h3><p>内核经常需要在后台执行一些耗时操作，就通过内核线程来实现，只在内核态运行，也没有独立的地址空间</p><h3 id="撤销进程"><a href="#撤销进程" class="headerlink" title="撤销进程"></a><strong>撤销进程</strong></h3><p>进程终止的一般方式为调用exit()系统调用。</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a><strong>进程调度</strong></h3><p>进程调度的过程就是选择哪个进程去占用cpu执行。</p><p>进程调度通过不同的进程调度算法来决定如何调度。   </p><blockquote><p>linux中动态优先级数值越小，动态优先级越高。</p></blockquote><p>linux调度策略是基于优先级排队的，每个进程都与一个值关联，这个优先级是动态的，对于长时间没有使用CPU的的进程动态提升他们的优先级（提升优先级通过降低优先级数值，对于已经占用CPU很长时间的进程动态减少优先级来处罚。</p><p>一般将进程区分为三类:  </p><h4 id="交互式进程"><a href="#交互式进程" class="headerlink" title="交互式进程:"></a><strong>交互式进程</strong>:</h4><p>进程经常与用户交互，需要花时间等待用户操作，当输入被接受时，必须很快唤醒进程。</p><h5 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h5><p>将所有的就绪的进程按照FCFS的顺序排成一个队列，每次调度把CPU时间分给队首进程，该进程可以执行他获得的时间片，时间片用完了就触发定时中断，挂起该进程并排到队尾，继续给此时对头的进程分配时间片。</p><ul><li>时间片轮转的效率与一次分配的时间片有关系，太短了导致进程切换频繁，CPU利用率低，太长了就没有实时性了。<h5 id="动态优先级调度"><a href="#动态优先级调度" class="headerlink" title="动态优先级调度"></a>动态优先级调度</h5>类似于动态时间片轮转。<br>为每个进程分配一个优先级，按进程优先级进行调度，而且会动态修改进程的优先级。</li></ul><p>linux采用的此种方式进行优先级调度。会给每个进程都分配两种优先级。</p><ul><li><strong>静态优先级</strong> 这种优先级由用户赋给实时进程，范围由1到99，越小优先级越高，调度程序不会改变他。</li><li><strong>动态优先级</strong> 这种优先级只用于普通进程，实质上它是基本时间片与当前时期内剩余时间片之和。</li></ul><p>linux进行调度需要的数据结构都记录在进程描述符中，包括以下几个域，简单记录下：</p><ul><li>need_reached 由ret_from_intr()检查的一个标志，决定是否调用schedule()函数</li><li>policy 调度的类型，可选值如下:<ul><li>SCHED_FIFO 先入先出的实时进程</li><li>SCHED_RR 循环轮转的实时进程</li><li>SCHED_OTHER 普通的分时进程</li><li>SCHED_YIELD 当进程调用sched_yield()系统调用时，这个标志被设置。调度程序就把进程描述符放在运行队列的尾端。当内核在执行一个较长且不紧急的任务时，又希望给其他进程机会，就会设置这个标志，并调用schedule()</li></ul></li><li>rt_priority 实时进程的静态优先级 普通进程用不到</li><li>priority 进程的基本时间片 又称为基本优先级</li><li>counter 当前时间片用完之前剩余的CPU时间节拍 在update_process_times()函数每个节拍都会将当前进程的counter-1</li></ul><p>以上参数中，priority与counter对于普通进程而言决定了进程的分时与动态优先级，对于SCHED_RR实时进程只用来分时，对于SCHED_FIFO实时进程用不到。</p><h5 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h5><p>一个进程需要执行100个时间片，如果采用时间片轮转，那么需要交换100次。</p><p>多级队列为这种需要连续执行多个时间片的进程考虑，里面设置了多个队列，每个队列对应了线程能执行的时间片的长短，例如分为1、2、4、8…等时间片，第一个队列入cpu执行，如果没执行完会进入第二个时间片长一点的队列，依次类推。</p><p>最上面的时间片最短的优先级最高，只有上一个队列没有进程在排队，才会执行后面的队列。</p><h4 id="批处理进程"><a href="#批处理进程" class="headerlink" title="批处理进程:"></a><strong>批处理进程</strong>:</h4><p>经常后台运行，不必有很快的响应,保证吞吐量和周转时间。</p><h5 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务 FCFS"></a>先来先服务 FCFS</h5><p>非抢占式的调度算法，有利于长作业，但不利于短作业，短作业必须长时间等待前面的长作业执行完。</p><h5 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先 SJF"></a>短作业优先 SJF</h5><p>非抢占式的调度算法，保证运行时间短的作业优先运行，一直有短作业到来的话，有可能使长作业饿死。</p><h5 id="最短剩余时间优先-SRTN"><a href="#最短剩余时间优先-SRTN" class="headerlink" title="最短剩余时间优先 SRTN"></a>最短剩余时间优先 SRTN</h5><p>短作业优先的抢占式算法，按剩余运行时间的顺序进行调度，当新的作业到来，其整个运行时间比当前进程剩余时间要短，则挂起当前进程，运行新来的进程。</p><h4 id="实时进程"><a href="#实时进程" class="headerlink" title="实时进程:"></a><strong>实时进程</strong>:</h4><p>有很强大的调度需要，绝不会被低优先级进程阻塞，必须要有很短的响应时间。<br>实时系统分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a><strong>进程同步</strong></h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>对临界资源(临界资源指的是一次仅允许一个进程使用的资源，硬件如打印机、磁带机，软件如消息队列、变量、缓冲区等)进行访问的代码被称为临界区，为了能正常安全地访问临界区资源，每个进程进入临界区之前要进行检查。</p><h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><p><strong>同步</strong> :同步指多个进程合作完成某个任务，但是这些进程之间有先后顺序的要求，必须按照一定的先后顺序执行。<br><strong>互斥</strong> :多个进程同一时刻只能有一个进程进入临界区。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是一个整型变量，可以对其进行down与up操作，也就是PV操作</p><p>down，如果信号量大于0，执行-1操作；如果信号量等于0，进程睡眠，等待信号量大于0并且被唤醒。</p><p>up，对信号量执行+1操作，并且唤醒睡眠的进程让其完成down操作。</p><p>以上两个操作必须是原语，在linux中通常会提前关中断，执行完以后开中断</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>由于信号量的机制，PV操作成对出现，但是位置分散，而且使用不当会造成死锁，因此提出了管程的机制。<br>管程的特点就是某个时刻只能有一个进程/线程使用管程。而且在不满足某个条件变量的时候能自我阻塞退出管程等待唤醒，等待其他进程/线程获得管程执行后唤醒其他进程/线程。</p><blockquote><p>所以在java中synchronized关键与Lock锁都实现了类似管程的功能。<br>简单记录下synchronized的管程理解。<br><strong>监视者对象</strong>:Monitor Object负责公共的接口方法，java中的Object就是监视者对象。<br><strong>同步块</strong>:在获得了监视者对象以后，才能执行这块代码，保证了同一时刻只有一个线程执行。<br><strong>监视锁</strong>:Monitor Lock 每个监视者对象都会有一把监视锁。<br><strong>监控条件</strong>:Monitor Condition 根据是否获得锁以及是否满足监控条件来决定阻塞还是唤醒进程/线程</p></blockquote><h4 id="同步问题的sail实现"><a href="#同步问题的sail实现" class="headerlink" title="同步问题的sail实现"></a>同步问题的sail实现</h4><h5 id="生产者消费组队列"><a href="#生产者消费组队列" class="headerlink" title="生产者消费组队列"></a>生产者消费组队列</h5><h5 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h5><h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h5><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a><strong>进程通信</strong></h3><p>为了能达到进程同步的目的，需要让进程间进行通信，传输一些同步必须的数据。</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道是一个固定大小的缓冲区，只支持半双工通信，只能在父子进程和兄弟进程间使用。</p><p>可以c++里面通过调用pipe函数创建，fd[0]用于读，fd[1]用于写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><p>与管道相同，只是去除了只能父子进程、兄弟进程通信的限制。</p><p>借助c++的mkfifo函数来创建。管道实际是一个file结构和一个VFS索引，也就是一个虚拟的文件。常用于客户进程与服务端进程间的通信，客户进程写完了以后，服务进程去读，服务进程写完了以后，客户进程去读。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="信号signal"><a href="#信号signal" class="headerlink" title="信号signal"></a>信号signal</h4><p>信号具有平台相关性，不同平台下能使用的信号种类不同也十分有限，<strong>用于通知进程某事件的发生</strong>。</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列独立于进程存在，不需要进程维护管理。<br>消息队列提供了同步阻塞的方法，不许进程自己提供。<br>读进程能有选择地接收不同类型的消息。</p><h4 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h4><p>是一个计数器，也能称为互斥量，能控制进程同步的访问共享资源。</p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>允许多个进程共享一片存储区域，因为数据不需要在进程间复制效率很高，但是对共享数据访问的话要使用使用同步机制保证数据安全。</p><h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p>指定ip与端口能实现相同机器或者不同机器间的通信。</p><!-- ## 操作系统的死锁问题### 发生死锁的必要条件根据死锁可以推出以下四种情况：- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。### 处理方法#### 死锁检测与恢复#### 死锁预防#### 死锁避免 --><h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。</p><p>通俗地讲，就是两个或多个进程互相持有资源并且等待对方持有的资源，每个进程都不愿意放弃自己的资源，导致没有进程可以继续执行。  </p><p>（1）系统资源不足；（2）进程推进顺序非法。</p><p>　　产生死锁的必要条件：</p><p>　　（1）互斥（mutualexclusion），一个资源每次只能被一个进程使用；</p><p>　　（2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺；</p><p>　　（3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；</p><p>　　（4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。</p><p>　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><p>　　死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源 的分配要给予合理的规划。</p><h4 id="死锁的处理策略："><a href="#死锁的处理策略：" class="headerlink" title="死锁的处理策略："></a>死锁的处理策略：</h4><h5 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h5><p>等待死锁发生以后再去解决</p><h5 id="预防策略"><a href="#预防策略" class="headerlink" title="预防策略"></a>预防策略</h5><p>破坏4个必要条件中的一个，就不会发生死锁</p><ul><li>互斥条件不能被破坏，如果资源共享可以破坏，问题是资源不能共享，如果共享会造成数据不一致的问题。</li><li>破坏其他三个都可以</li></ul><h5 id="避免策略"><a href="#避免策略" class="headerlink" title="避免策略"></a>避免策略</h5><p>避免死锁是尽量不破坏四个必要条件，在运行过程中来避免死锁发生。<br>、检测与恢复策略。</p><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>通过有效分配资源来避免死锁</p><h5 id="常用避免死锁的方法"><a href="#常用避免死锁的方法" class="headerlink" title="常用避免死锁的方法"></a>常用避免死锁的方法</h5><ul><li><p>顺序加锁</p></li><li><p>加锁限时</p><ul><li>一段时间没获取到资源就放弃获取锁，同时释放自己的资源</li></ul></li><li><p>解除死锁</p><ul><li>指一旦检测到死锁就剥夺某个进程占用的资源或者让进程回退</li></ul></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用空间。</p><p>操作系统将内存抽象为地址空间。每个程序拥有自己的地址空间，地址空间被分割成多个块，每一块被称为一页，这些页在使用的时候会被映射到实际的物理内存（可以不连续），不需要所有页都必须在物理内存中，如果使用到一页不在物理内存中，则会引发缺页异常，由硬件重新分配缺失的物理内存，并重新执行。</p><p>因此，虚拟内存技术保证了程序运行时不需要将虚拟地址每一页都映射到物理内存，仅仅只是用多少映射多少，所以使得有限的物理内存运行大程序成为可能。</p><h3 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h3><p>内存管理单元（MMU）管理着虚拟地址（线性地址）和物理内存的转换，其中页表（Page table）存储着页（虚拟地址空间）和页框（物理内存地址）的映射关系。</p><blockquote><p>对于linux而言，内存映射主要靠的页式内存管理机制，页机制是现代CPU都具备的，而段式内存管理是intel86系统架构独有的概念。linux中为了保证兼顾intel86平台先分段再分页的规则，使虚拟地址具有了相同的段基址 【0(段基址):偏移量(通过段基址+段内偏移量得到的是线性地址)】（这个 段基址:偏移量 的地址组合出现在段式内存管理里面，称为逻辑地址），所以实际上linux中的逻辑地址与线性地址是一致的。</p></blockquote><p>了解了各个地址的关系以后，研究一下页式管理的虚拟地址的构成。</p><p>一个虚拟地址可以区分两块:页面号和页面内偏移量。<br>对于一个32位linux系统，其页框大小为4kb，那么使用2^12表示偏移量即可全部寻址，高位的20位均可以表示页面号，根据操作系统书本的描述，页面号乘以页表项的长度加上页表的起始地址即可获得页表项在页表中的位置，根据这个位置号能获得物理块号的地址。将物理块号作为高位，将页面内偏移作为低位完成拼接即可获得页框的物理地址。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>因为内存大小有限，访问的页面可能不在内存中，这时候发生缺页中断而将这一页从磁盘中调入内存。如果页面已经满了，那就必须从内存里选一个页面出来保存新的数据。</p><h4 id="最长时间内不再被访问-OPT"><a href="#最长时间内不再被访问-OPT" class="headerlink" title="最长时间内不再被访问 OPT"></a>最长时间内不再被访问 OPT</h4><p>理论上的最优算法，所换出的页面是最长时间内不再被访问，但是因为无法知道一个页面的多长时间内不会再被访问。可以保证最低的缺页率。</p><h4 id="最久未使用LRU"><a href="#最久未使用LRU" class="headerlink" title="最久未使用LRU"></a>最久未使用LRU</h4><p>无法知道未来使用内存的情况，但是可以根据过去使用内存的情况来替换，最久没有使用过的页面可以替换掉。</p><h4 id="最近未使用NRU"><a href="#最近未使用NRU" class="headerlink" title="最近未使用NRU"></a>最近未使用NRU</h4><p>每个页面有两个状态:R与M ，当页面被访问时设置R=1，当页面被修改时设置M=1，R会定时被清零。<br>将页面分为以下四类:</p><ul><li>R=0,M=0</li><li>R=0,M=1</li><li>R=1,M=0</li><li>R=1,M=1<br>NRU 优先替换出已经被修改的脏页面（R=0,M=1），而不是频繁访问的干净页面（R=1,M=0）。</li></ul><h4 id="先进先出FIFO"><a href="#先进先出FIFO" class="headerlink" title="先进先出FIFO"></a>先进先出FIFO</h4><p>无法保证页面的命中率，随缘。</p><h4 id="第二次机会算法"><a href="#第二次机会算法" class="headerlink" title="第二次机会算法"></a>第二次机会算法</h4><p>将页面构造成一个FIFO队列，每个页面有一个标志位R，被访问或者被修改的将R=1,队列满的时候判断即将出队的页面R如果等于0，就直接让他出队，如果R==1，则将R置为0并把这个页面重新入队。</p><h4 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h4><p>第二次机会算法需要在队列中移动页面，影响效率。时钟算法不用移动页面节点，将页面构建成一个环，用一个指针指向最先入队的节点。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>为了解决 内存地址空间不隔离，内存地址不固定 这俩问题，引入了分段的概念.<br>首先，分段在程序编译期间会建立多个表。</p><blockquote><p>在编译过程中会建立许多的表，来确定代码和变量的虚拟地址：<br>1.被保存起来供打印清单的源程序正文；<br>2.符号表，包含变量的名字和属性；<br>3.包含所有用到的整形和浮点型数据的表；<br>4.语法分析树，包括程序语法分析的结果；<br>5.编译器内部过程调用的堆栈。  </p></blockquote><p>前四个表在编译期会动态增长，如果使用分页地址就会被覆盖。<br>这多张表分成逻辑上的多个段，逻辑上连续的地址空间。   </p><p>如果仅仅使用分段机制管理内存，那么这一张段表就对应一块连续的物理内存地址，逻辑地址的构成是段基址+段内偏移地址，根据段基址计算再到段表去查询获得物理地址的基址加上偏移地址就获得了实际的物理地址。但是在段式管理下，由于分配的内存不是定长的，时间长了，就会碎片化，导致有足够的内存空间但是无法分配给某个进程。</p><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>首先，分页与分段都是为了更好的使用内存资源。</p><p>段页式就解决了 内存地址空间不隔离，内存地址不固定，内存使用率不高 这仨问题。<br>首先段式管理解决了上面俩问题。</p><p>在段页式机制下面，程序内存地址被分成了多个连续的地址空间的段，在段内又分成了地址空间大小一致一般为4kb的页，解决了地址空间连续，利用率不高的问题。<br>段页式机制下，由段表计算出来的地址被称为线性地址，也就是分页里面的虚拟地址，将这个地址进行拆分，前一部分表示页面号，后一部分表示页面内偏移地址，页面号经过计算到页表中查询获得页的起始地址，加上页面内偏移就能计算得到实际的物理地址。</p><h3 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h3><p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p><h3 id="2020-8-22-面试-gt-谈一谈分段与分页"><a href="#2020-8-22-面试-gt-谈一谈分段与分页" class="headerlink" title="2020/8/22 面试&gt;谈一谈分段与分页"></a>2020/8/22 面试&gt;谈一谈分段与分页</h3><p>分段与分页的目的都是为了更好的利用内存资源。<br>分段指的是用户进程将自己的内存划分为多个逻辑段，每个段有自己的段号，段内物理地址连续，段间物理地址不连续，通过段表来记录逻辑地址到物理地址的映射关系，（取出逻辑地址的前几位为段号，后几位为段内偏移量，通过段表项起始地址+段号乘以段表项的长度，得到段号对应段表项的地址，然后取出对应段表项的起始物理地址，将起始物理地址+段内偏移量得到物理地址）段式内存管理解决了内存地址不隔离的问题，而且有段表也解决了直接使用物理地址，地址不固定的问题。<br>分页指的是将内存空间划分为固定大小的内存块，32位linux为4kb大小，每个块称为一页，通过页表可以不连续的映射物理内存块，每个页表项就是一个4kb物理内存块的起始地址（通过虚拟地址），并且每块大小相同也不会产生内存碎片。如果仅仅只是分页不分段的话，那内存空间是不隔离的，然后在分页中还有虚拟地址技术，可以分配一段连续的虚拟地址空间但是不映射物理页，当使用到对应的虚拟地址页时，发现缺页的时候才发生中断去分配物理内存页。这种技术可以运行大内存程序。</p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="磁盘性能参数"><a href="#磁盘性能参数" class="headerlink" title="磁盘性能参数"></a>磁盘性能参数</h3><p>寻道时间：磁头定位到磁道所需要的时间</p><p>旋转延迟：磁道定位之后，磁盘控制器开始等待，直到适当的扇区旋转到磁头处的时间。</p><p>存取时间：寻道时间+旋转延迟，即达到读或写的位置所需要的时间。</p><p>传输时间：磁头定位完成，磁头通过下面旋转的扇区，执行读操作或写操作所需要的时间。</p><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p><a href="https://www.cnblogs.com/tjulym/p/5003655.html">四种磁头调度算法</a></p><h2 id="linux常用指令"><a href="#linux常用指令" class="headerlink" title="linux常用指令"></a>linux常用指令</h2><h3 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h3><p>示例:chmod ugoa+rwx directory1<br>设置目录的所有人(u)、群组(g)以及其他人(o)以读（r，4 ）、写(w，2)和执行(x，1)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限</p><h3 id="jps命令"><a href="#jps命令" class="headerlink" title="jps命令"></a>jps命令</h3><p>jps是jdk提供的一个查看当前java进程的小工具。<br>jps -l 输出完整的包名<br>jps -v 输出jvm的参数</p><h3 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h3><p>ps -aux 查看系统所有进程的数据<br>能看到PID进程id、CPU进程占用的cpu、MEM进程占用的物理内存百分比、VSZ进程用掉的虚拟内存、RSS进程占用的固定内存量。</p><p>STAT：该程序目前的状态，主要的状态有：</p><ul><li>R ：该程序目前正在运作，或者是可被运作；</li><li>S ：该程序目前正在睡眠当中 (可说是 idle 状态啦！)，但可被某些讯号(signal) 唤醒。</li><li>T ：该程序目前正在侦测或者是停止了；</li><li>Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</li></ul><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><ol><li>第一行参数</li></ol><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>05:43:27</td><td>表示当前时间</td></tr><tr><td>up 4:52</td><td>系统运行时间 格式为时：分</td></tr><tr><td>2 users</td><td>当前登录用户数</td></tr><tr><td>load average: 0.58, 0.41, 0.30</td><td>系统负载，即任务队列的平均长度。 三个数值分别为 过去1分钟、5分钟、15分钟前到现在的平均值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</td></tr></tbody></table><blockquote><p>load average 平均负载可以通过uptime或者top查看，如果三个值依次减小，说明系统负载是上升的趋势，通过mpstat查看哪个进程在占用cpu，是使用cpu比较高还是io等待时间比较高。</p></blockquote><ol start="2"><li><p>第二行参数 Tasks: 159 total, 1 running, 158 sleeping, 0 stopped, 0 zombie<br>表示进程的数量</p></li><li><p>第三行参数 %Cpu(s): 37.0 us, 3.7 sy, 0.0 ni, 59.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st<br>表示cpu的信息。 mpstat指令也可单独查看</p></li></ol><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>37.0 us</td><td>用户空间占用CPU百分比</td></tr><tr><td>3.7 sy</td><td>内核空间占用CPU百分比</td></tr><tr><td>0.0 ni</td><td>用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td>59.3 id</td><td>空闲CPU百分比</td></tr><tr><td>0.0 wa</td><td>等待输入输出的CPU时间百分比</td></tr><tr><td>0.0 hi</td><td>硬中断（Hardware IRQ）占用CPU的百分比</td></tr><tr><td>0.0 si</td><td>软中断（Software Interrupts）占用CPU的百分比</td></tr></tbody></table><ol start="4"><li>第四行参数 KiB Mem: 1530752 total, 1481968 used, 48784 free, 70988 buffers   </li><li>第五行参数 KiB Swap: 3905532 total, 267544 used, 3637988 free. 617312 cached Mem  </li></ol><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>KiB Mem: 1530752 total</td><td>物理内存总量</td></tr><tr><td>1481968 used</td><td>使用的物理内存总量</td></tr><tr><td>48784 free</td><td>空闲内存总量</td></tr><tr><td>70988 buffers（buff/cache）</td><td>用作内核缓存的内存量</td></tr><tr><td>KiB Swap: 3905532 total</td><td>交换区总量</td></tr><tr><td>267544 used</td><td>使用的交换区总量</td></tr><tr><td>3637988 free</td><td>空闲交换区总量</td></tr><tr><td>617312 cached Mem</td><td>缓冲的交换区总量。</td></tr><tr><td>3156100 avail Mem</td><td>代表可用于进程下一次分配的物理内存数量</td></tr></tbody></table><p>ps：<br>cat /proc/meminfo 指令查看详细的内存使用情况<br>vmstat 指令 也可查看内存占用情况</p><p>top指令 查看进程的参数<br>    PID：进程的ID<br>　　USER：进程所有者<br>　　PR：进程的优先级别，越小越优先被执行<br>　　NInice：值<br>　　VIRT：进程占用的虚拟内存<br>　　RES：进程占用的物理内存<br>　　SHR：进程使用的共享内存<br>　　S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数<br>　　%CPU：进程占用CPU的使用率<br>　　%MEM：进程使用的物理内存和总内存的百分比<br>　　TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。<br>　　COMMAND：进程启动命令名称</p><blockquote><p><a href="https://blog.csdn.net/yjclsx/article/details/81508455">top命令</a></p></blockquote><h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><p>netstat -apt 查询所有状态的端口（已连接或者监听），并打印进程的pid与进程名</p><h2 id="linux问题"><a href="#linux问题" class="headerlink" title="linux问题"></a>linux问题</h2><h3 id="linux中的cached与buffers"><a href="#linux中的cached与buffers" class="headerlink" title="linux中的cached与buffers"></a>linux中的cached与buffers</h3><p>buffer缓冲区常常是用来将空闲的内存分配出来给块设备做读写缓冲区用的，用来暂存数据<br>cached是作为读取文件系统的cache，读写文件的时候为了提高效率，将文件在内存中进行缓存。</p><h3 id="linux中的虚拟内存与与swap空间"><a href="#linux中的虚拟内存与与swap空间" class="headerlink" title="linux中的虚拟内存与与swap空间"></a>linux中的虚拟内存与与swap空间</h3><p>虚拟内存指的就是linux使用的不存在的空间，这一部分空间物理内存肯定是给不了了，因此linux通过两种方法来进行内存管理，一种是调页算法，即页面替换算法，将容易命中的数据放到物理内存中，还有一种就是交换，即将没有足够空间的进程整个放到磁盘上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock原理详解</title>
      <link href="/2020/07/02/ReentrantLock%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/07/02/ReentrantLock%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="ReentrantLock原理详解"><a href="#ReentrantLock原理详解" class="headerlink" title="ReentrantLock原理详解"></a>ReentrantLock原理详解</h1><blockquote><p>提问：介绍一下ReentrantLock？</p></blockquote><h2 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br></pre></td></tr></table></figure><ol><li>lock()/unlock() </li><li>tryLock()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以进行加锁尝试 ，如果一段时间没有获得锁，就停止尝试获得锁返回false</span><br></pre></td></tr></table></figure></li><li>lockInterruptibly() <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过这个方式加锁的，可以被线程的interrupt()方法打断</span><br></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock(true);</span><br></pre></td></tr></table></figure><blockquote><p>提问：Lock公平锁为什么不能保证绝对的公平？</p></blockquote><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>ps:以下是ReentrantLock源码分析，AQS原理不再赘述噢，AQS源码解读-&gt; <a href="https://saaaaaail.gitee.io/2020/07/04/AQS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/#AQS%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3">AQS源码解读</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984872572414699L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//非公平锁与公平锁子类实现</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//这个是非公平锁的tryAcquire实现，acquires==1</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获得最新的同步状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">//如果c==0表示资源为空，可以占用</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//通过cas操作加锁，如果成功设置占用线程，并返回true</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">//如果资源已经被占用，判断是不是当前线程，如果是，将同步状态重入次数+1</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面都不成功返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试释放同步资源 这里release==1       </span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">//获得最新的同步资源状态state-1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="comment">//如果访问线程不是独线程的话抛错</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//如果c==0说明重入次数仅为1，可以直接释放</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//情况独占线程</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置同步状态位</span></span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Methods relayed from outer class</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread <span class="title function_">getOwner</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="literal">null</span> : getExclusiveOwnerThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getHoldCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock实现了Lock接口，还包含一个继承自AQS的静态内部类sync同步器，这个同步器实现了AQS里没有实现tryAcquire方法和tryRelease方法，下面看看非公平锁与公平锁的同步器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁的同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非公平锁的lock方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//cas尝试设置state为1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果失败了就调用AQS的acquire方法去获得资源或者放入AQS同步队列里阻塞</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//就是直接调用的sync里的tryAcquire方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平锁的同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公平锁就直接走AQS的同步队列了，也不用cas尝试一下</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公平锁的tryAcquire方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断一下AQS同步队列中没有元素，尝试加锁</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">//这里依然是可重入判断</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上叙述可知，公平锁与非公平锁的区别在于，公平锁获取资源完全交由AQS同步队列去安排，尝试加锁还要判断队列中有无元素，非公平锁虽然也会交给AQS同步队列，但是新来的线程会自己cas尝试获得锁，只要同步状态为0，就能抢夺资源。</p><p>ReentrantLock构造方法，默认非公平锁，设置为true就是公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一看ReentrantLock的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//同步器里的lock方法</span></span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//这是AQS里的可中断版本的acquire</span></span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这个写在sync里，就是公平锁也可以调这个</span></span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHoldCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.getHoldCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHeldByCurrentThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.isLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isFair</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync <span class="keyword">instanceof</span> FairSync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法基本都看过了，其中有几个aqs的方法没有分析过，下面来看一看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//存在一个计时器，每次自旋计算剩下多少时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">//这个parkNanos方法会调用unsafe的parkNanos方法阻塞这个线程剩余nanosTimeout的时间</span></span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>tryAcquireNanos方法实现了一个有时间限制的自旋尝试获取资源的操作，其中添加了deadline与当前时间比较，即使被park阻塞也只会阻塞剩余时间就自动被唤醒了。其他方法与AQS中的acquireQueued相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//可见这个方法检测到了中断标志位就</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lock与synchronized的区别"><a href="#lock与synchronized的区别" class="headerlink" title="lock与synchronized的区别"></a>lock与synchronized的区别</h1><ol><li>synchronized是关键字，而Lock是一个接口</li><li>synchronized会自动释放锁，而Lock必须手动释放锁</li><li>synchronized是不可中断的，Lock可以中断也可以不中断</li><li>通过Lock可以知道线程有没有拿到锁，而synchronized不能</li><li>synchronized能锁住方法和代码块，而Lock只能锁住代码块</li><li>Lock可以使用读锁提高多线程读效率</li><li>synchronized是非公平锁，ReentrantLock可以控制是否是公平锁</li><li>synchronized获取不到锁就会阻塞，而Lock可以尝试获取锁，一段时间获取不到就放弃获取。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程复习笔记</title>
      <link href="/2020/07/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="sail的多线程复习笔记"><a href="#sail的多线程复习笔记" class="headerlink" title="sail的多线程复习笔记"></a>sail的多线程复习笔记</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ol><li>线程启动 run()、start()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这俩方法的区别、原理？</span><br></pre></td></tr></table></figure></li><li>sleep() </li><li>yield() <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让出一下cpu，但是调度由操作系统去做，不一定切换线程，可能调度回来还是原线程，也可能切换</span><br></pre></td></tr></table></figure></li><li>join() <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">经常用来等待另一个线程的结束。比如t1、t2两个线程，在t1的代码中调t2.join()表示这时候转到t2去执行，t2执行完了继续执行t1。</span><br><span class="line"></span><br><span class="line">保证三个线程顺序执行？</span><br><span class="line">1. 主线程依次t1.join()、t2.join()、t3.join()</span><br><span class="line">2. 主线程t1.join(),t1线程中调t2.join(),t2线程中调t3.join()</span><br></pre></td></tr></table></figure></li><li>interrupt() <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置一个中断的标志位，当线程正在运行则不受影响，直到线程被join、wait、sleep等方法打断，会马上抛出InterruptException异常，我们捕获这个异常来处理，如果直接抛出，线程就会结束，如果不抛，而是人为处理掉，线程也可以继续正常运行。</span><br></pre></td></tr></table></figure><h3 id="java中线程状态"><a href="#java中线程状态" class="headerlink" title="java中线程状态"></a>java中线程状态</h3></li></ol><p><img src="%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.jpg" alt="线程状态图"></p><h4 id="Runnable状态"><a href="#Runnable状态" class="headerlink" title="Runnable状态"></a>Runnable状态</h4><p>java中线程的就绪状态Ready与运行状态Running可以统称为。</p><ol><li>就绪状态 是指线程处在一个cpu的等待队列里面，等待cpu分配时间片运行</li><li>运行状态就是 cpu运行当前线程</li></ol><h4 id="Teminated状态（终止状态）"><a href="#Teminated状态（终止状态）" class="headerlink" title="Teminated状态（终止状态）"></a>Teminated状态（终止状态）</h4><p>当线程结束以后会进入这个状态，不能重新调用start，如果想重新start，需要重新new一个线程对象。</p><h4 id="Blocked状态-阻塞状态"><a href="#Blocked状态-阻塞状态" class="headerlink" title="Blocked状态 (阻塞状态)"></a>Blocked状态 (阻塞状态)</h4><p>等待synchronized锁的时候进入Blocked状态，获得锁回到Runnable状态</p><h4 id="Waiting状态"><a href="#Waiting状态" class="headerlink" title="Waiting状态"></a>Waiting状态</h4><p>需要调用对应的方法才能解除状态</p><h4 id="TimedWaiting状态"><a href="#TimedWaiting状态" class="headerlink" title="TimedWaiting状态"></a>TimedWaiting状态</h4><p>过一段时间自动恢复</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h2 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h2><p>synchronized必须是可重入锁 记录重入次数</p><p>异常会释放synchronized锁，要注意捕获处理</p><p>synchronized(Object) 锁定对象 不能是String常量、Integer、Long等基础数据类型的包装类</p><p><strong>synchronized详解链接</strong></p><h4 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h4><p>锁细化<br>锁粗化</p><h2 id="可重入锁Lock"><a href="#可重入锁Lock" class="headerlink" title="可重入锁Lock"></a>可重入锁Lock</h2><h3 id="什么时候用Lock什么时候用synchronized"><a href="#什么时候用Lock什么时候用synchronized" class="headerlink" title="什么时候用Lock什么时候用synchronized"></a>什么时候用Lock什么时候用synchronized</h3><p>线程少并且一次占用线程时间不长可以使用自旋锁<br>线程多，并且容易长时间执行占用锁，就使用synchronized锁</p><h2 id="乐观锁cas"><a href="#乐观锁cas" class="headerlink" title="乐观锁cas"></a>乐观锁cas</h2><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><h4 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h4><p>分段锁</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch latch = new CountDonwLatch(100);</span><br><span class="line"></span><br><span class="line">latch.CountDown();会让其内置计数减一</span><br><span class="line"></span><br><span class="line">latch.await();会阻塞当前线程的方法，等待内置计数为0后才继续执行</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>就是通过Lock+condition来实现的，它的核心方法await，就是来一个线程先加锁，然后计数减一，然后如果没有满员，就调condition的await进等待队列，然后释放锁，下一个线程做同样的事情，直到满员以后就发车，signalAll并且初始化count</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier barrier = new CyclicBarrier(20,()-&gt;&#123;</span><br><span class="line">   System.out.println(&quot;满人！发车！&quot;);</span><br><span class="line">&#125;);//等待20个线程，然后会出发</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">   new Thread(()-&gt;&#123;</span><br><span class="line">      barrier.await();//当来一个线程就阻塞住，直到20个线程放行</span><br><span class="line">      System.out.println(&quot;20个齐了！我出发了&quot;);</span><br><span class="line">   &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//每个线程来都加锁跑下面的</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">            <span class="comment">//这里是寻找的最后一个线程到来的选出</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//初始化count为parties</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        <span class="comment">//来一个线程就进等待池，然后释放锁</span></span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读写锁 读锁为共享锁，与写锁冲突 写锁为独占锁，与写锁、读锁都冲突 适合读多写少的场景</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">信号量 同步pv操作  限流 有几个信号量，就允许几个线程同时获得信号量并运行</span><br><span class="line">Semaphore s = new Semaphore(1);</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">   try&#123;</span><br><span class="line">      s.acquire();//阻塞方法</span><br><span class="line">      System.out.println(&quot;T1 running&quot;);</span><br><span class="line">   &#125;catch(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;finally&#123;</span><br><span class="line">      s.release();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">   try&#123;</span><br><span class="line">      s.acquire();//阻塞方法</span><br><span class="line">      System.out.println(&quot;T2 running&quot;);</span><br><span class="line">   &#125;catch(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;finally&#123;</span><br><span class="line">      s.release();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Semaphore s1 = new Semaphore(4,true);//true表示公平</span><br><span class="line">队列先进先出获得信号量保证公平</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">两个线程间的数据交换</span><br><span class="line">Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">   String s = &quot;T1&quot;;</span><br><span class="line">   try&#123;</span><br><span class="line">      s = exchanger.exchange(s);//阻塞方法</span><br><span class="line">   &#125;catch(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,&quot;T1&quot;).start();</span><br><span class="line"></span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">   String s = &quot;T2&quot;;</span><br><span class="line">   try&#123;</span><br><span class="line">      s = exchanger.exchange(s);//阻塞方法，等另一个线程执行到这的时候交换数据，并解除阻塞，也可以设置时间，超时了就失败</span><br><span class="line">   &#125;catch(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,&quot;T2&quot;).start();</span><br></pre></td></tr></table></figure><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>这个容器类为什么出现？<br>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：</p><p>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；<br>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。<br>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。  </p><p>因为ArrayList类在多线程情况下是线程不安全的，要在并发场景使用的话，两种:</p><ul><li>Collections.SyncronizedList，就是使用synchronized关键字包装了一下</li><li>CopyOnWriteArrayList 使用了非公平Lock加锁，以及内部的数据存储在数组中，数组被volatile修饰</li></ul><p>这个类使用的方式也很奇怪，不是加完锁以后就对原数组操作，而是利用了volatile的可见性，修改数组内存地址对volatile是可见的。<br>因此将原数组拷贝了一份，在新数组上修改，然后将原数组的索引修改成新数组。<br>这样操作完以后新数组的值对其他线程也是立即可见的。</p><p>总结一下就是：</p><ol><li>对数组的写操作加锁，读操作不加锁；</li><li>通过加锁 + 数组拷贝+ volatile 来保证线程安全；</li></ol><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LockSuporrt.park()与unpack()//方法不需要锁对象即可实现</span><br><span class="line">wait()/notify()的方法</span><br><span class="line">而且unpark方法可限于park方法执行</span><br></pre></td></tr></table></figure><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2>]]></content>
      
      
      
        <tags>
            
            <tag> java并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java引用关系</title>
      <link href="/2020/07/01/java%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
      <url>/2020/07/01/java%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树原理详解</title>
      <link href="/2020/06/18/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/06/18/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树原理详解"><a href="#红黑树原理详解" class="headerlink" title="红黑树原理详解"></a>红黑树原理详解</h1><p>在java中TreeMap为了利用到二叉排序树的特性，底层采用的是红黑树，HashMap在jdk1.8版本中将链式解决冲突修改为了使用红黑树来解决冲突。</p><p>只有当我们了解了这些数据结构底层的实现的时候才能更好运用这些数据结构。</p><p>红黑树是一颗完全平衡排序二叉树，自身具有平衡二叉树与排序二叉树的特点。</p><h3 id="红黑树自身具有的基本规则特点"><a href="#红黑树自身具有的基本规则特点" class="headerlink" title="红黑树自身具有的基本规则特点:"></a>红黑树自身具有的基本规则特点:</h3><ol><li>节点分为红色与黑色</li><li>根节点必为黑色</li><li>叶子节点都为黑色，且为空</li><li>如果一个节点是红的，那么其两个子节点都是黑色的，即一条路径上不会出现连续的红色节点</li><li>从任意节点出发到其叶子节点的所有路径都具有相同的黑色节点数目</li><li>新加入红黑树的节点为红色节点</li></ol><h3 id="红黑树自平衡的基本操作"><a href="#红黑树自平衡的基本操作" class="headerlink" title="红黑树自平衡的基本操作:"></a>红黑树自平衡的基本操作:</h3><ol><li>变色: 在遵循上述特点的情况下进行必要的由黑变红或者由红变黑操作</li><li>左旋: 逆时针旋转</li><li>右旋: 顺时针旋转</li></ol><h3 id="插入新节点需要调整红黑树的的情况"><a href="#插入新节点需要调整红黑树的的情况" class="headerlink" title="插入新节点需要调整红黑树的的情况:"></a>插入新节点需要调整红黑树的的情况:</h3><p>(<strong>ps</strong>:每次插入都遵循规则进行调整的话，那如果父节点是红，那父父节点一定是黑的)</p><p>(<strong>ps</strong>:对于父节点是黑的情况，插入的节点为红，没有冲突，不需要进行调整)<br>(<strong>ps</strong>:以下统一将父节点的兄弟节点称为叔父节点)</p><h4 id="第一种情况-父节点为红，叔父节点为红"><a href="#第一种情况-父节点为红，叔父节点为红" class="headerlink" title="第一种情况 父节点为红，叔父节点为红"></a>第一种情况 父节点为红，叔父节点为红</h4><p>插入的节点不论是父节点的左孩子还是有右孩子都只需要对父节点和叔父节点进行颜色翻转为黑色，同时将父父节点颜色翻转为红色即可。 </p><p><img src="%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="第一种情况"></p><p>(这个节点就算是调整完了，接着对父父节点进行调整即可)</p><h4 id="第二种情况-父节点为红，叔父节点为空-黑"><a href="#第二种情况-父节点为红，叔父节点为空-黑" class="headerlink" title="第二种情况 父节点为红，叔父节点为空/黑"></a>第二种情况 父节点为红，叔父节点为空/黑</h4><ol><li>父节点是父父节点的左孩子，插入节点为父节点的左孩子</li></ol><p><img src="%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5LL.png" alt="第二种情况LL旋转"></p><p>此时进行父父节点(此时主角是父父节点)的LL旋转（右单旋转）即可</p><ol start="2"><li>父节点是父父节点的右孩子，插入节点为父节点的右孩子</li></ol><p><img src="%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5RR.png" alt="第二种情况RR旋转"></p><p>此时进行父父节点(此时主角是父父节点)的RR旋转（左单旋转）即可</p><ol start="3"><li>父节点是父父节点的左孩子，插入节点为父节点的右孩子</li></ol><p><img src="%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5LR.png" alt="第二种情况LR旋转"></p><p>此时先进行父节点的左单旋转，再进行父父节点的右单旋转即可（注意执行旋转的是哪个节点）</p><ol start="4"><li>父节点是父父节点的右孩子，插入节点为父节点的左孩子</li></ol><p><img src="%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5RL.png" alt="第二种情况RL旋转"></p><p>此时先进行父节点的右单旋转，再进行父父节点的左单旋转即可（注意执行旋转的是哪个节点）</p><p>以上思路是红黑树插入一个节点时应对不同情况做的调整。</p><h3 id="TreeMap实际实现"><a href="#TreeMap实际实现" class="headerlink" title="TreeMap实际实现"></a>TreeMap实际实现</h3><h4 id="TreeMap成员变量与构造函数"><a href="#TreeMap成员变量与构造函数" class="headerlink" title="TreeMap成员变量与构造函数"></a>TreeMap成员变量与构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeMap是可以自动排序的，默认情况下comparator为null，能自定* 义比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeMap的存储结构既然是红黑树，那么必然会有唯一的根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map中key-val对的数量，也即是红黑树中节点Entry的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树结构的调整次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造函数，按照key的自然顺序排列</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;comparator = <span class="literal">null</span>;&#125;</span><br><span class="line"><span class="comment">//传递Comparator具体实现，按照该实现规则进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;<span class="built_in">this</span>.comparator = comparator;&#125;</span><br><span class="line"><span class="comment">//传递一个map实体构建TreeMap,按照默认规则排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传递一个map实体构建TreeMap,按照传递的map的排序规则进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeMap的节点"><a href="#TreeMap的节点" class="headerlink" title="TreeMap的节点"></a>TreeMap的节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//key,val是存储的原始数据</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">//定义了节点的左孩子</span></span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    <span class="comment">//定义了节点的右孩子</span></span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">//通过该节点可以反过来往上找到自己的父亲</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">//默认情况下为黑色节点，可调整</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取节点的key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取节点的value值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用新值替换当前值，并返回当前值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="built_in">this</span>.value;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">keyHash</span> <span class="operator">=</span> (key==<span class="literal">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">valueHash</span> <span class="operator">=</span> (value==<span class="literal">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeMap的put方法"><a href="#TreeMap的put方法" class="headerlink" title="TreeMap的put方法"></a>TreeMap的put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果根节点都为null，还没建立起来红黑树，我们先new Entry</span></span><br><span class="line"><span class="comment">     * 并赋值给root把红黑树建立起来，这个时候红</span></span><br><span class="line"><span class="comment">     * 黑树中已经有一个节点了，同时修改操作+1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        compare(key, key); </span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果节点不为null,定义一个cmp，这个变量用来进行二分查找时的比较；定义parent，是new Entry时必须</span></span><br><span class="line"><span class="comment">     * 要的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// cpr表示有无自己定义的排序规则，分两种情况遍历执行</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从root节点开始遍历，通过二分查找逐步向下找</span></span><br><span class="line"><span class="comment">         * 第一次循环：从根节点开始，这个时候parent就是根节点，然后通过自定义的排序算法</span></span><br><span class="line"><span class="comment">         * cpr.compare(key, t.key)比较传入的key和根节点的key值，如果传入的key&lt;root.key，那么</span></span><br><span class="line"><span class="comment">         * 继续在root的左子树中找，从root的左孩子节点（root.left）开始：如果传入的key&gt;root.key,</span></span><br><span class="line"><span class="comment">         * 那么继续在root的右子树中找，从root的右孩子节点（root.right）开始;如果恰好key==root.key，</span></span><br><span class="line"><span class="comment">         * 那么直接根据root节点的value值即可。</span></span><br><span class="line"><span class="comment">         * 后面的循环规则一样，当遍历到的当前节点作为起始节点，逐步往下找</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 需要注意的是：这里并没有对key是否为null进行判断，建议自己的实现Comparator时应该要考虑在内</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从这里看出，当默认排序时，key值是不能为null的</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">        <span class="comment">//这里的实现逻辑和上面一样，都是通过二分查找，就不再多说了</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 能执行到这里，说明前面并没有找到相同的key,节点已经遍历到最后了，我们只需要new一个Entry放到</span></span><br><span class="line"><span class="comment">     * parent下面即可，但放到左子节点上还是右子节点上，就需要按照红黑树的规则来。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点加进去了，并不算完，我们在前面红黑树原理章节提到过，一般情况下加入节点都会对红黑树的结构造成</span></span><br><span class="line"><span class="comment">     * 破坏，我们需要通过一些操作来进行自动平衡处置，如【变色】【左旋】【右旋】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码分析可知，treeMap插入一个节点是直接插入到叶子节点，然后调用fixAfterInsertion(e)方法进行调整，下面看fixAfterInsertion(e)这个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">//新插入的节点为红色节点</span></span><br><span class="line">    x.color = RED;</span><br><span class="line">    <span class="comment">//我们知道父节点为黑色时，并不需要进行树结构调整，只有当父节点为红色时，才需要调整</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="comment">//如果父节点是左节点，对应上表中情况1和情况2</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">//如果叔父节点为红色，对应于“父节点和叔父节点都为红色”，此时通过变色即可实现平衡</span></span><br><span class="line">            <span class="comment">//此时父节点和叔父节点都设置为黑色，祖父节点设置为红色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">//此处就是颜色翻转</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果插入节点是黑色，插入的是右子节点，通过【左右节点旋转】（这里先进行父节点左旋）</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//设置父节点和父父节点颜色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//进行父父节点右旋（这里【变色】和【旋转】并没有严格的先后顺序，达成目的就行）</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//父节点是右节点的情况</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">//对应于“父节点和叔父节点都为红色”，此时通过变色即可实现平衡</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果插入节点是黑色，插入的是左子节点，通过【右左节点旋转】（这里先进行父节点右旋）</span></span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                    <span class="comment">//这里将x设置为了父节点，旋转完成以后实际上x即父节点的位置变为了新插入节点的右孩子</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//进行祖父节点左旋（这里【变色】和【旋转】并没有严格的先后顺序，达成目的就行）</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根节点必须为黑色</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码分析可知，其节点调整思路与我们之前讨论的两种情况完全一模一样，会一直跟节点方向进行调整，直到为null或者为根节点或者当前节点不为红才结束循环。<br>然后学习一下针对一个节点左旋或者右旋包括了哪些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;<span class="comment">//p的右孩子逆时针旋转</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 断开当前节点p与其右子节点的关联，重新将节点p的右子节点的地址指向节点p的右子节点的左子节点</span></span><br><span class="line"><span class="comment">         * 这个时候节点r没有父节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="comment">//将节点p作为节点r的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="literal">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        <span class="comment">//将节点p的父节点和r的父节点指向同一处</span></span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="comment">//p的父节点为null，则将节点r设置为root</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="literal">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="comment">//如果节点p是左子节点，则将该左子节点替换为节点r</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="comment">//如果节点p为右子节点，则将该右子节点替换为节点r</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        <span class="comment">//重新建立p与r的关系</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeMap方法的get方法分为默认笔记器与自定义比较器的方法，方法使用的就是二叉排序树的遍历方法，比较简单，直接跳过。</p><p>TreeMap除了插入完需要调整外，当删除一个节点时也需要调整。<br>TreeMap的删除操作有时间再看。</p><h1 id="打个tag-treeMap删除-参考链接TreeMap实现原理详解"><a href="#打个tag-treeMap删除-参考链接TreeMap实现原理详解" class="headerlink" title="打个tag treeMap删除 参考链接TreeMap实现原理详解"></a>打个tag treeMap删除 参考链接<a href="https://www.cnblogs.com/LiaHon/p/11221634.html">TreeMap实现原理详解</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计阶段都应该画什么图呢</title>
      <link href="/2020/06/10/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E9%83%BD%E5%BA%94%E8%AF%A5%E7%94%BB%E4%BB%80%E4%B9%88%E5%9B%BE%E5%91%A2/"/>
      <url>/2020/06/10/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E9%83%BD%E5%BA%94%E8%AF%A5%E7%94%BB%E4%BB%80%E4%B9%88%E5%9B%BE%E5%91%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="软件设计阶段都应该画什么图呢"><a href="#软件设计阶段都应该画什么图呢" class="headerlink" title="软件设计阶段都应该画什么图呢?"></a>软件设计阶段都应该画什么图呢?</h1><h2 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h2><p><strong>数据流图</strong> 是建立功能模型的基础。<br><strong>状态转换图</strong> 描绘了系统的各种行为模式和在不同状态间转换的方式。</p><h2 id="概要设计阶段"><a href="#概要设计阶段" class="headerlink" title="概要设计阶段"></a>概要设计阶段</h2><p><strong>用例图</strong><br><strong>活动图</strong><br><strong>泳道图</strong><br><strong>结构图</strong></p><h2 id="详细设计阶段"><a href="#详细设计阶段" class="headerlink" title="详细设计阶段"></a>详细设计阶段</h2><p><strong>时序图</strong><br><strong>类图</strong></p><h3 id="（记录一下）软件设计各阶段该做什么？"><a href="#（记录一下）软件设计各阶段该做什么？" class="headerlink" title="（记录一下）软件设计各阶段该做什么？"></a>（记录一下）软件设计各阶段该做什么？</h3><p><img src="%E5%9B%BE1.jpg" alt="软件设计各阶段笔记"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 需求分析 </tag>
            
            <tag> 概要设计 </tag>
            
            <tag> 详细设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompareAndSwap原理详解</title>
      <link href="/2020/06/03/CompareAndSwap%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/06/03/CompareAndSwap%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="CompareAndSwap原理详解"><a href="#CompareAndSwap原理详解" class="headerlink" title="CompareAndSwap原理详解"></a>CompareAndSwap原理详解</h1><p>谈到CAS操作就离不开原子类，在多个线程中对同一变量进行操作需要加锁，否则会存在线程安全问题，但是在多个线程对原子类进行操作的时候不需要加锁原因就是使用了CAS。</p><p>CAS即CompareAndSwap比较与交换，又称为无锁、自选锁、乐观锁。</p><p>以AtomicInteger i = new AtomicInteger(1)为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>类中包含两个静态变量，</p><ul><li>一个是unsafe实例</li><li>一个是valueOffset值，表示value这个值在主内存中的偏移量，用于使用unsafe类直接对该内存地址的值进行操作。</li></ul><p>还包含一个volatile修饰的value变量，保证每次读取value都能获得当前最新值。对于volatile详见<a href="https://saaaaaail.gitee.io/2020/05/24/volatile%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">volatile原理详解</a></p><p>然后观察一下AtomicInteger的成员方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the current value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets to the given value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Eventually sets to the given value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    unsafe.putOrderedInt(<span class="built_in">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets to the given value and returns the old value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="built_in">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AtomicInteger的所有成员方法总结一下最终会调用到unsafe类的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafe.putOrderedInt(this, valueOffset, newValue);</span><br></pre></td></tr></table></figure><p>以上 unsafe类的有序写入native方法，只保证写入有序性，不保证可见性，即一个线程写入这个值不保证其他线程立即可见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafe.compareAndSwapInt(this, valueOffset, expect, update);//比较valueOffset偏移地址对应的值是否等于expect，等于则更新update到偏移地址</span><br></pre></td></tr></table></figure><p>以上 unsafe类的cas native方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, delta);<span class="comment">//加delta到当前偏移地址的值上面去</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">        <span class="type">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getAndAddInt方法不是unsafe类的native方法，采用循环的方式完成cas加法:</p><ol><li>先读取内存偏移地址var2的值var5</li><li>然后使用cas方法，比较值var5与当前偏移地址var2里的值，相等的话就更新var5+var4</li><li>否则循环重新读取内存偏移地址var2的值var5，执行1、2两步</li></ol><p>图解:<br><img src="%E5%9B%BE1.jpeg" alt="cas原理图解"></p><p>因此compareAndSwapInt必须是原子性的操作，保证E与当前值N比较与更新V的操作不会被其他线程中断。</p><h2 id="hotspot层面CompareAndSwap源码"><a href="#hotspot层面CompareAndSwap源码" class="headerlink" title="hotspot层面CompareAndSwap源码"></a>hotspot层面CompareAndSwap源码</h2><p>jdk8u: unsafe.cpp:</p><p>cmpxchg = compare and exchange</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp</p><p>is_MP = Multi Processor  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: os.hpp is_MP()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_IF_MP(mp) <span class="string">&quot;cmp $0, &quot;</span> #mp <span class="string">&quot;; je 1f; lock; 1: &quot;</span></span></span><br></pre></td></tr></table></figure><p>LOCK_IF_MP(mp)宏定义 如果是多个cpu就加lock。</p><p>这段汇编代码</p><p>lock cmpxchgl 对cpu的读、比较、写操作加了锁，至于cpu加锁的方式有总线锁、高速缓存锁+缓存一致性协议，目前一般的cpu能支持缓存锁的都会使用缓存锁，不支持或者不能使用缓存锁时才会使用总线锁。</p><p>总线锁保证了某一时刻只有一个cpu核心能使用总线。</p><p>高速缓存锁+缓存一致性协议只得是cpu核心对自己得高速缓存进行管理，如果它读取得数据只位于一个缓存行中，就会将</p>]]></content>
      
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> java并发 </tag>
            
            <tag> CAS </tag>
            
            <tag> jdk1.8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象内存布局</title>
      <link href="/2020/06/02/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
      <url>/2020/06/02/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="对象内存布局详解"><a href="#对象内存布局详解" class="headerlink" title="对象内存布局详解"></a>对象内存布局详解</h1><p>ps:使用JOL插件能查看打印对象的内存布局情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br></pre></td></tr></table></figure><p>创建一个新对象的内存布局。<br>在一个64位系统中，一般安装的JVM也是64位，其指针也是64位的即8字节，但是一般开启了类型指针压缩，为4字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:UseCompressedClassPointers //开启类型指针压缩</span><br><span class="line">-XX:UseCompressedOops //开启普通指针压缩，对于堆内存低于4G会强制使用压缩指针，堆内存高于32G会强制使用8字节指针</span><br></pre></td></tr></table></figure><p>一个Object对象包括8个字节的markword、被压缩过的类型指针ClassPointer 4个字节。两部分合起来12字节为对象头。<br>但是Object对象没有成员对象，大小为0，对象大小要8个字节对齐，为了提高cpu访问内存的效率，cpu访问内存数据是直接读取8个字节，如果跨段放不对齐就很有可能需要读取两次。</p><p>那么最后会补齐4个字节，一个Object对象的大小是16字节。如果没有开启类型指针压缩，一个Object对象仍然是16字节，因为不需要填充字节。</p><p>为什么要对齐，cpu读取内存，按照总线带宽一次读取64位。</p><h2 id="8字节的markword"><a href="#8字节的markword" class="headerlink" title="8字节的markword"></a>8字节的markword</h2><p>关于synchronized对象锁的信息、与GC的信息记录在markword里面，根据锁的类型markword占用8个字节的方式也不一样。</p><table><thead><tr><th align="left">锁状态</th><th align="center">25位</th><th align="center">31位</th><th align="center">1位</th><th align="center">4bit</th><th align="center">1bit偏向锁位</th><th align="right">2bit锁标志位</th></tr></thead><tbody><tr><td align="left">无锁态(new)</td><td align="center">unused</td><td align="center">identity hashCode（调用了hashCode方法会存进来）</td><td align="center">unused</td><td align="center">分代年龄</td><td align="center">0</td><td align="right">01</td></tr></tbody></table><table><thead><tr><th align="left">锁状态</th><th align="center">54位</th><th align="center">2位</th><th align="center">1位</th><th align="center">4bit</th><th align="center">1bit偏向锁位</th><th align="right">2bit锁标志位</th></tr></thead><tbody><tr><td align="left">偏向锁</td><td align="center">当前线程指针JavaThread*</td><td align="center">Epoch</td><td align="center">unused</td><td align="center">分代年龄</td><td align="center">1</td><td align="right">01</td></tr></tbody></table><table><thead><tr><th align="left">锁状态</th><th align="center">62位</th><th align="right">2bit锁标志位</th></tr></thead><tbody><tr><td align="left">轻量级锁\自选锁\无锁</td><td align="center">指向线程栈中LockRecord的指针</td><td align="right">00</td></tr><tr><td align="left">重量级锁</td><td align="center">指向互斥量（重量级锁）的指针</td><td align="right">10</td></tr><tr><td align="left">GC标记信息</td><td align="center">CMS过程用到的标记信息</td><td align="right">11</td></tr></tbody></table><h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><p>当第一次加锁时候，这个时候加的就是偏向锁，这个偏向锁就是在markWord里面java线程指针指向当前线程。</p><p>当第一个线程执行期间，这时候又一条线程来获取锁，这时候会存在一个锁竞争，这时候撤销老线程的偏向锁（<strong>怎么撤销呢？新线程通知老线程stop the world</strong>），</p><p>两条线程（先在线程堆栈里开一个锁记录的空间，把锁对象markword的拷贝进来）采用自旋的方式（拿着锁对象的markword去cas，markword没改就把锁对象的前62位设置为当前线程锁记录的指针）将自己线程栈的锁记录的指针放到锁的markWord中，谁写成功了谁就获得这个轻量级锁（获得轻量级锁以后将锁记录的Owner指针指向锁对象的markword），这个轻量级锁是位于用户态的，申请下来也很快不占资源，但是自旋是消耗cpu的，如果太多线程长时间自旋，cpu很容易也就占满了，因此必须升级的。（自旋是什么意思呢，就是不停读锁的markWord出来，看是不是可以修改了，如果可以就将自己的锁记录的指针贴到markWord里面，如果不可以循环自旋）   </p><p>最后轻量级锁重入的实现:  首先构建一个无锁状态的displace markword（如果已经是轻量级锁的话，猜想根据markword的指针读对应锁记录出来，最后两位拼接01），然后CAS失败，说明不是无锁了，然后判断是不是锁重入（估计是读上一个锁记录的Owner指针指的是不是这个锁对象），如果是的，就将最新的锁记录的displace markword置null，然后这个锁记录的Owner也指向锁对象的markword，重入的时候建的锁记录的displace markword是null，只有第一次不为null  </p><p>轻量级锁解锁:  cas替换displace markword到锁对象markword成功则解锁成功（如果displace markword为null什么也不做，说明重入了），如果失败则膨胀成重量级锁以后再解锁。【BUT为什么会解锁失败？】</p><p>如果一个线程占着这个锁太久了，另一条线程疯狂自旋也拿不到锁，jvm会有个自适应自旋Adaptive Self Spinning的过程，当自选次数达到多少次了，就要升级到重量级锁。</p><p>膨胀为重量级锁时，如果是另一个线程B自旋太多次导致的，另一个线程B直接阻塞，因为轻量级锁这个线程A还在用cpu呢，那么这时候锁对象头被改了，markword存的是指向mutex的指针，锁标志位也变成10了，这时候A线程指向结束了，想解锁轻量级锁发现解锁失败了，说明已经是重量级锁了吧，先获得重量级锁，再解锁。让出资源。</p><h4 id="ps-重量级锁是什么"><a href="#ps-重量级锁是什么" class="headerlink" title="ps:重量级锁是什么"></a>ps:重量级锁是什么</h4><p>首先明确用户态与内核态，某些系统调用的操作，只能在内核态调用。那么这里的重量级锁就必须在内核态分配一个mutex结构（操作系统的互斥量）给某个线程，然后java里这个锁的markWord填的就是指向这个mutex的指针。</p><h4 id="升级为重量级锁以后有什么好处呢？"><a href="#升级为重量级锁以后有什么好处呢？" class="headerlink" title="升级为重量级锁以后有什么好处呢？"></a>升级为重量级锁以后有什么好处呢？</h4><p>获得的重量级锁对象以后，当前线程会占用cpu继续执行，而其他争夺锁的线程不再自旋消耗cpu资源而是进入到一个锁竞争队列，并且进入阻塞态。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>就是JIT编译的时候，去除不可能存在共享资源竞争的锁，什么意思呢？就是这个资源只能被某一个线程访问，不存在锁竞争但是代码里面是加了锁的。这时候呢去除这个锁避免加锁消耗资源。</p><p>以马士兵老师举例说明一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s1,String s2)</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(si).append(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子中，StringBuffer的append方法是加了synchronized修饰的，但是这个sb只能在这个方法中使用，是一个局部变量引用，只能被单一线程占用，因此会消除sb内部的加锁操作。</p><p>ps:在看视频的时候老师讲到了逃逸分析：是指我new出一个对象来，在内存分配过程中，发现这个对象只是在这个方法里使用，这个对象内存直接分配在栈上。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>就是将加锁的范围扩大，还是以马士兵老师的例子为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">        sb.append(str);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里jvm针对100次循环的加锁操作，将加锁的范围扩大到了循环外加一次锁即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile原理分析</title>
      <link href="/2020/05/24/volatile%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/24/volatile%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="volatile原理详解"><a href="#volatile原理详解" class="headerlink" title="volatile原理详解"></a>volatile原理详解</h1><h2 id="volatile基础含义"><a href="#volatile基础含义" class="headerlink" title="volatile基础含义:"></a>volatile基础含义:</h2><ol><li>可见性 （一个线程对数据进行的修改对其他线程都是可见的） 即指的是被volatile修饰的变量在读取数据的时候呢，会从主内存读到各级缓存然后读到cpu里面，写的时候呢除了写到三级缓存里面，还会直接写到主内存里面，这样其他cpu的缓存如果保存了这条修改的缓存行通过总线嗅探到缓存值失效了就从主存重新读一下，保证数据可见性。</li><li>禁止指令重排序 （禁止jvm为了优化字节码指令而对打乱指令的执行顺序）（dcl单例是否需要加volatile）</li></ol><h2 id="补充基础知识"><a href="#补充基础知识" class="headerlink" title="补充基础知识:"></a>补充基础知识:</h2><p>一台计算机的组成包括一个cpu、内存、磁盘、其他外设、驱动，cpu与内存之间进行数据交换，内存与硬盘进行数据交换。<br>由于cpu与内存的速度相差100倍，为了提高数据交互效率，在cpu与内存之间添加了三级缓存。<br>多核cpu与内存结构如下:</p><p><img src="%E5%9B%BE1.png" alt="多核cpu结构"></p><p>上图主板上两个cpu，每个cpu有两个核，每个核内有独立的L1、L2缓存，每个cpu的核都共享主板上的属于自己cpu的L3缓存，所有的cpu共享主内存。<br>一般来讲，一个cpu核只能只能被一个线程占用（所谓线程是cpu调度的基本单位，线程会占用cpu的寄存器，切换线程会保存现场），但是支持超线程的cpu中（例:四核八线程）有两套寄存器，可以同时跑两个线程，切换只是alu的切换。<br>JMM模型的主内存与线程工作内存的真面目就是主内存与缓存。</p><h3 id="缓存行-cache-line-缓存一致性协议-与volatile无关的"><a href="#缓存行-cache-line-缓存一致性协议-与volatile无关的" class="headerlink" title="缓存行 cache line 缓存一致性协议 与volatile无关的"></a>缓存行 cache line 缓存一致性协议 与volatile无关的</h3><p>指从内存中读取数据一次读取的是一个数据块，其大小是64Byte。<br>如果数据X和数据Y位于同一缓存行，这个缓存行同时被cpu核A和cpu核B读取，每次cpu核A的修改数据X到缓存L1中并未立即将X写入RAM，cpu核B读取的缓存行中包括数据X，以及其他所有cpu核发现自己的高速缓存包含这个数据的缓存行就会收到通知，使自身的缓存行失效，然后等cpu核A将数据写到RAM中后重新从RAM中读取缓存行到高速缓存里。</p><p>所以当cpu核A对数据X写，cpu核B对数据Y写，即便不是同一个数据由于存在于同一缓存行，每次修改自身数据到缓存都会使其他缓存行失效，并重新从内存读取，效率会下降。</p><p>缓存行会依次从主内存-&gt;L3-&gt;L2-&gt;L1。</p><h2 id="volatile的五层实现"><a href="#volatile的五层实现" class="headerlink" title="volatile的五层实现:"></a>volatile的五层实现:</h2><ol><li>java源码</li><li>ByteCode字节码</li><li>JVM虚拟机规范</li><li>Hotspot实现</li><li>CPU级别</li></ol><h3 id="java源码"><a href="#java源码" class="headerlink" title="java源码"></a>java源码</h3><p>volatile int i;</p><h3 id="ByteCode字节码"><a href="#ByteCode字节码" class="headerlink" title="ByteCode字节码"></a>ByteCode字节码</h3><p>Access flags: Acc_volatile<br>在字节码中为这个i添加了一个标记，标记为Acc_volatile</p><h3 id="JVM虚拟机规范"><a href="#JVM虚拟机规范" class="headerlink" title="JVM虚拟机规范"></a>JVM虚拟机规范</h3><p>对于volatile的基础含义，JVM设计了一部分规范来达成这两条基础含义。</p><p>首先是规定了八种happens-before原则（JVM规定对指令重排序要遵守的原则）<br>为了禁止指令重排序的发生，在两条指令之间添加一条fence或者barriar，内存屏障。</p><p>JVM层级的有四条逻辑层面的内存屏障，即要求所有的jvm都实现的规范:</p><ul><li>LoadLoad屏障：对于连续的读操作，保证屏障前面的读操作一定在屏障后面的读操作前完成。</li><li>StoreStore屏障：对于连续的写操作，保证屏障前面的写操作一定在屏障后面的写操作前完成。</li><li>LoadStore屏障：对于连续读写操作，保证屏障前面的读操作一定在屏障后面的写操作前完成。</li><li>StoreLoad屏障：对于连续的写读操作，保证屏障前面的写操作一定在屏障后面的读操作前完成。</li></ul><p>那么当使用volatile修饰一个变量时，对这个变量所占的内存进行读写前后都会加上内存屏障。</p><hr><ul><li>StoreStoreBarrier</li><li>volatile写</li><li>StoreLoadBarrier</li></ul><hr><ul><li>volatile读</li><li>LoadLoadBarrier</li><li>LoadStoreBarrier</li></ul><hr><p>在volatile变量读写前后会设置内存屏障。<br>StoreStoreBarrier屏障保证屏障之前volatile写操作一定完成于屏障之后的volatile写操作之前<br>StoreLoadBarrier屏障保证屏障之前的volatile写操作一定完成于volatile读操作之前<br>LoadLoadBarrier屏障保证屏障之前的volatile读操作一定完成于屏障之后的volatile读操作之前<br>LoadStoreBarrier屏障保证屏障之前的volatile读操作一定发生于屏障之后的volatile写操作之前</p><p>以上是JVM层面对volatile实现的要求规范，为了实现volatile的基本含义。</p><h3 id="Hotspot实现"><a href="#Hotspot实现" class="headerlink" title="Hotspot实现"></a>Hotspot实现</h3><p>为了实现上述的内存屏障，hotspot在将class文件加载到内存中以后会翻译成字节码指令并编译为当前机器cpu的机器语言，为了查看这种机器语言，可以使用HSDIS工具反汇编字节码生成的机器码为汇编代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static volatile int i = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for(int i=0;i&lt;1000000;i++)&#123;</span><br><span class="line">            m();</span><br><span class="line">            n();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void m()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void n()&#123;</span><br><span class="line">        i=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly java文件 &gt;&gt; 1.txt</span><br></pre></td></tr></table></figure><p>生成汇编代码导入到1.txt文件</p><p>查看汇编代码可知，在i的赋值之前判断如果是多处理器就的lock addl $0x0,(%rsp) 指令，这条指令加上了lock前缀，这个对寄存器加0的空操作，没有实际意义，只是保证当前cpu持有了总线锁，使本cpu的cache写入主内存，这个操作也会被其他cpu的cache嗅探到从而更新缓存，因此这条指令使得线程只能单条通过且更新内存，保证了内存对其他cpu得可见性。</p><h3 id="CPU级别的实现"><a href="#CPU级别的实现" class="headerlink" title="CPU级别的实现"></a>CPU级别的实现</h3><p>cpu级别的实现除了lock总线锁以外还有一种实现是高速缓存锁。</p><h2 id="例：dcl单例是否需要加volatile-（Double-Check-Lock）"><a href="#例：dcl单例是否需要加volatile-（Double-Check-Lock）" class="headerlink" title="例：dcl单例是否需要加volatile?（Double Check Lock）"></a>例：dcl单例是否需要加volatile?（Double Check Lock）</h2><p>关于单例实现中的双重锁定方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()&#123; ----------------------- A</span><br><span class="line">        if(instance == null)&#123;              ----------------------- B</span><br><span class="line">            synchronized(Singleton.class)&#123; ----------------------- C</span><br><span class="line">                if(instance == null)&#123;      ----------------------- D</span><br><span class="line">                    instance = new Singleton(); ------------------ E</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于此种方式中添加了synchronized锁，保证其中的代码只有一个线程能够执行，且保证加锁的代码具有原子性，理论上来说这一块儿代码不会有什么问题，但是由于jvm会对指令顺序进行优化，那么对于instance = new Singleton()这句代码，反汇编机器码出来的汇编指令包括8条汇编指令。</p><p>主要做了三件事：</p><ol><li>为Singleton对象分配内存空间</li><li>初始化Singleton对象的构造器</li><li>将instance对象指向分配的内存空间 （到这一步认为instance对象非空）</li></ol><p>由于jvm为了优化指令，提高代码效率，允许指令重排序，这样一条代码的指令顺序会被优化成如下的样子：</p><ol><li>为Singleton对象分配内存空间           </li><li>将instancde对象指向分配的内存空间 （到这一步认为instance对象非空）</li><li>初始化Singleton对象的构造器</li></ol><p>因此当线程一执行到E的优化后的第二条指令时，就认为instance非空了，如果这时候恰好线程二执行到B，判断instance非空，并返回了这个instance，由于instance尚未初始化，使用这个对象的时候就报错了。</p><p>因此dcl写法改为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance()&#123; </span><br><span class="line">        if(instance == null)&#123;              </span><br><span class="line">            synchronized(Singleton.class)&#123; </span><br><span class="line">                if(instance == null)&#123;      </span><br><span class="line">                    instance = new Singleton(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java并发 </tag>
            
            <tag> spring </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解importResource与注解import相关知识点</title>
      <link href="/2020/05/19/%E6%B3%A8%E8%A7%A3importResource%E4%B8%8E%E6%B3%A8%E8%A7%A3import%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/05/19/%E6%B3%A8%E8%A7%A3importResource%E4%B8%8E%E6%B3%A8%E8%A7%A3import%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="importResource注解与-import注解"><a href="#importResource注解与-import注解" class="headerlink" title="@importResource注解与@import注解"></a>@importResource注解与@import注解</h1><h2 id="import注解"><a href="#import注解" class="headerlink" title="@import注解"></a>@import注解</h2><p>@import注解用于导入某些特殊的Bean，包括添加了@Configuration注解的类、importSelector接口的实现类、importBeanDefinitionRegiser接口的实现类</p><h3 id="导入-Configuration类"><a href="#导入-Configuration类" class="headerlink" title="导入@Configuration类"></a>导入@Configuration类</h3><p>在springboot中一般使用@CompantScan注解配置扫描的路径，就能自动导入，如果不在扫描的路径下面的配置类就得使用@import注解导入，第三方jar包都需要借助@import注解导入</p><h3 id="导入importSelector接口的实现类"><a href="#导入importSelector接口的实现类" class="headerlink" title="导入importSelector接口的实现类"></a>导入importSelector接口的实现类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        全类名数组 = doSomething获得要加载的全类名数组;</span><br><span class="line">        return 全类名数组;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@import(MyImportSelector.class)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application()&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">        System.out.println(&quot;start success......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种方式便能导入selectImports方法返回的类名数组。<br>案例：参考springboot自动装配</p><h3 id="导入importBeanDefinitionRegiser接口的实现类"><a href="#导入importBeanDefinitionRegiser接口的实现类" class="headerlink" title="导入importBeanDefinitionRegiser接口的实现类"></a>导入importBeanDefinitionRegiser接口的实现类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(TestBean.class);</span><br><span class="line">        registry.registerBeanDefinition(&quot;TestBean&quot;, rootBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@import(MyImportBeanDefinitionRegistrar.class)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application()&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">        System.out.println(&quot;start success......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了在springboot启动阶段动态地向容器中注册Bean Definition。<br>案例：MapperScan导入容器的原理</p><h2 id="importResource注解"><a href="#importResource注解" class="headerlink" title="@importResource注解"></a>@importResource注解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface ImportResource &#123;</span><br><span class="line">    @AliasFor(&quot;locations&quot;)</span><br><span class="line">    String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String[] locations() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanDefinitionReader&gt; reader() default BeanDefinitionReader.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过locations属性加载对应的xml配置文件，同时需要配合@Configuration注解一起使用，定义为配置类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> @import </tag>
            
            <tag> @importResource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解Transactional与多线程、注解Async的关系分析</title>
      <link href="/2020/05/18/%E6%B3%A8%E8%A7%A3Transactional%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E6%B3%A8%E8%A7%A3Async%E7%9A%84%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/18/%E6%B3%A8%E8%A7%A3Transactional%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E6%B3%A8%E8%A7%A3Async%E7%9A%84%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot-springsession-redis分析</title>
      <link href="/2020/05/17/springboot-springsession-redis%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/17/springboot-springsession-redis%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="先总结"><a href="#先总结" class="headerlink" title="先总结"></a>先总结</h1><p>1、spring session redis的核心类为RedisOperationsSessionRepository与SessionRepositoryFilter。<br>2、一个请求打进来会经过SessionRepositoryFilter，这个Filter会将Request包装为SessionRepositoryRequestWrapper，然后重写了getSession方法，要知道获得Session的唯一方法就是这个方法，这个方法会从本地缓存里面取，然后从Cookie里找sessionId然后从redis里面取（同时更新最近访问时间），都没有就新创建一个新的Session。<br>3、Session的保存在一次请求结束的时候使用CommitSession保存到Redis里面，并且由于response的缓冲区有可能通过flush发方法随时被清空，因此response继承OnCommittedResponseWrapper重写了onResponseCommitted的方法保证session能被写入redis。<br>4、被写入的session包含三个key值，key=expired:sessionId，value=无记录 这个键在Redis中的过期时间就是当前session的过期时间 key=sessionId，value=包含session的全部信息，过期时间间隔、最近访问时间、一些attributes等等。还一个key = expiration，value=当前时间节点刚刚过期1分钟的sessionId集合。<br>5、关于登出操作，session.invalidate()会删除key=expired:sessionId，以及expiration集合中刚刚过期的sessionId，关于sessionId的删除是将session有效期设为0，惰性删除。</p><blockquote><p>使用分布式Session的作用是什么？<br>因为服务多机部署，当前端访问后端的时候，请求到了不同的主机上面，能根据cookie里的sessionId获得用户的登录状态</p></blockquote><h1 id="spring-boot-spring-session-redis实现session共享"><a href="#spring-boot-spring-session-redis实现session共享" class="headerlink" title="spring boot+spring session+redis实现session共享"></a>spring boot+spring session+redis实现session共享</h1><h2 id="为什么要实现session共享"><a href="#为什么要实现session共享" class="headerlink" title="为什么要实现session共享"></a>为什么要实现session共享</h2><p>因为目前目前要实现一个校验内核，将登录、鉴权以及其他一些通用操作抽离出来复用。这样一个内核使用起来肯定会搭成分布式结构，部署多个机房多个主机，通过nginx来进行负载均衡。如果不进行session共享，那么session是由tomcat容器管理的，当两次请求分别打进了不同的主机，第二次请求cookie中携带了sessionId，要么sessionId无效重新登录，要么跳过登录使用session时报错，总之体验不好。</p><ul><li>传统Session:request进入web容器，根据request获取Session，如果web容器里面存在Session则返回，如果不存在Session则新创建一个Session放到header或者header的cookie里面，tomcat的SessionId为jsessionid。</li><li>Spring Session:request进入web容器，根据request获取Session，首先会从请求头中获得Session，如果不为空则直接返回，如果请求头里的Session为空，则从cookie里面获取sessionId不为空，则拿着这个sessionId从redis获得session，这个session不为空的话保存这个session到request的header里，并返回这个session。如果从cookie里取得sessionId为空或者redis取出的session为空，就得重新创建一个session，保存一些session参数，并保存到request的header中，返回这个session。</li></ul><h2 id="Spring-Session-Redis快速搭建操作"><a href="#Spring-Session-Redis快速搭建操作" class="headerlink" title="Spring Session + Redis快速搭建操作"></a>Spring Session + Redis快速搭建操作</h2><h3 id="springboot方式"><a href="#springboot方式" class="headerlink" title="springboot方式"></a>springboot方式</h3><ol><li>依赖包如下:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Spring Web --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Spring session --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>使用@EnableRedisHttpSession注解开启使用Spring Session</li><li>redis配置不作介绍</li></ol><h2 id="Spring-Session原理分析"><a href="#Spring-Session原理分析" class="headerlink" title="Spring Session原理分析"></a>Spring Session原理分析</h2><h3 id="EnableRedisHttpSession注解"><a href="#EnableRedisHttpSession注解" class="headerlink" title="@EnableRedisHttpSession注解"></a>@EnableRedisHttpSession注解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;RedisHttpSessionConfiguration.class&#125;)</span><br><span class="line">@Configuration</span><br><span class="line">public @interface EnableRedisHttpSession &#123;</span><br><span class="line">    int maxInactiveIntervalInSeconds() default 1800;</span><br><span class="line"></span><br><span class="line">    String redisNamespace() default &quot;spring:session&quot;;</span><br><span class="line"></span><br><span class="line">    RedisFlushMode redisFlushMode() default RedisFlushMode.ON_SAVE;</span><br><span class="line"></span><br><span class="line">    String cleanupCron() default &quot;0 * * * * *&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由注解可见，导入了RedisHttpSessionConfiguration类</p><h3 id="RedisHttpSessionConfiguration类分析"><a href="#RedisHttpSessionConfiguration类分析" class="headerlink" title="RedisHttpSessionConfiguration类分析"></a>RedisHttpSessionConfiguration类分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class RedisHttpSessionConfiguration extends SpringHttpSessionConfiguration implements BeanClassLoaderAware, EmbeddedValueResolverAware, ImportAware, SchedulingConfigurer &#123;</span><br></pre></td></tr></table></figure><p>该类是一个配置类，父类为SpringHttpSessionConfiguration 稍后分析，实现了EmbeddedValueResolverAware, ImportAware接口</p><p>该配置类获得了从父类SpringHttpSessionConfiguration中创建的SessionRepositoryFilter的Bean类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public &lt;S extends Session&gt; SessionRepositoryFilter&lt;? extends Session&gt; springSessionRepositoryFilter(SessionRepository&lt;S&gt; sessionRepository) &#123;</span><br><span class="line">    SessionRepositoryFilter&lt;S&gt; sessionRepositoryFilter = new SessionRepositoryFilter(sessionRepository);</span><br><span class="line">    sessionRepositoryFilter.setServletContext(this.servletContext);</span><br><span class="line">    sessionRepositoryFilter.setHttpSessionIdResolver(this.httpSessionIdResolver);</span><br><span class="line">    return sessionRepositoryFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建filter需要SessionRepository的Bean，这个类的创建在RedisHttpSessionConfiguration中，由于Spring Session有三种支持分别是redis、mongoDB、jdbc，此处创建的就是redis的sessionRepository类RedisOperationsSessionRepository如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  @Bean</span><br><span class="line">public RedisOperationsSessionRepository sessionRepository() &#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; redisTemplate = this.createRedisTemplate();</span><br><span class="line">    RedisOperationsSessionRepository sessionRepository = new RedisOperationsSessionRepository(redisTemplate);</span><br><span class="line">    sessionRepository.setApplicationEventPublisher(this.applicationEventPublisher);</span><br><span class="line">    if (this.defaultRedisSerializer != null) &#123;</span><br><span class="line">        sessionRepository.setDefaultSerializer(this.defaultRedisSerializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sessionRepository.setDefaultMaxInactiveInterval(this.maxInactiveIntervalInSeconds);</span><br><span class="line">    if (StringUtils.hasText(this.redisNamespace)) &#123;</span><br><span class="line">        sessionRepository.setRedisKeyNamespace(this.redisNamespace);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sessionRepository.setRedisFlushMode(this.redisFlushMode);</span><br><span class="line">    int database = this.resolveDatabase();</span><br><span class="line">    sessionRepository.setDatabase(database);</span><br><span class="line">    return sessionRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，对于session的管理主要是由SessionRepository和SessionRepositoryFilter完成的。</p><h3 id="SessionRepositoryFilter"><a href="#SessionRepositoryFilter" class="headerlink" title="SessionRepositoryFilter"></a>SessionRepositoryFilter</h3><p>@Order(-2147483598)表明这个filter的优先级非常高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;</span><br><span class="line">    request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);</span><br><span class="line">    SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryFilter.SessionRepositoryRequestWrapper(request, response, this.servletContext);</span><br><span class="line">    SessionRepositoryFilter.SessionRepositoryResponseWrapper wrappedResponse = new SessionRepositoryFilter.SessionRepositoryResponseWrapper(wrappedRequest, response);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        filterChain.doFilter(wrappedRequest, wrappedResponse);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        wrappedRequest.commitSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对request和response进行包装，然后向下一个filter传递，在此次调用链结束之前会调用commitSession</p><h3 id="SessionRepositoryRequestWrapper-extends-HttpServletRequestWrapper"><a href="#SessionRepositoryRequestWrapper-extends-HttpServletRequestWrapper" class="headerlink" title="SessionRepositoryRequestWrapper extends HttpServletRequestWrapper"></a>SessionRepositoryRequestWrapper extends HttpServletRequestWrapper</h3><h4 id="commitSession"><a href="#commitSession" class="headerlink" title="commitSession"></a>commitSession</h4><p>commitSession是SessionRepositoryRequestWrapper具有的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">private void commitSession() &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 从当前request的header中获得Session的包装类</span><br><span class="line">    */</span><br><span class="line">    SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper.HttpSessionWrapper wrappedSession = this.getCurrentSession();</span><br><span class="line">    /**</span><br><span class="line">    * 如果header中保存的session为空</span><br><span class="line">    */</span><br><span class="line">    if (wrappedSession == null) &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 判断标志位有没有失效，requestedSessionInvalidated标志位只有在session调invalidate方法后才会设为true表示失效</span><br><span class="line">        */</span><br><span class="line">        if (this.isInvalidateClientSession()) &#123;</span><br><span class="line">            SessionRepositoryFilter.this.httpSessionIdResolver.expireSession(this, this.response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 如果请求header中的Session不为空，则从HttpSessionWrapper中取得ExpiringSession，调用sessionRepository的save方法保存到redis</span><br><span class="line">        */</span><br><span class="line">        S session = wrappedSession.getSession();</span><br><span class="line"></span><br><span class="line">        this.clearRequestedSessionCache();</span><br><span class="line"></span><br><span class="line">        SessionRepositoryFilter.this.sessionRepository.save(session);</span><br><span class="line"></span><br><span class="line">        String sessionId = session.getId();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">        * 判断请求的sessionId是否有效（这里面的标志位requestedSessionIdValid在getSession中被修改为true表示这个sessionId有效，如果requestedSessionIdValid为null会从cookie中取出sessionId从redis中取session不为空就返true）  或者  判断这个当前请求header里的session的id是否与cookie里保存的sessionid相同（getRequestedSessionId()是从cookie中获得当前请求的session），如果不同就执行里面的方法。</span><br><span class="line">        */</span><br><span class="line">        if (!this.isRequestedSessionIdValid() || !sessionId.equals(this.getRequestedSessionId())) &#123;</span><br><span class="line">            //这里就是把session的id添加到response的cookie里</span><br><span class="line">            SessionRepositoryFilter.this.httpSessionIdResolver.setSessionId(this, this.response, sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 从request的header取得当前session对象HttpSessionWrapper</span><br><span class="line">*/</span><br><span class="line">private SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper.HttpSessionWrapper getCurrentSession() &#123;</span><br><span class="line">    return (SessionRepositoryFilter.SessionRepositoryRequestWrapper.HttpSessionWrapper)this.getAttribute(SessionRepositoryFilter.CURRENT_SESSION_ATTR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 此方法判断session失效，1是当前session为空，2是requestedSessionInvalidated为true，这个状态是在HttpSessionWrapper里的invalidate()方法里置true的表示session已失效</span><br><span class="line">*/</span><br><span class="line">private boolean isInvalidateClientSession() &#123;</span><br><span class="line">    return this.getCurrentSession() == null &amp;&amp; this.requestedSessionInvalidated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 该方法是往response中清空cookie</span><br><span class="line">*/</span><br><span class="line">public void expireSession(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    this.cookieSerializer.writeCookieValue(new CookieValue(request, response, &quot;&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 清空请求session，包括已缓存session标志位、requestSession与requestSessionId置空，这几个值都在getRequestedSession()方法中赋值</span><br><span class="line">*/</span><br><span class="line">private void clearRequestedSessionCache() &#123;</span><br><span class="line">    this.requestedSessionCached = false;</span><br><span class="line">    this.requestedSession = null;</span><br><span class="line">    this.requestedSessionId = null;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 更新session的一下参数，如果是新的会话则入redis保存，同时将session置旧</span><br><span class="line">*/</span><br><span class="line">public void save(RedisOperationsSessionRepository.RedisSession session) &#123;</span><br><span class="line">    session.saveDelta();</span><br><span class="line">    if (session.isNew()) &#123;</span><br><span class="line">        String sessionCreatedKey = this.getSessionCreatedChannel(session.getId());</span><br><span class="line">        this.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class="line">        session.setNew(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 这个方法也比较清晰，如果当前请求header里的session的id与WRITTEN_SESSION_ID_ATTR的值不同的话就保存这个sessionId，并写到cookie中</span><br><span class="line">*/</span><br><span class="line">public void setSessionId(HttpServletRequest request, HttpServletResponse response, String sessionId) &#123;</span><br><span class="line">    if (!sessionId.equals(request.getAttribute(WRITTEN_SESSION_ID_ATTR))) &#123;</span><br><span class="line">        request.setAttribute(WRITTEN_SESSION_ID_ATTR, sessionId);</span><br><span class="line">        this.cookieSerializer.writeCookieValue(new CookieValue(request, response, sessionId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getSession"><a href="#getSession" class="headerlink" title="getSession"></a>getSession</h4><p>还有一个方法同样重要就是SessionRepositoryRequestWrapper重写的HttpServletRequestWrapper类的getSession方法，通过这个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper.HttpSessionWrapper getSession(boolean create) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 从request的header中获得Session</span><br><span class="line">    */</span><br><span class="line">    SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper.HttpSessionWrapper currentSession = this.getCurrentSession();</span><br><span class="line">    if (currentSession != null) &#123;</span><br><span class="line">        return currentSession;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 如果requestedSessionCached没有被缓存过为false，则会从cookie中找sessionId并从redis找到session并返回。</span><br><span class="line">        */</span><br><span class="line">        S requestedSession = this.getRequestedSession();</span><br><span class="line">        if (requestedSession != null) &#123;</span><br><span class="line">            if (this.getAttribute(SessionRepositoryFilter.INVALID_SESSION_ID_ATTR) == null) &#123;</span><br><span class="line">                //设置session最近访问的时间</span><br><span class="line">                requestedSession.setLastAccessedTime(Instant.now());</span><br><span class="line">                //设置session有效</span><br><span class="line">                this.requestedSessionIdValid = true;</span><br><span class="line">                //包装ExpiringSession为HttpSessionWrapper</span><br><span class="line">                currentSession = new SessionRepositoryFilter.SessionRepositoryRequestWrapper.HttpSessionWrapper(requestedSession, this.getServletContext());</span><br><span class="line">                currentSession.setNew(false);</span><br><span class="line">                //保存session到header里面，并返回</span><br><span class="line">                this.setCurrentSession(currentSession);</span><br><span class="line">                return currentSession;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (SessionRepositoryFilter.SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                SessionRepositoryFilter.SESSION_LOGGER.debug(&quot;No session found by id: Caching result for getSession(false) for this HttpServletRequest.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //设置header头标志位session无效为true</span><br><span class="line">            this.setAttribute(SessionRepositoryFilter.INVALID_SESSION_ID_ATTR, &quot;true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">        * 上面的操作均未取得session，认为session不存在，create=true就新创建session</span><br><span class="line">        */</span><br><span class="line">        if (!create) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (SessionRepositoryFilter.SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                SessionRepositoryFilter.SESSION_LOGGER.debug(&quot;A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for &quot; + SessionRepositoryFilter.SESSION_LOGGER_NAME, new RuntimeException(&quot;For debugging purposes only (not an error)&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            //通过sessionRepository创建ExpiringSession</span><br><span class="line">            S session = SessionRepositoryFilter.this.sessionRepository.createSession();</span><br><span class="line">            //设置session的最近访问时间</span><br><span class="line">            session.setLastAccessedTime(Instant.now());</span><br><span class="line">            //包装ExpiringSession为HttpSessionWrapper</span><br><span class="line">            currentSession = new SessionRepositoryFilter.SessionRepositoryRequestWrapper.HttpSessionWrapper(session, this.getServletContext());</span><br><span class="line">            //保存新创建的session到header中，并返回这个session</span><br><span class="line">            this.setCurrentSession(currentSession);</span><br><span class="line">            return currentSession;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private S getRequestedSession() &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 这个标志位表示session是否被缓存，为false表示没有缓存的session，进入语句块</span><br><span class="line">    */</span><br><span class="line">    if (!this.requestedSessionCached) &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 这个方法从cookie列表中找到当前session名称的sessionId列表</span><br><span class="line">        */</span><br><span class="line">        List&lt;String&gt; sessionIds = SessionRepositoryFilter.this.httpSessionIdResolver.resolveSessionIds(this);</span><br><span class="line">        Iterator var2 = sessionIds.iterator();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">        * 循环遍历sessionId列表</span><br><span class="line">        */</span><br><span class="line">        while(var2.hasNext()) &#123;</span><br><span class="line">            /**</span><br><span class="line">            * 如果暂存的requestedSessionId为空就先将requestedSessionId置为sessionId</span><br><span class="line">            */</span><br><span class="line">            String sessionId = (String)var2.next();</span><br><span class="line">            if (this.requestedSessionId == null) &#123;</span><br><span class="line">                this.requestedSessionId = sessionId;</span><br><span class="line">            &#125;</span><br><span class="line">            /**</span><br><span class="line">            * 从redis中查找这个sessionId的session，就暂存并跳出循环，返回session，如果没找到session，保存的就是列表中第一个sessionId，并返回空session</span><br><span class="line">            */</span><br><span class="line">            S session = SessionRepositoryFilter.this.sessionRepository.findById(sessionId);</span><br><span class="line">            if (session != null) &#123;</span><br><span class="line">                this.requestedSession = session;</span><br><span class="line">                this.requestedSessionId = sessionId;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        this.requestedSessionCached = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.requestedSession;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 这个方法从cookie列表中找到当前session名称的sessionId列表</span><br><span class="line">*/</span><br><span class="line">public List&lt;String&gt; resolveSessionIds(HttpServletRequest request) &#123;</span><br><span class="line">    return this.cookieSerializer.readCookieValues(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SessionRepositoryResponseWrapper-extends-OnCommittedResponseWrapper"><a href="#SessionRepositoryResponseWrapper-extends-OnCommittedResponseWrapper" class="headerlink" title="SessionRepositoryResponseWrapper extends OnCommittedResponseWrapper"></a>SessionRepositoryResponseWrapper extends OnCommittedResponseWrapper</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private final class SessionRepositoryResponseWrapper extends OnCommittedResponseWrapper &#123;</span><br><span class="line">      private final SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper request;</span><br><span class="line"></span><br><span class="line">      SessionRepositoryResponseWrapper(SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper request, HttpServletResponse response) &#123;</span><br><span class="line">          super(response);</span><br><span class="line">          if (request == null) &#123;</span><br><span class="line">              throw new IllegalArgumentException(&quot;request cannot be null&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              this.request = request;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      protected void onResponseCommitted() &#123;</span><br><span class="line">          this.request.commitSession();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先要知道response对象存在一个outputBuffer，当某些操作导致response对象被提交的话，会强制将缓冲区的东西发送给客户端并清理缓冲区。</p><p>导致response提交的操作:</p><blockquote><p>1、达到默认最大buffer size<br>2、调用HttpServletResponse.flushBuffer()<br>3、调用HttpServletResponse.getOutputStream().flush()或者HttpServletResponse.getWriter().flush()<br>4、调用HttpServletResponse.sendError()或者HttpServletResponse.sendRedirect()  </p></blockquote><p>继承了OnCommittedResponseWrapper类，这个类会重写这些方法，在清空缓冲区前执行onResponseCommitted()方法，此处就是保证response对象无论何时提交，Spring Session对象都能执行commitSession操作。</p><h3 id="RedisOperationsSessionRepository"><a href="#RedisOperationsSessionRepository" class="headerlink" title="RedisOperationsSessionRepository"></a>RedisOperationsSessionRepository</h3><p>sessionRespository根据session存储的不同分为很多种sessionRepository操作仓库，重点关注下RedisOperationsSessionRepository的源码。</p><p>首先需要了解redisSession保存到redis中的几个关键的key-value:</p><ul><li>key【spring:session:sessions:sessionId】+ value【保存是这个sessionId对应的session的详细信息，包括Session的过期时间间隔、最近的访问时间、attributes等等】这个kv的过期时间是session最大过期时间+5分钟</li><li>key【spring:session:sessions:expires:sessionId】+ value【不保存有效信息】这个kv在redis中的过期时间就是session的过期时间</li><li>key【spring:session:expirations:expiration】+value【是一个set结构，保存的是expiration时间戳的sessionid的集合】这个key里面的expiration表示的是session过期时间滚动到下一分钟的时间戳，意思就是在到达这个时间点时，集合里面的sessionId刚刚过期小于1分钟</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 如下是RedisSession的关键属性</span><br><span class="line">*/</span><br><span class="line">final class RedisSession implements Session &#123;</span><br><span class="line">    //MapSession是RedisSession的本地缓存，从redis中取出session后将session属性保存在MapSession中，通过getAttribute获得属性</span><br><span class="line">    private final MapSession cached;</span><br><span class="line">    //</span><br><span class="line">    private Instant originalLastAccessTime;</span><br><span class="line">    //delta数据用于跟踪数据的变化，持久化到redis中</span><br><span class="line">    private Map&lt;String, Object&gt; delta;</span><br><span class="line">    private boolean isNew;</span><br><span class="line">    private String originalPrincipalName;</span><br><span class="line">    private String originalSessionId;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public RedisOperationsSessionRepository.RedisSession createSession() &#123;</span><br><span class="line">    RedisOperationsSessionRepository.RedisSession redisSession = new RedisOperationsSessionRepository.RedisSession();</span><br><span class="line">    if (this.defaultMaxInactiveInterval != null) &#123;</span><br><span class="line">        redisSession.setMaxInactiveInterval(Duration.ofSeconds((long)this.defaultMaxInactiveInterval));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return redisSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是createSession调用RedisSession构造方法创建一个session。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public void save(RedisOperationsSessionRepository.RedisSession session) &#123;</span><br><span class="line">    //调用redisSession的saveSetla持久化session</span><br><span class="line">    session.saveDelta();</span><br><span class="line">    if (session.isNew()) &#123;</span><br><span class="line">        //如果session为新创建的则发布一个session创建的事件</span><br><span class="line">        String sessionCreatedKey = this.getSessionCreatedChannel(session.getId());</span><br><span class="line">        this.sessionRedisOperations.convertAndSend(sessionCreatedKey, session.delta);</span><br><span class="line">        session.setNew(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* redisSession的save方法，用于将变化的属性保存到delta中，并持久化到redis</span><br><span class="line">*/</span><br><span class="line">private void saveDelta() &#123;</span><br><span class="line">    String sessionId = this.getId();</span><br><span class="line">    /**</span><br><span class="line">    * sessionId</span><br><span class="line">    */</span><br><span class="line">    this.saveChangeSessionId(sessionId);</span><br><span class="line">    /**</span><br><span class="line">    * delta为空，表示没有改变的数据</span><br><span class="line">    */</span><br><span class="line">    if (!this.delta.isEmpty()) &#123;</span><br><span class="line">        RedisOperationsSessionRepository.this.getSessionBoundHashOperations(sessionId).putAll(this.delta);</span><br><span class="line">        String principalSessionKey = RedisOperationsSessionRepository.getSessionAttrNameKey(FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME);</span><br><span class="line">        String securityPrincipalSessionKey = RedisOperationsSessionRepository.getSessionAttrNameKey(&quot;SPRING_SECURITY_CONTEXT&quot;);</span><br><span class="line">        if (this.delta.containsKey(principalSessionKey) || this.delta.containsKey(securityPrincipalSessionKey)) &#123;</span><br><span class="line">            String principal;</span><br><span class="line">            if (this.originalPrincipalName != null) &#123;</span><br><span class="line">                principal = RedisOperationsSessionRepository.this.getPrincipalKey(this.originalPrincipalName);</span><br><span class="line">                RedisOperationsSessionRepository.this.sessionRedisOperations.boundSetOps(principal).remove(new Object[]&#123;sessionId&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            principal = RedisOperationsSessionRepository.PRINCIPAL_NAME_RESOLVER.resolvePrincipal(this);</span><br><span class="line">            this.originalPrincipalName = principal;</span><br><span class="line">            if (principal != null) &#123;</span><br><span class="line">                String principalRedisKey = RedisOperationsSessionRepository.this.getPrincipalKey(principal);</span><br><span class="line">                RedisOperationsSessionRepository.this.sessionRedisOperations.boundSetOps(principalRedisKey).add(new Object[]&#123;sessionId&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">        * 清空delta，表示delta里的数据已经入库了</span><br><span class="line">        */</span><br><span class="line">        this.delta = new HashMap(this.delta.size());</span><br><span class="line">        /**</span><br><span class="line">        * 更新过期时间，时间是依次下沿至下一时间间隔</span><br><span class="line">        */</span><br><span class="line">        Long originalExpiration = this.originalLastAccessTime != null ? this.originalLastAccessTime.plus(this.getMaxInactiveInterval()).toEpochMilli() : null;</span><br><span class="line">        /**</span><br><span class="line">        * 更新session的三个key</span><br><span class="line">        */</span><br><span class="line">        RedisOperationsSessionRepository.this.expirationPolicy.onExpirationUpdated(originalExpiration, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>save方法完成redisSession的持久化操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private RedisOperationsSessionRepository.RedisSession getSession(String id, boolean allowExpired) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 根据sessionid从redis中取出map结构，保存的是这个sessionId对应的session的参数，是一个map结构</span><br><span class="line">    */</span><br><span class="line">    Map&lt;Object, Object&gt; entries = this.getSessionBoundHashOperations(id).entries();</span><br><span class="line">    if (entries.isEmpty()) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 这个方法下面有介绍，就是将entries转为mapSession结构</span><br><span class="line">        */</span><br><span class="line">        MapSession loaded = this.loadSession(id, entries);</span><br><span class="line">        /**</span><br><span class="line">        * 如果不允许session过期allowExpired=false且mapSession对应的redisSession没有过期</span><br><span class="line">        */</span><br><span class="line">        if (!allowExpired &amp;&amp; loaded.isExpired()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //将mapSession转成redisSession</span><br><span class="line">            RedisOperationsSessionRepository.RedisSession result = new RedisOperationsSessionRepository.RedisSession(loaded);</span><br><span class="line">            result.originalLastAccessTime = loaded.getLastAccessedTime();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private MapSession loadSession(String id, Map&lt;Object, Object&gt; entries) &#123;</span><br><span class="line">    MapSession loaded = new MapSession(id);</span><br><span class="line">    Iterator var4 = entries.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    //找到session的参数填入到MapSession中</span><br><span class="line">    while(var4.hasNext()) &#123;</span><br><span class="line">        Entry&lt;Object, Object&gt; entry = (Entry)var4.next();</span><br><span class="line">        String key = (String)entry.getKey();</span><br><span class="line">        if (&quot;creationTime&quot;.equals(key)) &#123;</span><br><span class="line">            loaded.setCreationTime(Instant.ofEpochMilli((Long)entry.getValue()));</span><br><span class="line">        &#125; else if (&quot;maxInactiveInterval&quot;.equals(key)) &#123;</span><br><span class="line">            loaded.setMaxInactiveInterval(Duration.ofSeconds((long)(Integer)entry.getValue()));</span><br><span class="line">        &#125; else if (&quot;lastAccessedTime&quot;.equals(key)) &#123;</span><br><span class="line">            loaded.setLastAccessedTime(Instant.ofEpochMilli((Long)entry.getValue()));</span><br><span class="line">        &#125; else if (key.startsWith(&quot;sessionAttr:&quot;)) &#123;</span><br><span class="line">            loaded.setAttribute(key.substring(&quot;sessionAttr:&quot;.length()), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return loaded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 考虑一下其过期方法，即查找的时候会判断mapSession有没有过期，当前时间减去失效时间小于上一次的访问时间，认为session有效</span><br><span class="line">*/</span><br><span class="line">public boolean isExpired() &#123;</span><br><span class="line">    return this.isExpired(Instant.now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean isExpired(Instant now) &#123;</span><br><span class="line">    if (this.maxInactiveInterval.isNegative()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return now.minus(this.maxInactiveInterval).compareTo(this.lastAccessedTime) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后getSession方法根据sessionId获得RedisSession。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void deleteById(String sessionId) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 根据sessionId获得session，allowExpore参数为true，表示过期了就不创建新的了</span><br><span class="line">    */</span><br><span class="line">    RedisOperationsSessionRepository.RedisSession session = this.getSession(sessionId, true);</span><br><span class="line">    if (session != null) &#123;</span><br><span class="line">        //清除当前session数据的索引</span><br><span class="line">        this.cleanupPrincipalIndex(session);</span><br><span class="line">        //这个onDelete方法删除的是【spring:session:expirations:expiration】这个key的过期时间集合里面删除sessionId</span><br><span class="line">        this.expirationPolicy.onDelete(session);</span><br><span class="line">        //这个删除的是【spring:session:sessions:expires:sessionId】key 这个是表示sessionId的过期时间的key</span><br><span class="line">        String expireKey = this.getExpiredKey(session.getId());</span><br><span class="line">        this.sessionRedisOperations.delete(expireKey);</span><br><span class="line">        //将session有效期设置为0，可见删除方法并没有直接从redis中删除session信息的key</span><br><span class="line">        session.setMaxInactiveInterval(Duration.ZERO);</span><br><span class="line">        this.save(session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据sessionId删除session，首先删除了过期时间集合中的sessionId，以及与session过期时间相同的redis的key值，然后将session的有效期设置为0，即 使这个session失效而不是从redis中删除，而是更新其在redis中的失效时间并保存，此处采用的是惰性删除，让其自然过期且无法访问，对内存不友好，对cpu友好。</p><h3 id="spring-session中的事件传播机制-redis向"><a href="#spring-session中的事件传播机制-redis向" class="headerlink" title="spring session中的事件传播机制 redis向"></a>spring session中的事件传播机制 redis向</h3><p>Spring Session中事件传播的实现如下:</p><p><img src="%E5%9B%BE1.png" alt="spring session事件传播流程图"></p><p>Spring Session的事件类型： </p><ul><li>session创建事件</li><li>session过期事件</li><li>session删除事件</li></ul><p>首先Spring Session事件的顶层是ApplicationEvent 是基于Spring的事件传播机制的，RedisOperationsSessionRepository负责session的出入库，必然是SessionEvent的事件发布者，持有事件发布者对象ApplicationEventPublisher，在RedisHttpSessionConfiguration中创建Bean的时候就会注入上下文中的applicationEventPublisher Bean对象。对于事件的监听则由开发者自己实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SessionEventListener implements ApplicationListener&lt;SessionCreatedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(SessionCreatedEvent event) &#123;</span><br><span class="line">        //当session创建的时候doSomething</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上图可知，Spring Session发布何种事件是由redis的键空间通知机制触发的。</p><p>RedisOperationsSessionRepository实现spring-data-redis中的MessageListener接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RedisOperationsSessionRepository implements FindByIndexNameSessionRepository&lt;RedisOperationsSessionRepository.RedisSession&gt;, MessageListener &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 这个方法在RedisOperationsSessionRepository构造方法中就会触发，设置监听redis事件的sessionChannel</span><br><span class="line">    */</span><br><span class="line">    private void configureSessionChannels() &#123;</span><br><span class="line">        this.sessionCreatedChannelPrefix = this.namespace + &quot;event:&quot; + this.database + &quot;:created:&quot;;</span><br><span class="line">        this.sessionDeletedChannel = &quot;__keyevent@&quot; + this.database + &quot;__:del&quot;;</span><br><span class="line">        this.sessionExpiredChannel = &quot;__keyevent@&quot; + this.database + &quot;__:expired&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 用于监听redis的键空间通知并发布spring的事件</span><br><span class="line">    */</span><br><span class="line">    public void onMessage(Message message, byte[] pattern) &#123;</span><br><span class="line">        byte[] messageChannel = message.getChannel();</span><br><span class="line">        byte[] messageBody = message.getBody();</span><br><span class="line">        String channel = new String(messageChannel);</span><br><span class="line">        if (channel.startsWith(this.sessionCreatedChannelPrefix)) &#123;</span><br><span class="line">            Map&lt;Object, Object&gt; loaded = (Map)this.defaultSerializer.deserialize(message.getBody());</span><br><span class="line">            this.handleCreated(loaded, channel);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String body = new String(messageBody);</span><br><span class="line">            if (body.startsWith(this.getExpiredKeyPrefix())) &#123;</span><br><span class="line">                boolean isDeleted = channel.equals(this.sessionDeletedChannel);</span><br><span class="line">                if (isDeleted || channel.equals(this.sessionExpiredChannel)) &#123;</span><br><span class="line">                    int beginIndex = body.lastIndexOf(&quot;:&quot;) + 1;</span><br><span class="line">                    int endIndex = body.length();</span><br><span class="line">                    String sessionId = body.substring(beginIndex, endIndex);</span><br><span class="line">                    RedisOperationsSessionRepository.RedisSession session = this.getSession(sessionId, true);</span><br><span class="line">                    if (session == null) &#123;</span><br><span class="line">                        logger.warn(&quot;Unable to publish SessionDestroyedEvent for session &quot; + sessionId);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(&quot;Publishing SessionDestroyedEvent for session &quot; + sessionId);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    this.cleanupPrincipalIndex(session);</span><br><span class="line">                    if (isDeleted) &#123;</span><br><span class="line">                        this.handleDeleted(session);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        this.handleExpired(session);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> spring-boot </tag>
            
            <tag> spring-session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>threadLocal分析</title>
      <link href="/2020/05/14/threadLocal%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/14/threadLocal%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal分析-jdk1-8"><a href="#ThreadLocal分析-jdk1-8" class="headerlink" title="ThreadLocal分析 jdk1.8"></a>ThreadLocal分析 jdk1.8</h1><h2 id="ThreadLocal的get、set方法"><a href="#ThreadLocal的get、set方法" class="headerlink" title="ThreadLocal的get、set方法"></a>ThreadLocal的get、set方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">     return t.threadLocals;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上可见 会根据当前线程对象获得线程内置的ThreadLocalMap属性。</p><p>在分析ThreadLocalMap之前先关注ThreadLocal的关键属性。</p><h2 id="ThreadLocal基本属性"><a href="#ThreadLocal基本属性" class="headerlink" title="ThreadLocal基本属性"></a>ThreadLocal基本属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final int threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">private static AtomicInteger nextHashCode =</span><br><span class="line">    new AtomicInteger();</span><br><span class="line"></span><br><span class="line">private static final int HASH_INCREMENT = 0x61c88647;</span><br><span class="line"></span><br><span class="line">private static int nextHashCode() &#123;</span><br><span class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中threadLocalHashCode表示当前ThreadLocal对象在对应线程的ThreadLocalMap里的位置。</p><p> 每次都通过<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextHashCode()</span><br></pre></td></tr></table></figure><br> 方法获得下一个ThreadLocal对象的偏移量的地址，之所以确认HASH_INCREMENT的值为0x61c88647是应用了某种算法，暂不考虑，保证分布均匀。</p><h2 id="ThreadLocalMap分析"><a href="#ThreadLocalMap分析" class="headerlink" title="ThreadLocalMap分析"></a>ThreadLocalMap分析</h2><h3 id="ThreadLocalMap基本属性"><a href="#ThreadLocalMap基本属性" class="headerlink" title="ThreadLocalMap基本属性"></a>ThreadLocalMap基本属性</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; </span><br><span class="line">&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) </span><br><span class="line">    &#123; </span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final int INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">private Entry[] table;</span><br><span class="line"></span><br><span class="line">private int size = 0;</span><br><span class="line"></span><br><span class="line">private int threshold; // Default to 0</span><br><span class="line">private void setThreshold(int len) &#123;</span><br><span class="line">    threshold = len * 2 / 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 包括内置的实现了WeakReference弱引用的Entry静态对象，初始化的默认容量16，entry数组，thresholld为重hash阈值，此处为总容量的2/3。</p><p> <strong>这里注意构造方法</strong>，传进来的ThreadLocal对象，传到了WeakReference中将这条指向threadLocal的引用封装成了弱引用，那么这个key作为对象的引用在外部的强引用置空以后，这个弱引用就只能活到下一次GC，但是在ThreadLocalMap中仍然会残留一个null，value的键值对。造成内存泄漏，因此当一个对象不使用了以后，要主动调用threadLocal.remove()方法删除这条记录。</p><h3 id="ThreadLocalMap构造方法"><a href="#ThreadLocalMap构造方法" class="headerlink" title="ThreadLocalMap构造方法"></a>ThreadLocalMap构造方法</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">    size = 1;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 做了这么几件事：</p><ol><li>初始entry数组</li><li>hashCode与2次幂相与求余数作为table里的索引</li><li>new一个Entry保存key与value，key是threadLocal对象，value是值</li><li>size=1</li><li>设置重hash阈值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    int len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = new Entry[len];</span><br><span class="line"></span><br><span class="line">    for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            if (key != null) &#123;</span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = new Entry(key, value);</span><br><span class="line">                int h = key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                while (table[h] != null)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个构造方法，用于把父线程的entry数组拷贝到当前线程中。</p><h3 id="ThreadLocalMap重要方法"><a href="#ThreadLocalMap重要方法" class="headerlink" title="ThreadLocalMap重要方法"></a>ThreadLocalMap重要方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据ThreadLocal对象获得Entry。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line"></span><br><span class="line">    while (e != null) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        if (k == key)</span><br><span class="line">            return e;</span><br><span class="line">        if (k == null)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        else</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Entry不存在或者entry的key不等于当前threadLocal对象就调用这个方法。</p><p>如果entry的key不等于当前threadLocal对象，则从i往后遍历entry数组直到找到相等的entry返回，若碰到k==null调用expungeStaleEntry</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line"></span><br><span class="line">    // expunge entry at staleSlot</span><br><span class="line">    tab[staleSlot].value = null;</span><br><span class="line">    tab[staleSlot] = null;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    // Rehash until we encounter null</span><br><span class="line">    Entry e;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            e.value = null;</span><br><span class="line">            tab[i] = null;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">            if (h != i) &#123;</span><br><span class="line">                tab[i] = null;</span><br><span class="line"></span><br><span class="line">                // Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="line">                // null because multiple entries could have been stale.</span><br><span class="line">                while (tab[h] != null)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expungeStaleEntry(int staleSlot)方法将staleSlot索引的entry从table里面清理掉，范围是从staleSlot索引位置往后到下一个entry为空的i，返回i，然后rehash将entry数组重新定位索引，有重复的索引就线性探测法往后找空的。之所以要循环判断k==null并清理，是因为entry为弱引用，活到下一次GC就回收了很容易为空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">    // We don&#x27;t use a fast path as with get() because it is at</span><br><span class="line">    // least as common to use set() to create new entries as</span><br><span class="line">    // it is to replace existing ones, in which case, a fast</span><br><span class="line">    // path would fail more often than not.</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">    for (Entry e = tab[i];</span><br><span class="line">         e != null;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = new Entry(key, value);</span><br><span class="line">    int sz = ++size;</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法 hash值与len-1相与获得索引值，从i往后遍历entry数组</p><ul><li>期间碰到key相同的就意味着找到了，更新value返回。</li><li>如果entry的key为空调用replaceStaleEntry(key, value, i)方法返回</li></ul><p>遍历结束找到一个索引i对应的entry为空的位置，保存新entry，更新size，然后不满足cleanSomeSlots(i, sz)方法（表示从i往后的一个范围里没有过时的entry，返回false）且size比重hash阈值要大就rehash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,int staleSlot) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    int slotToExpunge = staleSlot;</span><br><span class="line">    /**</span><br><span class="line">    * 往前遍历找到staleSlot索引最前边儿key是空的entry的索引i，记录到slotToExpunge里面</span><br><span class="line">    */</span><br><span class="line">    for (int i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        if (e.get() == null)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 从staleSlot往后遍历i</span><br><span class="line">    */</span><br><span class="line">    for (int i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">        * 找到一个key相等的entry则意味着命中了，更新entry的value，然后做一个值的交换，把tab[staleSlot]的entry赋给tab[i]，然后把i的entry赋给tab[staleSlot]，staleSlot就是当前threadLocal的索引</span><br><span class="line">        */</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">            * 如果此时仍然没有找到一个key为空的entry，则更新slotToExpunge为当前索引i</span><br><span class="line">            */</span><br><span class="line">            if (slotToExpunge == staleSlot)&#123;</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line">            /**</span><br><span class="line">            * 从slotToExpunge位置开始往后遍历清理过时数据，然后cleanSomeSlots方法，这个方法</span><br><span class="line">            */</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">        * 这是往后找到key为空，并且要slotToExpunge == staleSlot（相等说明staleSlot往前遍历时前面的索引没有key空的entry存在，则更新一次slotToExpunge为staleSlot往后最近的key为空的索引，这么做是为了保证这个索引是整个table里最靠前的key为空的索引，之后会从它开始清理过时的entry）</span><br><span class="line">        */</span><br><span class="line">        if (k == null &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 遍历完一遍没有找到entry不为空且key相等的索引位置，就直接赋值就好了</span><br><span class="line">    */</span><br><span class="line">    tab[staleSlot].value = null;</span><br><span class="line">    tab[staleSlot] = new Entry(key, value);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 这里不等说明找到了entry不为空且key为空的索引位置</span><br><span class="line">    */</span><br><span class="line">    if (slotToExpunge != staleSlot)&#123;</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,int staleSlot)方法用于清洗map里的过期数据，即entry不为空但是k为空的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private boolean cleanSomeSlots(int i, int n) &#123;</span><br><span class="line">    boolean removed = false;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    do &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        if (e != null &amp;&amp; e.get() == null) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = true;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ( (n &gt;&gt;&gt;= 1) != 0);</span><br><span class="line">    return removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cleanSomeSlots(int i, int n)方法主要从i往后寻找entry不为空且key为空的entry，调用expungeStaleEntry(i)方法清理掉这些过时的entry，n的作用是每次除以2，起到控制循环次数的作用。如果在n变为0的次数里面没有过时的entry，则返回false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void rehash() &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    // Use lower threshold for doubling to avoid hysteresis</span><br><span class="line">    if (size &gt;= threshold - threshold / 4)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rehash()方法:</p><ul><li>调用expungeStaleEntries()方法从0到len清理过时的entry</li><li>如果size大于rehash阈值的3/4就扩容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void resize() &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    int oldLen = oldTab.length;</span><br><span class="line">    int newLen = oldLen * 2;</span><br><span class="line">    Entry[] newTab = new Entry[newLen];</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    for (int j = 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            if (k == null) &#123;</span><br><span class="line">                e.value = null; // Help the GC</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int h = k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                while (newTab[h] != null)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resize()方法为扩容方法，新创建一个容量2倍的entry数组，遍历旧entry数组，同时使用线性探测法解决冲突，将旧entry保存到新entry数组，更新重hash阈值、size、table。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring bean 生命周期</title>
      <link href="/2020/04/26/spring-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/04/26/spring-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="先总结主要流程"><a href="#先总结主要流程" class="headerlink" title="先总结主要流程"></a>先总结主要流程</h1><ol><li>obtainBeanFactory(); 创建BeanFactory，就是将配置类和xml里的Bean类注册到BeanDefinition中。</li><li>然后注册BeanFactory的一些后置处理器。</li><li>执行BeanFactory的BeanDefinitionRegistryPostProcessor完成Bean的注册工作。</li><li>注册Bean的后置处理器</li><li>初始化国际化相关的类</li><li>初始化事件驱动机制的事件注册表</li><li>注册事件监听器</li><li>finishBeanFactoryInitialization开始生成Bean，在Bean的生命周期前后都有后置处理器执行</li><li>后续自己悟</li></ol><h1 id="spring-bean-生命周期"><a href="#spring-bean-生命周期" class="headerlink" title="spring bean 生命周期"></a>spring bean 生命周期</h1><p>ConfigurableApplicationContext中的refresh()方法，其中几个重要步骤：</p><ol><li>prepareRefresh();//刷新前的预处理<ul><li>initPropertySource();//初始化一些属性设置</li><li>getEnvironment().validateRequiredProperties();//验证属性合法性</li><li><code>earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();//保存容器中的一些事件</code></li></ul></li><li>obtainBeanFactory();<ul><li>refreshBeanFactory();//创建beanFactory，根据配置加载bean到beanFactory中为BeanDefinitionMap，其中保存的是bean的定义信息，完成bean的注册。</li></ul></li><li>prepareBeanFactory(beanFactory);<ul><li>设置BeanFactory的类加载器</li><li>添加部分BeanPostProcessor【ApplicationContextAwareProcessor】</li><li>设置忽略的自动装配接口EnvironmentAware、EmbeddedValueResolverAware、xxx</li><li>注册可以解析的自动装配:BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</li><li>添加BeanPostProcessor【ApplicationListenerDetector】</li><li>添加编译时的AspectJ</li><li>给BeanFactory中测试一些能用的组件:environment【ConfigurableEnvironment】、<br>systemProperties【Map&lt;String, Object&gt;】、<br>systemEnvironment【Map&lt;String, Object&gt;】</li></ul></li><li>postProcessBeanFactory(beanFactory);<ul><li>如果子类实现了BeanFactoryPostProcessor接口的postProcessBeanFactory(beanFactory)后置处理器方法，则此时调用这些方法</li></ul></li><li>invokeBeanFactoryPostProcessors(beanFactory);<ul><li>执行BeanFactoryPostProcessor后置处理器的postProcessBeanFactory(beanFactory)方法</li><li>包含两个接口:BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor</li><li>先执行BeanDefinitionRegistryPostProcessor<ul><li>获取所有实现了BeanDefinitionRegistryPostProcessor接口的后置处理器</li><li>首先执行实现了PriorityOrdered优先级接口的后置处理器 <code>postProcessor.postProcessBeanDefinitionRegistry(registry)</code></li><li>然后执行实现了Ordered顺序接口的后置处理器 <code>postProcessor.postProcessBeanDefinitionRegistry(registry)</code></li><li>最后执行没有优先级接口与顺序接口的后置处理器<code>postProcessor.postProcessBeanDefinitionRegistry(registry)</code></li></ul></li><li>然后执行BeanFactoryPostProcessor<ul><li>获取所有实现了BeanFactoryPostProcessor接口的后置处理器</li><li>首先执行实现了PriorityOrdered优先级接口的后置处理器 <code>postProcessor.postProcessBeanFactory()</code></li><li>然后执行实现了Ordered顺序接口的后置处理器 <code>postProcessor.postProcessBeanFactory()</code></li><li>最后执行没有优先级接口与顺序接口的后置处理器 <code>postProcessor.postProcessBeanFactory()</code></li></ul></li></ul></li><li>registerBeanPostProcessors(beanFactory);//注册Bean的后置处理器<ul><li>不同接口类型的BeanPostProcessor，在bean创建前后的执行时机也不同，例：<code>-。-</code></li><li>获取所有的BeanPostProcessor后置处理器；后置处理器都可以使用PriorityOrdered、Ordered接口来设置执行的优先级</li><li>先注册了实现PriorityOrdered接口的BeanPostProcessor到BeanFactory中:<code>beanFactory.addBeanPostProcessor(postProcessor);</code></li><li>然后注册Ordered接口的</li><li>最后注册没有实现优先级接口与顺序接口的</li><li>然后注册MergedBeanDefinitionPostProcessor</li><li>然后注册一个ApplicationListenerDetector，用于判断bean创建完成后检查是否是ApplicationListener，如果是添加监听器<code>applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</code></li></ul></li><li>initMessageSource();<ul><li>获取beanFactory</li><li>看容器中是否有id为messageSource，类型为MessageSource的组件</li><li>如果有，赋值给messageSource，如果没有创建一个DelegatingMessageSource；</li><li>把创建好大的messageSource注册到容器中，获取国际化配置文件的值的时候，可以自动注入MessageSource <code>beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);</code></li></ul></li><li>initApplicationEventMulticaster();//初始化事件注册表，用于根据事件类型获得其对应的监听器集合<ul><li>获取beanFactory</li><li>从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster</li><li>如果上一步为空，则创建一个SimpleApplicationEventMulticaster添加到beanFactory中</li></ul></li><li>onRefresh();//子类重写此方法，容器刷新时自定义逻辑</li><li>registerListeners();//将容器中的ApplicationListener注册到ApplicationEventMulticaster中</li><li>finishBeanFactoryInitialization(beanFactory);//初始化剩下的所有单实例bean<ul><li>beanFactory.preIntantiateSingletons();<ul><li>判断是否是FactoryBean；是否是实现了FactoryBean接口的bean</li><li>若不是工厂bean，则利用getBean方法开始创建bean</li><li>getBean(beanName) -&gt; doGetBean()</li><li>transformedBeanName(name);//处理bean的别名</li><li><code>Object sharedInstance = getSingleton(beanName);//从spring的缓存中获得bean</code></li><li><code>BeanFactory parentBeanFactory = this.getParentBeanFactory();//获得bean的父容器，如果该容器不为空，且包含beanName的定义信息，从该容器中返回bean</code></li><li><code>RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);//上面的步骤都没有获得bean的实例则开始创建，首先获得bean的定义信息</code></li><li>从beanDefinition中获得当前bean DependOn的bean(由@DependsOn或标签depend-on定义，表示当前Bean依赖的bean集合)，循环初始化这些beanName的实例，通过getBean(beanName)方法<ul><li><code>String[] dependsOn = mbd.getDependsOn();//获得当前bean依赖的beanName集合</code></li><li>循环遍历dependsOn集合（spring中的dependentBeanMap表示【依赖我的】集合，dependenciesForBeanMap表示【我依赖的】集合）<ul><li>判断<code>this.isDependent(beanName, dep)</code>为false继续执行，为true表明存在循环依赖，抛错（判断dependentBeanMap是否包含dep），这里是禁止循环依赖的</li><li><code>registerDependentBean(dep, beanName);</code>注册当前beanName到dep的dependentBeanMap集合中去</li><li><code>getBean(dep);</code>加载这些依赖的bean</li></ul></li></ul></li><li>根据beanDefinition mbd中当前bean是Singleton还是Prototype或是其他作用域执行不同的创建实例的方法</li><li>对于Singleton而言进行了一层同步回调与单例控制，对于Prototype则直接创建新的实例</li><li><code>instance = this.createBean(beanName, mbd, args);//开始创建单实例bean</code></li><li><code>beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);//让实现了【InstantiationAwareBeanPostProcessor】接口的后置处理器执行postProcessBeforeInstantiation()方法，如果postProcessBeforeInstantiation()方法的返回值不为null，则调用postProcessAfterInitialization()方法</code></li><li><code>beanInstance = this.doCreateBean(beanName, mbdToUse, args);//创建bean的方法</code><ul><li>【创建Bean实例】<code>BeanWrapper instanceWrapper = this.createBeanInstance(beanName, mbd, args);//利用工厂方法或者对象的构造器创建出Bean实例</code></li><li><code>this.singletonFactories.put(beanName, singletonFactory);this.earlySingletonObjects.remove(beanName);</code>【如果允许循环依赖，第一次暴露bean的引用，解决循环依赖问题】，即将刚刚实例化结束的对象暴露出去，暂存到三级缓存singletonFactories中，同时清理二级缓存earlySingletonObjects</li><li><code>this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);//</code></li><li>【Bean属性赋值】<code>this.populateBean(beanName, mbd, instanceWrapper);//Bean属性赋值</code><ul><li>获取InstantiationAwareBeanPostProcessor后置处理器，调用postProcessAfterInstantiation()</li><li>获取nstantiationAwareBeanPostProcessor后置处理器，调用postProcessPropertyValues()</li><li>applyPropertyValues(beanName, mbd, bw, pvs);//使用setter方法为bean属性赋值</li></ul></li><li>【Bean初始化】<code>this.initializeBean(beanName, exposedObject, mbd);//初始化Bean</code><ul><li>【执行Aware接口方法】<code>this.invokeAwareMethods(beanName, bean);//执行xxxAware接口的方法，BeanNameAware\BeanClassLoaderAware\BeanFactoryAware Aware接口是spring将对应数据暴露出去的一种方式</code></li><li>【执行后置处理器初始化之前】<code>wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName);//方法中会执行后置处理器的beanPostProcessor.postProcessBeforeInitialization()方法</code></li><li>【执行初始化方法】<code>this.invokeInitMethods(beanName, wrappedBean, mbd);</code><ul><li>判断有没有实现InitializingBean接口，如果实现了则调用afterPropertiesSet方法</li><li>如果配置了init-method则执行自定义的初始化方法</li></ul></li><li>【执行后置处理器初始化之后】<code>wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);//方法中会执行后置处理器的beanPostProcessor.postProcessAfterInitialization()方法</code></li><li>【获得二级缓存中的对象，若不为空说明存在循环依赖，需要第二次暴露bean的引用，解决循环依赖会导致的一种问题】若当前对象A的引用发生了变化，且存在循环依赖，对象为B，要提前创建B，创建B的时候会通过getSingleton()方法获得A，这时候是从三级缓存中取得刚刚实例化的A引用，并放入到二级缓存中，如果A发生了变化，且B创建成功了说明B中的A与当前A不一样，违反了单例，报错，因此第二次暴露的代码放在下面。<ul><li><code>Object earlySingletonReference = this.getSingleton(beanName, false);//获得二级缓存中的对象</code>如果这个对象不为null，说明存在循环引用，因为只有循环引用创建时会将缓存从三级移入到二级缓存</li></ul></li></ul></li><li><code>this.registerDisposableBeanIfNecessary(beanName, bean, mbd);//注册Bean的销毁方法</code></li></ul></li><li><code>if (newSingleton) &#123;this.addSingleton(beanName, singletonObject);&#125;</code>如果是Singleton作用域，则会调用上述方法，将初始化完毕的实例更新到一级缓存singletonObjects，并清空二级缓存与三级缓存，如果是其他作用域没有这一步。</li></ul></li></ul></li><li>finishRefresh();//完成BeanFactory初始化创建工作。ioc容器创建完成。<ul><li>initLifecycleProcessor();//初始化和生命周期有关的后置处理器LifecycleProcessor</li><li>getLifecycleProcessor().onRefresh();//拿到前面定义的生命周期后置处理器，回调onRefresh()</li><li>publishEvent(new ContextRefreshedEvent(this));//发布容器刷新完成事件</li><li>LiveBeansView.registerApplicationContext(this);</li></ul></li></ol><h2 id="为什么要二次暴露bean的引用"><a href="#为什么要二次暴露bean的引用" class="headerlink" title="为什么要二次暴露bean的引用?"></a>为什么要二次暴露bean的引用?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">//尝试从缓存中获取单例，注意后面的参数为false，表示不从第三级缓存singletonFactories中获取，为什么呢？因为这里不允许循环依赖</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//如果不为null，就会进入if条件中，因为earlySingletonReference不为null，说明存在循环引用，</span></span><br><span class="line"><span class="comment">//为什么呢？因为第一个处理的时候，会将引用放到singletonFactories缓存中，当循环依赖注入的时候，</span></span><br><span class="line"><span class="comment">//会通过singletonFactories中拿到提前暴露的引用，然后放到第二级缓存earlySingletonObjects中。</span></span><br><span class="line"><span class="comment">//所以，在这里拿到了earlySingletonReference，表明存在循环引用。</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果相等，那么就什么也不做，将earlySingletonReference返回回去即可</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不相等（具体为什么会不相等，下面会单独说），并且有其它bean依赖这个bean</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">    <span class="comment">//拿到依赖这个bean的所有bean</span></span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">    <span class="comment">//如果存在已经创建完的bean（已经创建完的bean依赖该bean）</span></span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果真的存在，那么就会报错，现在创建成功的对象里注入的当前bean与我现在创建完的bean的对象实例不一样，为什么实例化的对象引用与创建完的对象引用会不一样呢，参考上面初始化部分的流程，在Bean初始化前后，bean后置处理器的初始化方法有可能修改bean的实例的，那些在已经判断两个bean不一样了，违反了单例就直接报错了。</span></span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
            <tag> spring bean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm垃圾收集过程</title>
      <link href="/2020/04/26/jvm-gc-process/"/>
      <url>/2020/04/26/jvm-gc-process/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm垃圾收集过程"><a href="#jvm垃圾收集过程" class="headerlink" title="jvm垃圾收集过程"></a>jvm垃圾收集过程</h1><ol><li>一般对象产生会首先放到Eden区，Eden区空间不足则会放入到From Survivor区，如果仍然放不下，就会触发一次新生代的Minor GC。<ul><li>在Eden区中存活的对象会放入To Survivor区中</li><li>在From Survivor区中存活的对象会放入To Survivor区中，同时给From Survivor区的对象年龄+1，如果达到阈值，就会被放入老年代</li><li>最后会清空Eden区与From Survivor区，不会产生内存碎片，如果在一次Minor GC结束以后，To Survivor区放不下存活的对象，就将这些对象移入老年代</li><li>大对象会直接放入老年代</li></ul></li><li>当执行完一次Minor GC以后，有对象移入老年代，就得分析有没有超过老年代最大剩余空间，超过了就会触发Full GC。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm垃圾收集器G1</title>
      <link href="/2020/04/24/jvm-gc-c1/"/>
      <url>/2020/04/24/jvm-gc-c1/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm垃圾收集器G1"><a href="#jvm垃圾收集器G1" class="headerlink" title="jvm垃圾收集器G1"></a>jvm垃圾收集器G1</h1><h2 id="G1（Garbage-First）"><a href="#G1（Garbage-First）" class="headerlink" title="G1（Garbage-First）"></a>G1（Garbage-First）</h2><p>G1面向服务端应用的垃圾收集器。  </p><p>其他垃圾收集器将堆区分为新生代与老年代来进行垃圾收集，而G1直接对新生代与老年代一起回收。  </p><p>G1将堆划分为多个大小相同的region，记录region垃圾回收的时间与回收获得的空间，维护一个垃圾回收的优先列表。便于预测停顿时间模型。region被分类为Eden、Survivor、Old、Humongous四种类型。</p><p>region被分为多个card，一个card分片一般为512Bytes。</p><p>每个region都具有自己的Remembered Set（Rset），是point into的设计，即逻辑上记录的是其他region的card中的对象（这些对象引用了当前region中某一card的某个对象），实际上Rset的设计是一个HashTable，一条记录的key值是其他region的起始地址，value是一个集合，记录region中的card数组的索引值。</p><h2 id="GC过程"><a href="#GC过程" class="headerlink" title="GC过程"></a>GC过程</h2><p>G1提供了两种GC方式</p><ul><li>Young GC: 回收所有年轻代的Region。当Eden的Region不能再分配内存就会触发，促发以后的GC与普通新生代GC的复制过程类似，不过其标记阶段除了使用GC Root还使用了RSet。</li><li>Mixed GC: 回收所有年轻代的Region与部分老年代的Region。根据预测停顿模型选择回收收益高的old Region满足指定用户开销。-XX:MaxGCPauseMillis 指定G1停顿时间的预测值。</li></ul><h3 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h3><p>主要分为两个阶段:</p><h4 id="1-全局并发标记阶段"><a href="#1-全局并发标记阶段" class="headerlink" title="1.全局并发标记阶段:"></a>1.全局并发标记阶段:</h4><ul><li>初始标记: stw，标记GC Root对象以及GC Root直接可达的对象，将这些对象压入扫描栈，并使用外部的bitmap记录mark信息。</li><li>并发标记: 进行GC Root Tracing，同时会记录这段时间对象引用状态变化到RSet Log里，即不断从扫描栈取出对象引用，在bitmap里将对象mark，然后将对象引用的对象压入扫描栈。</li><li>最终标记: stw，使用RSet Log里的变化修正Rset的引用关系。注意这里最终扫描的是SATB Buffer而不是整个young gen（CMS的最终标记里扫描的就是整个根集合），SATB Buffer是在并发标记阶段，利用write barrier将新插入的引用关系记录下来；利用pre write buffer将即将被删除的引用关系记录下来，用这些新的引用关系与旧的引用关系为根，重新扫描一遍避免漏标。</li><li>清除垃圾: stw，根据next bitmap里存活对象以及RSet统计存活的对象，对RSet进行排序用于下一次CSet收集Region，根据一个Region的Rset有没有其他Region引用，如果完全没有就认为没有活对象，可以整体清除Region。</li></ul><h4 id="2-拷贝存活对象"><a href="#2-拷贝存活对象" class="headerlink" title="2.拷贝存活对象:"></a>2.拷贝存活对象:</h4><ul><li>stw，1、依赖于停顿预测模型，选择停顿少，回收内存多的region进行收集，构成Collect Set，2、扫描这些Region的RSet以及根对象，确认存活的对象，把存活的对象集中拷贝到空闲的Region中，然后回收这些Region。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>空间整合: 符合停顿预测模型的标记-整理算法，局部的region存活对象拷贝到同一region中，减少内存碎片。</li><li>可预测GC停顿时间</li><li>只处理部分Region而不是全堆扫，对大内存比较高效</li></ul><h3 id="介绍一下G1"><a href="#介绍一下G1" class="headerlink" title="介绍一下G1"></a>介绍一下G1</h3><p>G1是一个基于可停顿预测模型的多线程的垃圾处理器，这个处理器同时管理整个堆，将堆内容划分为大小相等的多个Region，Region依然被划分为Eden、Suvivor、Old这些区。</p><p>Region的垃圾处理过程分为三块儿，第一块儿是young GC，与普通的新生代GC类似，如果Eden分区满了向其中使用着的Suvivor区放，如果也放不下触发young GC。</p><p>然后第二块就是全局并发标记，首先初始标记stw，找到GC Root以及跟它直接管理的对象进行标记，然后并发标记，与用户线程一起运行，进行GC Root tracing，标记所有存活对象，期间将对象引用的变化保存到RSet Log里面。然后第三阶段最终标记将RsetLog里的变化修正到RSet里面，同时修改对象的标记关系，漏标的标上，多标的去除标记，第四阶段清除，做两件事吧，根据bitmap与RSet统计不同Region里面存活对象的情况，对Region进行排序。第二件事将没有引用指向当前Region的Region回收掉。 第三块儿，进行存活对象拷贝，根据停顿预测模型选择部分Region构成CSet，将里面存活的对象集中拷贝到另一个Region。回收当前Region。</p><p>优点就是使用了复制算法，没有内存碎片<br>可以预测GC停顿时间<br>可以处理大内存GC，因为只处理部分Region不是全堆扫</p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> G1 </tag>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm知识点复习</title>
      <link href="/2020/04/21/jvm%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
      <url>/2020/04/21/jvm%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、知识点"><a href="#一、知识点" class="headerlink" title="一、知识点"></a>一、知识点</h1><h2 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h2><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆区</li><li>方法区</li><li>运行时常量池</li></ul><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程私有，如果正在执行的方法是java方法，则记录的是字节码指令的地址，如果正在执行的方法是native方法，则记录为空。不会报栈溢出、内存溢出异常。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>线程私有，保存局部变量表、操作数栈、方法出口、动态链接等。栈深度大于虚拟机允许的最大深度，那么会报栈溢出异常。如果虚拟机栈内存不够，且无法申请到新的内存，那么会报内存溢出异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>线程私有，与虚拟机栈类似。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>堆是jvm管理的最大一块内存，线程共享。存放对象实例。是java GC管理的主要区域。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存放已经被加载的类的信息、常量、静态变量、即使编译器编译后的代码等数据。</p><p>从jdk1.8开始，移除永久代，将方法区移到元空间，位于本地内存，而不是jvm被分配的内存。</p><p>永久代里的数据常量池和静态变量放到堆中，类的信息放到元空间里。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池逻辑上属于方法区，1.8版本以后放入堆区。</p><p>主要存 class文件中的常量池在被加载以后会放入这个区域 (编译期间生成的字面量和符号引用)</p><blockquote><p>字面量: 文本字符串等<br>符号引用: 编译原理里的概念包括(类和接口的全限定名、字段名称和描述符、方法名称和描述符)</p></blockquote><p>除了编译期间生成的常量，在运行期间也可以向常量池加常量比如string.intern();</p><blockquote><p>String s1 = “Holl”;   //这是一个纯字面量，(如果常量池没有”Holl”,会先将”Holl”放入常量池，)返回常量池里”Holl”的引用<br>String s2 = new String(“Holl”);//这里(如果Holl不在常量池，先上面一步，然后)创建一个对象，从常量池中返回Holl的引用保存到对象中，s2指向这个对象，所以实际上s2指向的是Holl在常量池里的引用<br>String s3 = new String(“Holl”).intern();//intern方法会判断常量池有没有Holl，如果没有先在常量池放入Holl，然后直接返回Holl的引用给s3，如果常量池有Holl了，直接返回Holl的引用给s3   </p><p>注意:<br>这里s2，不管常量池有没有Holl返回的都是一个对象的引用，这个对象里保存的是Holl在常量池的引用。<br>这里s3，不管常量池有没有Holl返回都是常量池中Holl的引用。<br>当然它们做了同样的操作就是常量池不存在Holl时加入Holl到常量池。  </p><p>思考: s1与s3的最终结论是一样，为什么还存在s3这种用法?<br>因为不是所有的字符串一开始都是字面量，对于变量来说只能使用s3的方法将引用替换成常量池的直接引用。  </p></blockquote><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="parallel-Scavenge垃圾收集器"><a href="#parallel-Scavenge垃圾收集器" class="headerlink" title="parallel Scavenge垃圾收集器"></a>parallel Scavenge垃圾收集器</h4><p>新生代垃圾收集器，多线程<br>其他的垃圾收集器，关注的是最短的停顿时间，而这个垃圾收集器关注吞吐量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量 = 用户程序运行时间/(用户程序运行时间+垃圾收集器停顿时间)</span><br></pre></td></tr></table></figure><p>按这个等式来讲，停顿时间越少，吞吐量应该越大才对，但是漏掉了一个变量，就停顿时间越少，那么触发垃圾收集会越频繁，这就非常不利于高吞吐量的程序。<br>因此为了高吞吐量，停顿时间不能过短也不能过长，寻找一个最优值。</p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>findClass()方法是直接进行使用当前定义类进行加载<br>defineClass()将二进制文件转化为Class对象<br>loadClass()会先进行父加载器查找，没找到才会调用findClass()</p><p>其中findClass与loadClass可以自定义，区别自己悟</p><h3 id="tomcat类加载"><a href="#tomcat类加载" class="headerlink" title="tomcat类加载"></a>tomcat类加载</h3><p>tomcat类加载器的话是违背了双亲委派原则的，首先执行完启动类加载器，以及扩展类加载器以后，执行systemClassLoader加载tomcat启动的类在bin目录下面，</p><p>然后下面就是Tomcat的通用类加载器（包括catalinaLoader与sharedLoader，加载的类位于/lib目录下），以及web应用程序类加载器（加载WEB-INF目录下的classes目录以及lib目录）。</p><p>在加载完启动类加载器、扩展类加载器、系统类加载器以后会优先执行各个Web应用的类加载器。</p><h1 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cas、sso的原理详解</title>
      <link href="/2020/04/19/cas%E3%80%81sso%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/04/19/cas%E3%80%81sso%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CAS组成"><a href="#一、CAS组成" class="headerlink" title="一、CAS组成"></a>一、CAS组成</h1><p>CAS包括CAS Server和CAS Client两部分组成 :</p><h2 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h2><p>CAS Server需要独立部署，用于完成对用户的认证工作，包括用户名/密码的认证、票据的认证。</p><h2 id="CAS-Client"><a href="#CAS-Client" class="headerlink" title="CAS Client"></a>CAS Client</h2><p>CAS Client与受保护的客户端应用部署在一起，用于做登录校验，比如统一后台的服务与CAS客户端一起部署。通过filter的方式过滤从浏览器打到统一后台的每一个请求，分析http请求头中是否包含请求Service Ticket，如果没有则说明用户没有经过认证，于是CAS Client会重定向用户请求到CAS Server登录页面并且会带上浏览器要请求的目标地址，输入用户名和密码进行认证，认证成功会生成一个长度相当、唯一、不可伪造的Service Ticket，并且缓存在CAS Server中，并为客户端浏览器生成一个Ticket Granted Cookie（TGC）并重定向到之前浏览器要访问的目标地址（即CAS Client）（附带上生成的ServiceTicket），这时http头中有ST参数，CAS Client会与CAS Server请求认证ST。认证成功Client创建session返回浏览器。</p><h1 id="二、CAS核心票据"><a href="#二、CAS核心票据" class="headerlink" title="二、CAS核心票据"></a>二、CAS核心票据</h1><h2 id="TGT（Ticket-Granting-Ticket）"><a href="#TGT（Ticket-Granting-Ticket）" class="headerlink" title="TGT（Ticket Granting Ticket）"></a>TGT（Ticket Granting Ticket）</h2><p>TGT是CAS为用户签发的登录凭证，是缓存在CAS Server中的对象，封装了Cookie值以及此Cookie值对应的用户信息。用户在浏览器到Client Server之间认证时使用ssl协议，认证成功后生成的Cookie称为TGC，写入到浏览器头部，同时在CAS Server中生成一个TGT对象放入自己的缓存，TGT对象的ID就是cookie的值。 </p><h2 id="TGC（Ticket-Granting-Ticket）"><a href="#TGC（Ticket-Granting-Ticket）" class="headerlink" title="TGC（Ticket Granting Ticket）"></a>TGC（Ticket Granting Ticket）</h2><p>TGC 是存放用户凭证的key值，也是保存在浏览器的Cookie，当与Client Server通信时，会去Server放入缓存中以Cookie为key查询有没有用户信息，如果有说明登录过，如果没有用户需要重新登录。</p><h2 id="ST（Service-Ticket）cas普通模式"><a href="#ST（Service-Ticket）cas普通模式" class="headerlink" title="ST（Service Ticket）cas普通模式"></a>ST（Service Ticket）cas普通模式</h2><p>ST 是CAS签给浏览器的访问某一服务Service的票据，浏览器访问Service时，Service发现用户没有ST，则重定向到SSO Server获取，如果用户包含TGC，则在SSO Server缓存中查询TGT对象，如果存在TGT对象则会签发一个ST对象，将ST作为请求参数重定向到用户要访问的Service，Service获得ST（ST的ticketGrantingTicket属性值是TGT对象），Service（CAS Client）拿着ST与 SSO Server（即CAS Server） 进行验证认证用户的登录状态返回一个xml数据，包含验证成功的信息，若认证成功则Service与浏览器会建立一个Session关系保留登录成功状态，这个作为session保存登录状态的cookie与CAS无关。</p><h2 id="PGT（Proxy-Granting-Ticket）cas代理模式"><a href="#PGT（Proxy-Granting-Ticket）cas代理模式" class="headerlink" title="PGT（Proxy Granting Ticket）cas代理模式"></a>PGT（Proxy Granting Ticket）cas代理模式</h2><p>PGT 是由ST签发的票据。浏览器持有ST去访问Proxy Service，Proxy Service调用SSO Server（CAS Server）的serviceValidate接口验证ST，若在CAS Server上验证成功，CAS Server会首先调用PGTurl（是一个https url）将生成的PGT及PGTIOU传输给Proxy Service，Proxy Service会以PGTIOUS为key，PGT为value存储在Map中；然后CAS会生成验证ST成功的xml消息（包含PGTIOUS）返回给Proxy Service，Proxy Service拿到PGTIOUS会从自身的缓存map中拿到PGT，从中取出用户信息。（PGT中保存着签发ST的TGT对象）</p><h2 id="PT（Proxy-Ticket）cas代理模式"><a href="#PT（Proxy-Ticket）cas代理模式" class="headerlink" title="PT（Proxy Ticket）cas代理模式"></a>PT（Proxy Ticket）cas代理模式</h2><p>PT 是由PGT签发的票据。类似于TGT签发ST，在代理模式下，PT是用户访问back-end service的票据。当用户访问的是一个Web应用，web应用要求一个ST，那么浏览器拿着TGC去获得ST即可访问Web应用，而对于一个C/S结构的应用，得不到cookie。不能直接访问back-end Service 而是通过访问Proxy Service的接口，凭借Proxy Service的PGT获取PT票据然后访问back-end Service，<br>问题是如何获得PGT票据，那么根访问普通代理模式一样首先重定向到SSO Server，两种情况：<br>1、如果有TGC就与Server的TGT比较，成功则生成ST票据作为请求参数，重定向到Proxy Service<br>2、如果没有TGC，SSO Server返回登录界面，用户填写用户名和密码认证，认证成功生成TGT并返回TGC到浏览器头部，同时签发一个ST票据作为请求参数重定向到Proxy Service<br>通过以上两步任意一步，Proxy Service 或得ST票据与SSO Server进行认证，经过PGT中的步骤获得PGT票据，然后Proxy Service传递PGT与back-end Service的地址给SSO Server获得PT票据，Proxy Service将PT票据作为请求参数调用back-end Service接口，back-end Service获得PT票据调用SSO Server的接口认证PT票据，认证成功则返回业务数据给Proxy Service。</p><h1 id="三、CAS流程解读（普通模式）"><a href="#三、CAS流程解读（普通模式）" class="headerlink" title="三、CAS流程解读（普通模式）"></a>三、CAS流程解读（普通模式）</h1><p><img src="1.jpg" alt="sso流程原理图"></p><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程:"></a>详细过程:</h3><ol><li>用户访问产品 a，域名是 <a href="http://www.a.cn。">www.a.cn。</a></li><li>由于用户没有携带在 a 服务器上登录的 a cookie，所以 a 服务器返回 http 重定向，重定向的 url 是 SSO 服务器的地址，同时 url 的 query 中通过参数指明登录成功后，回跳的a 页面。重定向的url 形如 sso.cn/login?service=https%3A%2F%2F<a href="http://www.a.cn。">www.a.cn。</a></li><li>由于用户没有携带在 SSO 服务器上登录的 TGC（看上面，票据之一），所以 SSO 服务器判断用户未登录，给用户显示统一登录界面。用户在 SSO 的页面上进行登录操作。</li><li>登录成功后，SSO 服务器构建用户在 SSO 登录的 TGT（又一个票据，用于身份验证TGC，并生成ST票据），同时返回一个 http 重定向。这里注意：<blockquote><ul><li>重定向地址为之前写在 query 里的 a 页面。</li><li>重定向地址的 query 中包含 sso 服务器派发的 ST。</li><li>重定向的 http response 中包含写 cookie 的 header。这个 cookie 代表用户在 SSO 中的登录状态，它的值就是 TGC，保存在了sso的域下面，下此访问sso会带上这个cookie。</li></ul></blockquote></li><li>浏览器重定向到产品 a。此时重定向的 url 中携带着 SSO 服务器生成的 ST。</li><li>根据 ST，a 服务器直接向 SSO 服务器发送请求，SSO 服务器验证票据的有效性。验证成功后，a 服务器知道用户已经在 sso 登录了，于是 a 服务器构建用户登录 session，记为 a session。并将 cookie 写入浏览器。注意，此处的 cookie 和 session 保存的是用户在 a 服务器的登录状态，和 CAS 无关。</li></ol><blockquote><p>注意上面只能在同一个浏览器访问的时候才能实现单点登录，因为当用户访问b的时候，这个时候要重定向到sso服务器  sso.cn/login?service=https%3A%2F%2F<a href="http://www.b.cn。">www.b.cn。</a> 由于之前访问a的时候浏览器在sso域下生成了cookie TGC，这时候重定向到sso旧会带上这个TGC，然后sso服务器使用TGC寻找其服务器缓存的TGT对象，并生成一个ST票据，将ST作为query参数重定向回b服务器，这时候b服务器就拿着这个ST直接请求sso服务器验证ST的正确性，验证成功的话，b就构建用户登录 session。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cas </tag>
            
            <tag> sso </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm垃圾收集器CMS</title>
      <link href="/2020/01/24/jvm-gc-cms/"/>
      <url>/2020/01/24/jvm-gc-cms/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm垃圾收集器CMS"><a href="#jvm垃圾收集器CMS" class="headerlink" title="jvm垃圾收集器CMS"></a>jvm垃圾收集器CMS</h1><p>CMS（Concurrent Mark Sweep）并发标记-清除算法。<br>分为四个步骤:</p><ul><li>初始标记: 标记一下与GC roots直接关联的对象，需要全局暂停。 </li><li>并发标记: 进行GC roots tracing 过程，耗时最长，不用暂停，与用户线程并行。</li><li>重新标记: 对并发标记阶段，对象状态发生了变化的对象进行修改，需要全局暂停。</li><li>并发清除: 对前面阶段没有标记的对象进行清除，不用暂停，与用户线程并行。</li></ul><p>优点:</p><ul><li>并发收集</li><li>低停顿</li></ul><p>CMS不足:</p><ul><li>吞吐量低: 暂停时间短，导致gc时间多与用户线程争抢cpu，导致吞吐量低，cpu利用率不高。</li><li>无法处理浮动垃圾，可能出现Concurrent Mode Failure: 浮动垃圾是并发清除阶段，用户线程继续运行而产生的垃圾，这部分垃圾只能下一次GC的时候才能回收。如果预留的内存不足以存放浮动垃圾会出现Concurrent Mode Failure，此时jvm临时启用Serial Old来替代CMS。</li><li>标记-清除算法会产生内存碎片。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> gc </tag>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
